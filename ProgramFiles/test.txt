********************************************** DO NOT REMOVE THIS HEADER **************************************************
You may use the service and the contents contained in these services for your own individual non-commercial purpose only.
Any other use, is strictly prohibited without the permission of the work's  publisher.
Vous pouvez utiliser le service et le contenu de ces services à des fins personnelles et non commerciales uniquement.
Toute autre utilisation est strictement interdite sans l'autorisation de l'éditeur.
****************************************************************************************************************<chapter>
<page>  Object-Oriented Software Engineering Practical software development using UML and JavaSecond edition 
 Lethbridge.book  Page i  Tuesday, November 16, 2004  12:22 PM<page>  
 Lethbridge.book  Page ii  Tuesday, November 16, 2004  12:22 PM<page>  
 Object-Oriented Software 
Engineering 
Practical Software Development using UML and JavaSecond editionTimothy C. LethbridgeRobert Laganière 
London 
 • Burr Ridge, IL • New Y ork • St. Louis • San Francisco •AucklandBogotá • Caracas • Lisbon • Madrid • Mexico • Milan • Montreal • New DelhiPanama • Paris• San Juan • São Paulo • Singapore •Tokyo • Toronto 
 Lethbridge.book  Page iii  Tuesday, November 16, 2004  12:22 PM<page>  
Object-Oriented Software EngineeringT
imothy C LethbridgeRobert LaganièreISBN 0-07-70109082
Published by McGraw-Hill EducationShoppenhangers RoadMaidenheadBerkshire SL62QLTelephone: 44 (0) 1628 502 500Fax: 44 (0) 1628 770 224Website: http://www.mcgraw-hill.co.ukBritish Library Cataloguing in Publication DataA catalogue record for this book is available from the British LibraryLibrary of Congress Cataloguing in Publication DataThe Library of Congress data for this book has been applied for from the Library ofCongressPublishing Director: Catriona KingDevelopment Editor: Karen MosmanMarketing Manager: Alice DuijserSenior Production Manager: Max ElveyText Design by Mike CotterellCover design by Ego CreativeTypeset at Neuadd Bwll, Llanwrtyd WellsPrinted and bound in the UK by Bell & Bain Ltd, GlasgowPublished by McGraw-Hill Education (UK) Limited an imprint of The McGraw-HillCompanies, Inc., 1221 Avenue of the Americas, New Y ork, NY 10020. Copyright © 2005by McGraw-Hill Education (UK) Limited. All rights reserved. No part of thispublication may be reproduced or distributed in any form or by any means, or stored ina database or retrieval system, without the prior written consent of The McGraw-HillCompanies, Inc., including, but not limited to, in any network or other electronicstorage or transmission, or broadcast for distance learning.ISBN 0-07-70109082 © 2005. Exclusive rights by The McGraw-Hill Companies, Inc. formanufacture and export. This book cannot be re-exported from the country to which itis sold by McGraw-Hill. 
 Lethbridge.book  Page iv  Tuesday, November 16, 2004  12:22 PM<page>  
i 
Contents 
Foreword  xi Preface xv Guided tour xxiiTechnology to enhance learning and teaching xxiv 
1 Software and software engineering  1 
1.1 The nature of software 11.2 What is software engineering? 61.3 Software engineering as a branch of the engineering profession 81.4 Stakeholders in software engineering 101.5 Software quality 111.6 Software engineering projects 141.7 Activities common to software projects 161.8 The themes emphasized in this book 201.9 Difficulties and risks in software engineering as a whole 241.10 Summary 261.11 For more information 26 
2 Review of object orientation  29 
2.1 What is object orientation? 292.2 Classes and objects 312.3 Instance variables 362.4 Methods, operations and polymorphism 382.5 Organizing classes into inheritance hierarchies 392.6 The effect of inheritance hierarchies on polymorphism and variable declarations 452.7 Concepts that define object orientation 522.8 A program for manipulating postal codes 552.9 Classes for representing geometric points 572.10 Measuring the quality and complexity of a program 602.11 Difficulties and risks in programming language choice and OO programming 622.12 Summary 632.13 For more information 63 
 Lethbridge.book  Page v  Tuesday, November 16, 2004  12:22 PM<page>  vi 
Contents 
3 Basing software development on reusable technology  67 
3.1 Reuse: building on the work and experience of others 683.2 Incorporating reusability and reuse into software engineering 693.3 Frameworks: reusable subsystems 713.4 The client–server architecture 773.5 Technology needed to build client–server systems 873.6 The Object Client–Server Framework (OCSF) 913.7 Basic description of OCSF – client side 923.8 Basic description of OCSF – server side 953.9 An instant messaging application using the OCSF 993.10 Difficulties and risks when considering reusable technology and client–server systems 1013.11 Summary 1023.12 For more information 103 
4 Developing requirements  109 
4.1 Domain analysis 109 4.2 The starting point for software projects 114 4.3 Defining the problem and the scope 115 4.4 What is a requirement? 119 4.5 Types of requirements 119 4.6 Use cases: describing how the user will use the system 127 4.7 Some techniques for gathering requirements 138 4.8 Types of requirements document 145 4.9 Reviewing requirements 148 4.10 Managing changing requirements 155 4.11 GPS-based Automobile Navigation Assistant (GANA) 156 4.12 Requirements for a feature of the SimpleChat instant messaging program 1604.13 Difficulties and risks in domain and requirements analysis 164 4.14 Summary 165 4.15 For more information 166 
5 Modeling with classes  169 
5.1 What is UML? 169 5.2 Essentials of UML class diagrams 172 5.3 Associations and multiplicity 173 5.4 Generalization 182 5.5 Object diagrams 186 5.6 More advanced features of class diagrams 188 5.7 The basics of Object Constraint Language (OCL) 193 5.8 A class diagram for genealogy 196 5.9 The process of developing class diagrams 199 5.10 Implementing class diagrams in Java 216 5.11 Difficulties and risks when creating class diagrams 218 5.12 Summary 218 5.13 For more information 219 
 Lethbridge.book  Page vi  Tuesday, November 16, 2004  12:22 PM<page>  vii 
Contents 
6 Using design patterns  221 
6.1 Introduction to patterns 2216.2 The Abstraction–Occurrence pattern 2236.3 The General Hierarchy pattern 2266.4 The Player–Role pattern 2286.5 The Singleton pattern 2316.6 The Observer pattern 2326.7 The Delegation pattern 2346.8 The Adapter pattern 2366.9 The Façade pattern 2386.10 The Immutable pattern 2396.11 The Read-Only Interface pattern 2406.12 The Proxy pattern 2416.13 The Factory pattern 2436.14 Enhancing OCSF to employ additional design patterns 2466.15 Difficulties and risks when using design patterns 2506.16 Summary 2516.17 For more information 251 
7 Focusing on users and their tasks  253 
7.1 User-centered design 254 7.2 Characteristics of users 256 7.3 The basics of user interface design 258 7.4 Usability principles 262 7.5 Evaluating user interfaces 273 7.6 Implementing a simple GUI in Java 276 7.7 Difficulties and risks in user-centered design 280 7.8 Summary 280 7.9 For more information 281 
8 Modeling interactions and behavior  285 
8.1 Interaction diagrams 285 8.2 State diagrams 292 8.3 Activity diagrams 301 8.4 Implementing classes based on interaction and state diagrams 302 8.5 Difficulties and risks in modeling interactions and behavior 306 8.6 Summary 307 8.7 For more information 307 
9 Architecting and designing software  309 
9.1 The process of design 310 9.2 Principles leading to good design 314 
Design Principle 1: Divide and conquer 
314 
Design Principle 2: Increase cohesion where possible 
315 
Design Principle 3: Reduce coupling where possible 
321 
Design Principle 4: Keep the level of abstraction as high as possible 
329 
 Lethbridge.book  Page vii  Tuesday, November 16, 2004  12:22 PM<page>  viii 
Contents 
Design Principle 5: Increase reusability where possible 
330 
Design Principle 6: Reuse existing designs and code where possible 
331 
Design Principle 7: Design for flexibility 
331 
Design Principle 8: Anticipate obsolescence 
332 
Design Principle 9: Design for portability 
333 
Design Principle 10: Design for testability 
334 
Design Principle 11: Design defensively 
334 9.3 Techniques for making good design decisions 336 9.4 Model Driven Development 340 9.5 Software architecture 342 9.6 Architectural patterns 347 
The Multi-Layer architectural pattern 
347 
The Client–Server and other distributed architectural patterns 
349 
The Broker architectural pattern 
351 
The Transaction Processing architectural pattern 
352 
The Pipe-and-Filter architectural pattern 
353 
The Model–View–Controller (MVC) architectural pattern 
355 
The Service-Oriented architectural pattern 
358 
The Message-Oriented architectural pattern 
360 9.7 Writing a good design document 362 9.8 Design of a feature for the SimpleChat instant messaging application 365 9.9 Difficulties and risks in design 366 9.10 Summary 367 9.11 For more information 368 
10 Testing and inspecting to ensure high quality  371 
10.1 Basic definitions 371 10.2 Effective and efficient testing 373 10.3 Defects in ordinary algorithms 380 10.4 Defects in numerical algorithms 388 10.5 Defects in timing and co-ordination: deadlocks, livelocks and critical races 39110.6 Defects in handling stress and unusual situations 394 10.7 Documentation defects 398 10.8 Writing formal test cases and test plans 398 10.9 Strategies for testing large systems 402 10.10 Inspections 409 10.11 Quality assurance in general 413 10.12 Test cases for phase 2 of the SimpleChat instant messaging system 416 10.13 Difficulties and risks in quality assurance 420 10.14 Summary 421 10.15 For more information 422 
11 Managing the software process  425 
11.1 What is project management? 425 11.2 Software process models 428 
 Lethbridge.book  Page viii  Tuesday, November 16, 2004  12:22 PM<page>  ix 
Contents 
11.3 Cost estimation 43511.4 Building software engineering teams 44511.5 Project scheduling and tracking 44911.6 Contents of a project plan 45211.7 Difficulties and risks in project management 45311.8 Summary 45511.9 For more information 456 
12 Review  459 
12.1 Theme 1: Understanding the customer and user 45912.2 Theme 2: Basing development on solid principles and reusable technology 45912.3 Theme 3: Object orientation 46412.4 Theme 4: Visual modeling using UML 46412.5 Theme 5: Evaluation of alternatives in requirements and design 46512.6 Theme 6: Incorporating quantitative and logical thinking 46512.7 Theme 7: Iterative and agile development 46612.8 Theme 8: Communicating effectively using documentation 46712.9 Theme 9: Risk management in all software engineering activities 46712.10 Where next? 469 
Appendix A: Summary of the UML notation used in this book 471Appendix B: Summary of the documentation types recommended in this book 475Appendix C: System descriptions 479Glossary 485 
 Lethbridge.book  Page ix  Tuesday, November 16, 2004  12:22 PM<page>  
 Lethbridge.book  Page x  Tuesday, November 16, 2004  12:22 PM<page>  
ii 
Foreword  
If a builder build a house for someone, and does not constructit properly, and the house which he built falls in and kills itsowner, then that builder shall be put to death 
Article 229 of the Code of Hammurabi (1780 BC).This earliest recorded attempt to regulate the engineering profession remindsus, in the bluntest way possible, that the paramount purpose of engineering andengineering design is to serve the user. One would assume that the engineer’sresponsibility to users is so self evident that it goes without saying. Variousprofessional engineering societies have inculcated this into the core of the rulesthat regulate the conduct of their members.However, in the relatively young discipline of software engineering, this hasnot yet fully permeated the professional culture. Part of it is due to the essentialnature of the software: like no other engineering medium, software provides theshortest path from concept to reality. With no metal to bend, heavy weights tolift, or large teams of people to mobilize, creativity is practically unhampered. Inthe heady and seductive process of embodying ideas through software, users areoften forgotten or relegated to secondary status. In some cases, they are evenseen as a distraction whose idiosyncrasies merely get in the way of ‘elegant andclean’ design. Software developers are notorious for their impatience withanything that separates them from programming – the medium has become themessage. Symptomatically, the terms ‘hacking’ and ‘hacker’ have no equivalentin any other engineering discipline.It is interesting to note the dramatic impact that the concept of ‘use case’ hashad on the software community. This idea, introduced by Ivar Jacobson and hiscolleagues a little over a decade ago, was lauded as revolutionary. Its essence liesin the formal introduction of the concept of a user (an ‘actor’) into the softwaredesign process. (The layperson can hardly be blamed for wondering ‘what tookthem so long?’ Hammurabi knew this almost 4000 years ago.) 
 Lethbridge.book  Page xi  Tuesday, November 16, 2004  12:22 PM<page>  xii 
Foreword 
Clearly, there is an imbalance of motivations here that needs to be set right:the creative urge needs to be made subservient to the need to support the user.This is something that has to be instilled from the first steps in a softwareengineering education, and the book by Tim Lethbridge and Robert Laganièreis an important contribution to this.The authors build the book around nine ‘themes’ , auspiciously starting with‘understanding the customer and user’ . (Many software practitioners do noteven differentiate between customers and users.) The themes are not drytheorems but distillations of practical and proven domain knowledge drawnfrom a wealth of experience in industrial software development. The bookabounds with pragmatic detail that is rarely found in textbooks. In fact, it is thekind of textbook that, as a young engineering student, I wished I had, because itdescribes the proverbial ‘real world’ .The book does not shirk theory, quite to the contrary. However, the theorycomes alive because it is set in its full and proper context, comprising not onlythe technical but the social and cultural aspects that often play an important rolein molding the theory. The reader not only learns why a particular technologicalapproach is good, but also its drawbacks and, perhaps equally importantly, itshistory. (Some things – like the  
QWERTY 
 keyboard – can only be understoodproperly if one is familiar with their history.) They carefully point out thecontroversial issues in modern software engineering without taking sides,meticulously listing the arguments for each viewpoint.The ‘engineering’ side of software engineering is extremely well representedhere and not just because the authors emphasize a user-centric approach.Themes such as ‘incorporating quantitative thinking’ , ‘evaluation of alternativesin requirements and design’ , ‘risk management’ , or ‘communicating effectively’are all proven and effective techniques evolved from centuries of engineeringexperience and which, unfortunately, are still not adequately applied in softwareengineering. Y es, software is different from other forms of engineering in many,many ways, but not so different that it cannot benefit from these lessons learned.For example, the lack of quantitative thinking, including elementary riskanalysis, is probably one of the most common causes of software project failures.And, no matter which statistics you read, more software projects fail thansucceed. (Thankfully, the engineers who design buildings and airplanes have amuch better record than their software counterparts.) Model-driven development is another important thread throughout thebook. This relatively new approach to software development, which promisesto be the first true technological generational advance since the invention ofthe compiler, is covered in detail, from the basic principles of objectorientation to the latest modeling languages and their use. The way of thefuture lies here.So, from the nuts and bolts of objects to the high vistas of softwarearchitecture, from writing code to testing, from software development processesto project management – it’s all gathered here. The breadth and depth of thematerial covered is striking and impressive, yet it has been brought together 
 Lethbridge.book  Page xii  Tuesday, November 16, 2004  12:22 PM<page>  xiii 
Foreword 
quite seamlessly, all the pieces in their rightful places, in balance. Althoughprimarily conceived as a textbook, it will undoubtedly serve its readers as areference for years to come. 
If a builder build a program for someone, and does notconstruct it properly… 
Bran SelicAugust, 2004Ottawa, Canada 
 Lethbridge.book  Page xiii  Tuesday, November 16, 2004  12:22 PM<page>  
 Lethbridge.book  Page xiv  Tuesday, November 16, 2004  12:22 PM<page>  
iii 
Preface  
Our focus in this book is software engineering knowledge and skills that readerscan put into immediate practical use. The book is designed to be used in second-year post-secondary software engineering courses, although it has been used inintroductory software engineering courses at all levels. It will also be valuable toprogramming practitioners who want to develop a better understanding ofmodern software engineering.We have taught software engineering courses for fourteen years, and haveattempted to tune the book so that it is both useful and enjoyable to students.Feedback from former students has been gratifying – some have reported that theyregularly use it as a reference in their jobs. Our industrial experience performingsoftware development, consulting and professional training has also allowed us tofocus on material that is important to the employers of these students. 
Using the book in a software engineering degree program 
Software 
 engineering is becoming an established discipline, separate fromcomputer  
science 
 and computer engineering. As a witness to this, in 2004 TheIEEE Computer Society and the ACM approved  
Software Engineering 2004 
(SE2004), a document outlining what should be taught in any undergraduatesoftware engineering program. Timothy Lethbridge played a leading role in thatproject, and this book is specifically designed as a textbook for SE2004 courseSE201. See the web site http://sites.computer.org/ccse.At the University of Ottawa, we teach the material in this book over a 12-weekperiod during the first semester of the second year. By that time, students havecompleted two semesters of computer science – including object-orientedprogramming in Java. They take a course in data structures and algorithms inparallel with this course, and subsequently take advanced software engineeringcourses that expand their knowledge of the material we introduce here.Students who have studied the material in this course should be particularlyemployable in summer jobs, co-op and sandwich work terms, and other formsof industrial placement. Employers are looking for students who understandwhat constitutes a good requirement, can apply fundamental design principles, 
 Lethbridge.book  Page xv  Tuesday, November 16, 2004  12:22 PM<page>  xvi 
Preface 
can use UML properly, can translate requirements and designs into good qualityprograms, and can effectively test those programs. This book gives a practicalgrounding in all of these skills.The book is structured so that in a 12-week course or unit, it can be taughtusing three hours a week of classroom instruction, plus regular supervised andunsupervised laboratory time. Each year we assign a selection of the exercises,many of which students work on in groups. This second edition of the bookupdates many exercises and introduces many new ones. 
Suggested background 
Prior to studying this book, readers should  
understand 
 the basic notions of object-oriented programming, although Chapter 2 gives a brief review of theseconcepts. We have selected Java as the language used for programming examplessince it is a complete, simple and popular object-oriented language. Motivatedreaders who know other object-oriented languages should be able to pick up thenecessary Java from the material provided in Chapter 2 and the book’s web site,and as they work through the exercises. 
Material on the web site 
We have prepared a web site with many resources to support readers andteachers. The address is http://www.lloseng.com.Here you will find sets of presentation slides, source code, answers to exercises,links to all the web-based references, a knowledge base summarizing many of theconcepts presented, videotapes of lectures, and various other learning aids.There is also a publisher’s website at http://www.mhhe.com/lethbridge, whereyou will find lecturer’s password-protected resources. 
Themes taught throughout the book 
Woven throughout the book are nine themes that we believe are basic tocontemporary software engineering. Each of these themes is revisited in manychapters, and is taught in the context of concrete examples and exercises. 
1. 
Understanding the customer and the user 
. We emphasize domain analysis aswell as gathering and validating requirements. We place these in the context ofuse case analysis and usability. Readers are asked to think in terms of what thecustomer’s problem really is, what is realistic, etc. The purpose of softwareengineering is described at the beginning of the book as solving customers’problems, rather than developing software for its own sake. 
2. 
Basing development on solid principles and reusable technology 
. We emphasize the necessity for software engineers to understand design principlesand have a thorough grasp of suitable technology before embarking on aproject. To ensure this is the case for the design work in this book, we firstreview object-oriented principles. Later we discuss frameworks, a series ofdesign principles, and many design and architectural patterns. 
 Lethbridge.book  Page xvi  Tuesday, November 16, 2004  12:22 PM<page>  xvii 
Preface 
3. 
Visual modeling using UML 
. We present key elements of UML, particularlyclass, interaction and state diagrams. We do not cover all of UML and we donot restrict our discussion to UML alone since it does not cover all of softwareengineering. We emphasize that UML diagrams do not solve problems bythemselves, but are one of the many tools that software engineers should use asa regular part of their work. For the second edition, we have updated the bookso that it is compliant with UML 2.0. 
4. 
Evaluation of alternatives in requirements and design 
. Throughout the book we present alternatives with their advantages and disadvantages. We encouragereaders to record the rationale for each choice. 
5. 
Object orientation 
. We cover all aspects of object-oriented development,including analysis, design, and programming. Ensuring that the reader seeshow to take projects all the way to implementation means that he or she getsmore than just an abstract view of the development process, and appreciatesthe reasons for many design principles. 
6. 
Quantitative and logical thinking 
. We cover the essentials of software metricsin several different chapters so that students can learn to think quantitatively.We also promote the judicious application of logic as embodied in OCL andassertions. 
7. 
Iterative and agile development 
. We strongly emphasize that readers shouldfollow an iterative approach to development. As project work, readers are askedto perform requirements analysis, design and implementation very near thebeginning of the book, and then again several times throughout the book. Toaccomplish this we introduce a complete project in Chapter 3. Initially, readersare asked to make only a small change to this project in order to begin tounderstand it. In Chapter 4, readers are then asked to write and reviewrequirements for new features to add to the system – again they design andimplement the features. Later, readers learn more details of topics such asdesign and quality assurance, and are asked to apply what they learn tosuccessively more advanced changes to their project. Concepts from the agilemovement are also emphasized: developing in very small increments, test-firstdevelopment, etc. 
8. 
Communicating effectively using documentation 
. We encourage readers to practice writing informative but concise documentation; we provide templatesand examples of each type of document. 
9. 
Risk management in all software engineering activities 
. Throughout the book, we discuss many aspects of risk management, including evaluatingpotential costs and risks on a regular basis, balancing risks with benefits,avoiding doing work that is not worthwhile, and evolving plans as we learnmore information. We point out that the knowledge learned from the otherthemes above can be applied to reduce risk. 
 Lethbridge.book  Page xvii  Tuesday, November 16, 2004  12:22 PM<page>  xix 
Preface 
understand the project work. Then we move on to  
requirements 
 and object- oriented analysis, focusing initially on use cases and static modeling. Later, weintroduce dynamic modeling. 
Use of this book in a 12-week course 
The following is a suggested schedule for using this book in a second-yearuniversity course. For the main body of the book, Chapters 3 to 10, the allocatedtime corresponds roughly to the length of each chapter.The authors use this book in a 12-week course, where each week has threehours of lecture as well as three hours of lab and tutorial time. Students areexpected to read all the chapters, although the lectures focus most heavily on thecore material in Chapters 3 through 10, and particularly Chapters 3, 5, 8 and 9. We also anticipate that students work on a selection of exercises withdeliverables about four times during the course. We also expect them to deliverthree iterations of the project. We have provided suggested project activities atthe end of many chapters. 
Week 1 
Chapters 1 and 2: Introduction and review (1 week). 
Weeks 2–3 
Chapter 3: Reuse and the client–server framework (1.5 weeks).Project work: learning to use the client–server framework by making a minorchange to a system implemented using it. 
Weeks 3–4 
Chapter 4: Domain analysis, use cases and requirements (1.5 weeks).Project work: adding features following requirements analysis. 
Weeks 4–5 
Chapter 5: OO analysis and modeling (1.5 weeks).Project work: adding features that require considerable modeling. 
Week 6 
Chapter 6: Design patterns (1 week). 
Week 7Chapter 7: Use cases and user interfaces (0.5 weeks).Project work: adding a GUI.Weeks 8–9Chapter 8: Dynamic modeling (1.5 weeks).Weeks 9–10Chapter 9: Design principles and architecture (1.5 weeks).Project work: detailed design of some features.Week 11Chapter 10: Testing (1 week).Project work: preparing a test plan.Week 12Chapters 11 and 12: Introduction to project management and review (1 week).Other orderings are possible. In particular, the order in which Chapters 6through 11 can be covered is flexible. Also, parts of many chapters could beskipped in order to give greater emphasis to other material. Lethbridge.book  Page xix  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page xxi  Tuesday, November 16, 2004  12:22 PM<page> xxv T echnology to enhance learning and teaching
For lecturers: Primis Content Center
Study skills
We publish guides to help you study, research, pass exams and write essays, allthe way through your university studies.http://www.openup.co.uk/ss/
Computing skills
If you would like to brush up on your computing skills, we have a range of titlescovering MS Office applications such as Word, Excel, PowerPoint, Access andmore: http://www.mcgraw-hill.co.uk/app.If you need to supplement your course withadditional cases or content, create apersonalised e-Book for your students. Visithttp://www.primiscontentcenter.com or emailprimis_euro@mcgraw-hill.com for moreinformation.
 Lethbridge.book  Page xxv  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page xxvi  Tuesday, November 16, 2004  12:22 PM<page> Section 1.27What is software engineering?
with this goal, such as adding unnecessary features. Software engineers havethe responsibility to recognize situations when it would be most cost effectivenot to develop software at all, to develop simpler s o f t w a r e  o r  t o  p u r c h a s e existing software.The problems being solved by software engineers are usually related tohuman activities. Software engineers must therefore learn to communicateand negotiate effectively with people, to understand how people do theirwork, and to understand what impact any proposed software may have on itsusers’ productivity.
Systematic development and evolution
Software development becomes an engineering process when the developersapply well-understood techniques in an organized and disciplined way.Software engineering is a young field, and its technology and techniques arestill undergoing rapid development. Nevertheless, there are many well-accepted practices that have been formally standardized by bodies such as theIEEE, ISO (International Organization for Standardization) and variousnational standards bodies.Sometimes a software engineering team sets out to develop completely newsoftware. However, most development work involves modifying software thathas been already written – this is because software is normally continuallychanged over a period of years until it becomes obsolete. Ensuring that thisconstant change, called maintenance or evolution, is done in a systematic way is an integral part of software engineering. We will discuss this in more detailin Section 1.6 below.
Large, high-quality software systems
A small system can often be successfully developed by a programmer workingalone. However, large systems with many functions and components becometoo complex unless engineering discipline is applied. A system of manythousands of lines of code cannot be completely understood by one person,and certainly would take one person far too long to develop, thereforeteamwork is essential to software engineering. One of the hardest challengesis dividing up the work and ensuring that the teams communicate effectivelyand produce subsystems that properly connect with each other to produce alarge but functioning system.The techniques discussed in this book are therefore essential for large systems, although many of them are also useful for small systems.The end product that is produced must be of sufficient quality. Somesoftware engineering techniques are aimed at increasing the quality of thedesign, whereas others are used to verify that sufficient quality is presentbefore the software is released. Quality is discussed in more detail inSection 1.5 and Chapter 10. Lethbridge.book  Page 7  Tuesday, November 16, 2004  12:22 PM<page> Section 1.821The themes emphasized in this book
Theme 2: basing development on solid principles and reusable technology
A fundamental tenet of engineering is that once techniques or technologybecome well established, their use should become routine. Civil engineers, forexample, have a well-established set of principles, which they use to decide whatkind of bridge to build. They also have standard bridge designs that they adaptfor most routine bridge projects.Even though software engineering is still a maturing discipline, manyprinciples have become well established. We discuss these principles throughoutthe book.As for technology, we base our designs on Java, a language with wideacceptance. Furthermore, in Chapter 3 we present a framework – a collection of classes that forms the basic structure upon which many different applicationscan be built. We demonstrate how this framework can be used to rapidly buildseveral different applications.Applying well-understood principles and reusing designs means that we arebuilding on the experience and work of others, rather than ‘reinventing thewheel’ . The creative task of the engineer is to put knowledge to use in innovativeways to solve problems. This contrasts with the role of the scientist, which is toseek out new knowledge.
Theme 3: object orientation
Object-oriented (OO) techniques are based on the use of classes that act asabstractions of data, and that contain a set of procedures which act on that data.It is now widely recognized that object orientation is an effective designapproach to manage the complexity inherent in most large systems.In this book we discuss three major areas of software engineering in an object-oriented context: analysis, design and programming. In Chapter 2, we reviewbasic OO principles and OO programming; then, in the rest of the book, weapproach analysis and design from a primarily OO perspective. We will ask youto implement your designs in the OO language Java, so that you can see theconsequences of your design decisions.
Theme 4: visual modeling using UML
The Unified Modeling Language (UML) is a set of notations for representingsoftware requirements and design. It is now widely accepted as the standardapproach to representing many aspects of software.We will teach you in some detail how to use several different aspects of UML,including class diagrams (Chapter 5), state diagrams and interaction diagrams(both in Chapter 8).
Theme 5: evaluation of alternatives in requirements and design
There is rarely a single straightforward answer to any problem in softwareengineering. Whether you are developing requirements or performing design, Lethbridge.book  Page 21  Tuesday, November 16, 2004  12:22 PM<page> 22Chapter 1
Software and software engineering 
there are often several alternatives that must be assessed systematically todecide which is best.In both requirements analysis and design we will encourage you to listalternatives, and discuss their advantages and disadvantages before making adecision. We will also encourage you to document your reasoning, frequentlycalled rationale, so that others can understand your decisions.
Theme 6: incorporating quantitative and logical thinking
It is becoming increasingly necessary to incorporate mathematical thinking intosoftware development. We will present basic ways to measure aspects ofsoftware systems and software engineering processes. The objective of doingthis measurement is to help make predictions of development time and qualityin order to better control these factors. This topic, commonly known as software metrics, is covered in the chapters on object-orientation (Chapter 2),requirements (Chapter 4), design (Chapter 9), testing (Chapter 10) and projectmanagement (Chapter 11).We will also show several ways to make use of logic in order to develop software: in Chapter 5 we will introduce OCL, a language for formally describing propertiesof designs; and in Chapter 9 we will show how logic can be used in a techniquecalled defensive programming.
Theme 7: iterative and agile development
Traditionally, software engineering has been performed following what is calledthe waterfall model. In this approach you first develop requirements; once theseare complete you move on to design, and then to programming, testing anddeployment. An outdated view held that you should completely finish each ofthese steps before moving on to the next; then, when you complete deployment,you are finished. In contrast, the currently accepted view is that softwareengineering is, and should be, a highly iterative process. So-called agile techniques are the most highly iterative of all (see the sidebar ‘ Agile versusconventional development’ earlier in this chapter).It is typical to develop the first iteration of a system as a prototype, with only rough requirements and little functionality. Doing this serves to help establishthe requirements for the next iteration. Several iterations of prototypes may beneeded before the stakeholders are finally satisfied with the requirements, atwhich time you can proceed with a more rigorous process involving morecomplete specification and design.Even after delivering software to customers, you typically continue to build aseries of new releases, each one involving most of the activities discussed inSection 1.6. Iterative development results in delivering smaller units of work(prototypes or releases) quite frequently. This means that the first release can bein the customers’ hands earlier than if you had tried to develop a fully fledgedsystem. It also means that if the system turns out to be a disaster, less work hasbeen wasted. Lethbridge.book  Page 22  Tuesday, November 16, 2004  12:22 PM<page> Section 1.823The themes emphasized in this book
We will practice the iterative approach in this book, starting in Chapter 3, byasking you to make a series of small changes to a project. Y ou will do therequirements, design and implementation of each change, with changesbecoming more sophisticated as you learn more of the material in the book.We discuss processes the waterfall, iterative and other approaches in moredetail in Chapter 11.
Theme 8: communicating effectively using documentation
Software engineers communicate with each other orally both in meetings and ateach other’s desks; however, it would never be possible to run a large project ifall information had to be conveyed in this manner.Writing clear documentation is therefore anessential skill. Documentation should be written atall stages of development and includes requirements,designs, user manuals, instructions for testers andproject plans. One of the keys to writing gooddocumentation is to understand the audience. Y oumust provide the information the readers will need,and organize it in such a way that the readers can find it easily. For example, theaudience for design documentation includes other software engineers with whomyou are currently working, as well as those who will need to make changes later. Bothgroups need to understand what you did and why you did it.Unfortunately, unless it is managed appropriately, writing documentation canwaste resources and can be a source of rigidity in software development. Thewaste of resources can occur if documentation is never read – this will be thecase if it is excessively voluminous, poorly written or not made readily available.Excessive documentation means that the readers cannot find what they wanteasily, and ‘can’t find the forest for the trees’ . It is therefore as bad as if you hadnot created enough documentation to start with.Forcing software developers to write documents prematurely just to meetspecific deadlines can mean that the overall objective becomes writingdocuments, instead of solving problems. Furthermore, such documents canentrench poorly made decisions that are hard to change.In this book, we will encourage you to write documentation but we willemphasize that it should be as short and succinct as possible, and it should servethe purpose of documenting your decisions and communicating them to others.Furthermore, documentation should be written in the context of riskmanagement, discussed below, which means that it is always subject to change.We will give you outlines of each type of document as well as several exampledocuments. Y ou will have the opportunity to practice writing the documentsand also reviewing them in groups.When writing documentation you should also be aware that there are oftenstandards that you should adhere to. It is important that documentation usedwithin a company have a standard format so that people can more easily use it.
Agile documentation
Agile developers prefer to write very littledocumentation. Some would prefer thatanything that needs documenting be put incode comments and nowhere else. Lethbridge.book  Page 23  Tuesday, November 16, 2004  12:22 PM<page> 30Chapter 2
Review of object orientation 
Procedural abstraction and the procedural paradigm
From the earliest days of programming, software has been organized around thenotion of procedures (also in some contexts called functions or routines). These provide procedural abstraction. When using a certain procedure, a programmerdoes not need to worry about all the details of how it performs its computations;h e  o r  s h e  o n l y  n e e d s  t o  k n o w  h o w  t o  c a l l  i t  a n d  w h a t  i t  c o m p u t e s .  T h eprogrammer’s view of the system is thus made simpler.In the so-called procedural paradigm, the entire system is organized into a setof procedures. One ‘main’ procedure calls several other procedures, which inturn call others.The procedural paradigm works very well when the main purpose ofprograms is to perform calculations with relatively simple data. However, ascomputers and applications have become more complex, so has the data.Systems written using the procedural paradigm are complex if each procedureworks with many types of data, or if each type of data has many differentprocedures that access and modify it.
Data abstraction
Data abstractions can help reduce some of a system’s complexity. Records and structures were the first data abstractions to be introduced. The idea is to grouptogether the pieces of data that describe some entity, so that programmers canmanipulate that data as a unit.However, even when using data abstraction, programmers still have to writecomplex code in many different places. Consider, for example, a bankingsystem that is written using the procedural paradigm, but using recordsrepresenting bank accounts. The software has to manage accounts of differenttypes, such as checking, savings and mortgage accounts (a checking accountwould be called a cheque account or current account in some countries). Eachtype of account will have different rules for the computation of fees, interest,etc. Such a system would have procedures like the following pseudocode inmany different places:
if account is of type checking then  do somethingelse if account is of type savings then  do something elseelse  do yet another thingendif
Imagine also that clients can hold several accounts of different types, and someaccounts can be held jointly; also the different account holders might havedifferent rights. Rules to deal with issues like these would be scatteredthroughout the code, making change very difficult. Lethbridge.book  Page 30  Tuesday, November 16, 2004  12:22 PM<page> 34Chapter 2
Review of object orientation 
Example 2.1 In the following, we indicate whether each item should be a class or an instance. Ifit should be a class, we describe its instances. If it should be an instance, wedescribe its class. Film: class; instances include ‘Star Wars’ and ‘Casablanca’ .Reel of film: class; instances are physical reels.Film reel with serial number SW19876: instance of 
ReelOfFilm . Showing of ‘Star Wars’ in the Phoenix Cinema at 7 pm: instance of class 
ShowingOfFilm .
ExerciseE4
Which of the following items do you think should be a class, and which shouldbe an instance? For any item that should be an instance, name a suitable classfor it. If you think an item could be either a class or an instance, depending oncircumstances, explain why.  
Naming classes
One of the first challenges in any object-oriented project is to name the classes.Notice that the class names mentioned in the last subsection such as 
Employee ,
Hospital  and Doctor  are nouns, have their first letter capitalized and are written in the singular. These are important conventions that should be followed in allobject-oriented programs in languages like Java and C++. Being consistentabout capitalization ensures that readers of the program can tell what is a classand what is not. Using the singular ensures that readers can tell that an instanceof the class is a single item, not a list or collection. If you want to give a class aname consisting of more than one word, then omit the spaces and capitalize thefirst letter of each word, for example: 
PartTimeEmployee . It is also important to choose names for classes that are neither too general nortoo specific. Many words in the English language have more than one meaning,or are used with a broad meaning. For example, the word ‘bus’ could mean thephysical vehicle, or a particular run along a particular route, as in, ‘I will catchthe 10:30 bus (but I don’t care which vehicle is used)’ . Y ou might choose to call(a) General Motors (b) Automobile company(c) Boeing 777 (d) Computer science student(e) Mary Smith (f) Game(g) Board game (h) Chess(i) University course SEG 2100 (j) Airplane(k) The game of chess between Tom and Jane which started at 2:30 pm yesterday.(l) The car with serial number JM 198765T4 Lethbridge.book  Page 34  Tuesday, November 16, 2004  12:22 PM<page> Section 2.337Instance variables
Variables versus objects
One common source of confusion when discussing object-oriented programs isthe difference between variables and objects. These are quite distinct concepts.At any given instant, a variable can refer to a particular object or to no objectat all. Variables that refer to objects are therefore often called references. During the execution of a program, a given variable may refer to differentobjects. Furthermore, an object can be referred to by several differentvariables at the same time.The type of a variable determines what classes of objects it may contain. Wewill explain the rules regarding this in later sections.Variables can be local variables in methods; these are created when a methodruns and are destroyed when a method returns. However, objects temporarilyreferenced by such variables may last much longer than the lifetime of themethod as long as some other variable also references the object.
ExercisesE7
Identify the attributes that might be present in the following classes. Try to bereasonably exhaustive.(a)
Series  (in a scheduling system for an independent television station)(b)
Passenger  (in an airline system)(c)
Event  (in a personal schedule system; a meeting might be a kind of event)(d)
Clasroom  (in a university course scheduling system)(e)
PhoneCall  (in the system of a mobile telephone company)(f)
AssemblyLine  (in a factory automation system)
E8 Identify some associations that might involve the classes listed in theprevious exercise. For each association, indicate the other class that wouldbe involved.
Instance variables versus class variables
If you declare that a class has an instance variable called var, then you are saying that each instance of the class will have its own slot named 
var. Therefore, for example, each 
Employee  has a supervisor . The actual data put into these variableswill vary from object to object: employees will have different instances of 
Manager
as their supervisors.Sometimes, however, you want to create a variable whose value is shared byall instances of a class. Such a variable is known as a class variable or static variable. If one instance sets the value of a class variable, then all the otherinstances see the same changed value. Lethbridge.book  Page 37  Tuesday, November 16, 2004  12:22 PM<page> Section 2.539Organizing classes into inheritance hierarchies
In the banking system, the three classes CheckingAccount , SavingsAccount  and
MortgageAccount  would each have their own method for the polymorphic operation
calculateInterest . When a program is calculating the interest on a series of accounts,it will invoke the version of 
calculateInterest  specific to the class of each account.
ExerciseE9
For each of the following sets of classes, find an appropriate superclass and thepolymorphic operations that should be included in this superclass. Explain theway these operations would behave in each subclass and identify someoperations that might be present in only one of the subclasses.(a)
Square , Circle , Rectangle
(b)Truck , Ambulance , Bus
(c)Techician , AdministrativeAssistant , Manager  
2.5 Organizing classes into inheritance hierarchies
If several classes have attributes, associations or operations in common, it isbest to avoid duplication by creating a separate superclass that contains these common aspects. Conversely, if you have a complex class, it may be good todivide its functionality among several specialized subclasses. For example, imagine you are creating a banking application in whichthere are several kinds of accounts. Some things are common to all accounts,s u c h  a s  h a v i n g  a  b a l a n c e  a n d  a n  o w n e r ,  a s  w e l l  a s  b e i n g  a b l e  t o  d e p o s i tmoney in the account, open it and close it. Other things differentiate theaccounts – for example, a mortgage account has a negative balance as well asa property (e.g. a house) as collateral; a savings account might have certainprivileges associated with it such as higher interest for keeping a highbalance in it. In this example we would say that class 
Account  should be the superclass of subclasses 
SavingsAccount , CheckingAccount  and MortgageAccount . The relationship between a subclass and an immediate superclass is calleda generalization. The subclass is called a specialization. A hierarchy with one or more generalizations is called an inheritance hierarchy, a generalization hierarchy or an isa hierarchy. The reason for the latter name will becomeclear shortly.Y ou can draw inheritance hierarchies graphically as shownin Figure 2.4. The little triangle symbolizes one or moregeneralizations sharing the same superclass, and points to thesuperclass. It is clearest when such diagrams are drawn with thesuperclass at the top and the subclasses below, although otherarrangements are also allowed.
C++ terminology for superclass and subclass
In C++, a superclass is called a‘base class’, while a subclass iscalled a ‘derived class’. Lethbridge.book  Page 39  Tuesday, November 16, 2004  12:22 PM<page> 44Chapter 2
Review of object orientation 
a) VehicleCarSports car AirplaneAmphibious vehicle EngineJet engineElectric motor WheelTransmissionTruckBicycle    b) Edition of book Copy of book Volume Issue of newspaper Magazine Work of literature NewspaperIssue of magazine PublicationChapterAuthorPublisher Copy of issue of magazine     c) ScheduleBusTrip Chartered bus Bus route Express bus Luxury busTour busRoute Unscheduled trip      d) StudentCourse ProfessorGraduate student Course section Program of studiesTeaching assistant Administrative assistant TechnicianClassroomTime slot Meeting room BuildingGymnasiumRegistration system LaboratoryTutorialExam   e) CurrencyExchange rate BankFinancial instrument Credit card Debit card CheckCredit UnionBank machine VisaMasterCardLoan Bank accountBank branchCanadian dollars US dollars  f) Hotel roomMeeting room BallroomSuiteHilton (the hotel chain) Ottawa HiltonMeeting organizer Catered function BookingGuestReservationMeeting ConferenceConference room Item on bill   g) Insurance policy Claim Deductible Insurance client Insured property Automobile policyHome policyLife insurance BeneficiaryPolicy renewal    Lethbridge.book  Page 44  Tuesday, November 16, 2004  12:22 PM<page> Section 2.645The effect of inheritance hierarchies on polymorphism and variable declarations
2.6 The effect of inheritance hierarchies on polymorphism and variable declarations
Much of the power of the object-oriented paradigm comes from polymorphismand inheritance working together. In this section we will investigate this synergy. Figure 2.8 shows an expanded version of the hierarchy of two-dimensionalshapes from Figure 2.6, also incorporating the 
EllipticalShape  class from Figure 2.7, as well as a modified 
Polygon  hierarchy. We will use Figure 2.8 toillustrate several important points; you should study it and try to understand itbefore proceeding.h) Telephone Phone line Digital linePhone call Conference call Call waitingExtension Feature Call on holdCaller Call forwarding Forwarded callTelephone number Voice mail message Voice mailVoice mail box  
Figure 2.8A hierarchy of shapes showing polymorphism and overriding
Shape2Drotate()translate()changeScale()getArea()getPerimeterLength()getCenter()getBoundingRect()center
EllipticalShape
semiMajorAxisPolygon
getVertices()getBoundingRect()
Ellipse
getSemiMajorAxis()
getSemiMinorAxis()rotate()
getArea()
getPerimeterLength()
getOrientation()getBoundingRect()semiMinorAxis
changeScale()
getFocus1()
getFocus2()orientationCircle
rotate()
getArea()
getPerimeterLength()
getBoundingRect()changeScale()
getRadius()SimplePolygon
orientation
rotate()
getOrientation()ArbitraryPolygon
points
addPoint()
removePoint()
rotate()
changeScale()
getArea()
getPerimeterLength()
getVertices()RegularPolygon
numPoints
radius
changeNumPoints()
changeScale()
getArea()
getPerimeterLength()
getVertices()Rectangle
height
width
setHeight()
setWidth()changeScale()
getArea()
getPerimeterLength()
getVertices()
getBoundingRect() Lethbridge.book  Page 45  Tuesday, November 16, 2004  12:22 PM<page> 50Chapter 2
Review of object orientation 
E14 Explain how you would incorporate the operations flipHorizontally  and
flipVertically  into the hierarchy of Figure 2.8. Describe which classes (if any)should declare these to be abstract operations, and which classes should havemethods for them.
E15 Explain how you would incorporate the following classes into the hierarchy ofFigure 2.8. Describe the attributes and operations that would be present inthese classes.
(a) IsoscelesTriangle(b) Square
(c)Star
E16 Describe what the methods addPoint  and removePoint  in class ArbitraryPolygon
would have to do. Hint: think about what attributes would be affected, andhow. Y ou do not need to write any code.
E17 Imagine you want to create an operation called getEnclosingCircle  in the hierarchy of Figure 2.8. This operation would compute the smallest circle thatcan completely enclose any shape. Describe the methods that you think wouldbe needed to implement this operation.
Variables and dynamic binding
Imagine you are programming in an object-oriented language and declare avariable called 
aShape  that has type Shape2D . What this means is that as theprogram runs, the variable can contain objects of any concrete class in thehierarchy of 
Shape2D .If you then attempt to invoke the operation 
getBoundingRect  on the variable
aShape , the program will make the decision about what method to run ‘on the fly’ .The decision-making process is called dynamic binding (or sometimes late binding or virtual binding).Y ou can imagine that the following procedure is used to perform dynamicbinding:1.The program looks in the class of the object actually stored in the variable. Ifthere is a concrete method for the operation in that class, then it runs themethod.2.Otherwise, it checks in the immediate superclass to see if there is a methodthere; if so, it runs the method.3.The program repeats step 2, looking in successively higher superclasses until itfinds a concrete method and runs it.4.If no method is found, then there is an error. Lethbridge.book  Page 50  Tuesday, November 16, 2004  12:22 PM<page> Section 2.651The effect of inheritance hierarchies on polymorphism and variable declarations
Therefore, for example, if you had an instance of RegularPolygon  in the aShape
variable, and invoked the operation getBoundingRect , the program would look first in 
RegularPolygon , then SimplePolygon  and finally Polygon  be f o r e  i t  fi n d s  a method to run.If 
aShape  had contained an instance of Rectangle , however, then the program would find a 
getBoundingRect  method in that class immediately.It would be inefficient if programs ran the above dynamic binding algorithmfor every procedure call, therefore an optimized approach using a lookup tableis used instead. However, programmers do not normally need to be aware of theoptimized mechanism.Dynamic binding is what gives polymorphism its power. It relievesprogrammers from the burden of having to write conditional statements toexplicitly choose which code to run; with dynamic binding, that work is doneautomatically by the programming language.Dynamic binding is only needed when the compiler determines that there ismore than one possible method that could be executed by a particular call.Therefore, for example, if you declared a variable to have type 
Rectangle , and you could be sure that 
Rectangle  would have no subclasses, then only a Rectangle
could be put in that variable. In such a case, the compiler can staticallydetermine precisely which method to call. 
ExerciseE18
In which of the following situations would dynamic binding be needed?Assume that the compiler knows that no new classes or methods can be addedto the hierarchy. 
Interfaces
An interface in Java is very much like an abstract class, except that it can haveneither instance variables nor concrete methods – it is basically a named list ofabstract operations. We instead create several implementing classes (rather than subclasses) of an interface that must implement the abstract operations. A classcan implement multiple interfaces, but can have only one superclass. You have a variable of type: You invoke the operation:a)Rectangle getPerimeterLength 
b)SimplePolygon getCenter 
c)Polygon getBoundingRect 
d)EllipticalShape getScale 
e)RegularPolygon translate  Lethbridge.book  Page 51  Tuesday, November 16, 2004  12:22 PM<page> 56Chapter 2
Review of object orientation 
CanadianPostalCode , ensures that the format is XNX NXN, where N is a numberand X is a letter; the first letter is also taken from a restricted set. The otherimplementations of 
validate  ensure that US postal codes have an all-numericformat, while British postal codes adhere to their more complex alphanumericformat. 
The PostalCodeException  class
PostalCodeException  illustrates the concept of the user-defined exception class.Instances of this class are thrown when an error is found while validating apostal code. A class that manipulates postal codes could choose to handle suchexceptions in any way it wishes.
The user interface class PostalTest  
The user interface class, PostalTest , has only a static main method and one private static helper method called 
getInput . The code prompts the user for input andthen attempts to create an instance of one of the subclasses of 
PostalCode . If a
PostalCodeException  is thrown, it tries to create an instance of other subclassesuntil none remain. Then it prints out information about the result. Clearly thisis not a sophisticated user interface, nevertheless it is sufficient to test thefacilities of the 
PostalCode  hierarchy.It would be possible to put all the code from 
PostalTest  into PostalCode  – the
main method in PostalCode  would then simply be used to test the class. This is, infact, a design alternative that some people would choose. We prefer to advocatethe complete separation of the classes that do the user interface work from thefunctional classes.
PostalTest  is a rather degenerate class in the object-oriented sense, since it willnever have any instances. If any instances were created, then they could donothing since there are no constructors, instance variables or instance methods.The 
main method and its helper methods are class methods (also called staticmethods), reminiscent of the procedural paradigm. For the purposes of havinga simple test class, we believe this is acceptable; however, you should be carefulnot to force class methods to do work that would be better done in instancemethods.
ExercisesE20
Run the postal code program. Then carefully read through the code for all sixclasses. Use the Java documentation to look up any methods or classes you donot understand. 
E21 The way the program is written, letters in Canadian postal codes are onlyaccepted if they are upper case. On the other hand, letters in British postalcodes are accepted whether they are upper case or not. This is inconsistent. Lethbridge.book  Page 56  Tuesday, November 16, 2004  12:22 PM<page> Section 2.957Classes for representing geometric points
Modify the program so that user input of upper or lower case is accepted, andthe input is converted to upper case immediately.
E22 Describe how you would design the following modifications to the postal codeprogram. Think carefully about whether there should be one method, orseveral different polymorphic methods. In the latter case, think about whetherthere should be an abstract method in the superclass and concrete methods inthe subclasses, or else a concrete method in the superclass and one or moreoverriding methods in the subclasses.(a) There should be an operation 
length  that returns the number of charactersin a postal code.(b) There should be a file that contains postal codes, one per line. There shouldthen be an operation called 
isOnRecord  that returns true if a postal code is in this file. Do not worry for now about the efficiency of this operation in thecase of very large files, although you should be aware that this would be aconcern in a production-quality system. Hint: investigate class
FileInputStream .(c) For each country, there should be a file that contains, on each line, a postal codeprefix followed by the name of a destination of such postal codes. For example,class 
BritishPostalCode  might use the file BritishPostalDestinations.txt , and on one of its lines it might contain ‘SW Southwest-London’ . The parts of theprogram that set the destination should read these files.
E23 Implement the designs you prepared in the above exercise.
E24 Add a new subclass representing postal codes for the fictitious country ofOotumlia, whose format is always one or two letters, followed by a space,followed by two numbers. Y ou will have to modify the 
PostalTest  class to accommodate your new subclass, although you must not modify the 
PostalCode
class. 
2.9 Classes for representing geometric points
In this section we illustrate the use of the mathematical class library in Java. Wealso illustrate how a seemingly simple problem can be solved in several ratherdifferent ways. Y ou will have the chance to analyze the advantages anddisadvantages of various alternatives.The classes described in this section represent points on a 2-dimensional plane.From mathematics, we know that to represent a point on a plane, you can use xand y coordinates, which are called Cartesian coordinates. Alternatively, you can use polar coordinates, represented by a radius (often called rho) and an angle(often called theta). In the code we have provided, you can interchangeably workwith a given point as Cartesian coordinates or polar coordinates. Lethbridge.book  Page 57  Tuesday, November 16, 2004  12:22 PM<page> 58Chapter 2
Review of object orientation 
Java already has classes for representing geometric points. Take a fewmoments to look at classes 
Point2D  and Point  in the Java documentation.We will call the point class presented here 
PointCP ; its main distinguishing feature from the built-in Java classes is that it can handle both Cartesian andpolar coordinates. We also provide a class called 
PointCPTest  which, like
PostalTest , simply provides a user interface for testing. The public methods ofboth classes are shown in Figure 2.11. The code for these classes can also befound at the book’s web site (www.lloseng.com).Class 
PointCP  contains two private instance variables that can either store xand y, or else rho and theta. No matter which storage format is used, all fourpossible parameters can be computed. Users of the class can also call methods
convertStorageToPolar  or convertStorageToCartesian  in order to explicitly convert the internal storage of an instance to the alternative format.The above design of 
PointCP  is certainly not the only possible design. Table 2.1shows several alternative designs; the above design is Design 1.
ExercisesE25
Answer the following questions with respect to the above designs of the PointCP
class.(a) Discuss why it might be useful to allow users of class 
PointCP  (Design 1) to explicitly change the internal storage format, using 
convertStorageToCartesian
or convertStorageToPolar .(b) What might be a potential hidden weakness of these methods? Hint: whatcould happen if one is called, then the other, and this process is repeatednumerous times?(c) Write a short program to test whether the weakness you discussed in part bis, in fact, real.
E26 Create a table describing the various advantages (pros) and disadvantages(cons) of each of the five design alternatives. Some of the factors to considerare: simplicity of code, efficiency when creating instances, efficiency whenFigure 2.11Classes for representing points using both Cartesian and polar coordinates. Only the operations are shownPointCPTestmain() PointCPgetX()getY()getRho()getTheta()convertStorageToCartesian()convertStorageToPolar()toString() Lethbridge.book  Page 58  Tuesday, November 16, 2004  12:22 PM<page> Section 2.959Classes for representing geometric points
doing computations that require both coordinate systems, and amount ofmemory used.
E27 Implement and test Design 5. Y ou will also have to make some small changes to
PointCPTest . Hints: a) Do you still need the variable typeCoord ? b) Do still you need the third argument in the constructor?
E28 Run a performance analysis in which you compare the performance of Design5, as you implemented it in the previous exercise, with Design 1. Determine themagnitude of the differences in efficiency, and verify the hypotheses youdeveloped in E26.
E29 To run a performance analysis, you will have to create a new test class thatrandomly generates large numbers of instances of 
PointCP , and performs operations on them, such as retrieving polar and Cartesian coordinates. Y oushould then run this test class with the two versions of 
PointCP  – Design 1 and Design 5.
E30 Summarize your results in a table: the columns of the table would be the twodesigns; the rows of the table would be the operations. The values reported inthe table would be the average computation speed. Make sure you explain yourresults.T able 2.1Alternative designs for the P PP Po oo oi ii in nn nt tt tC CC CP PP P  classHow Cartesian coordinates are computedHow polar coordinates are computed Design 1: Store one type of coordinates using a single pair of instance variables, with a flag indicating which type is storedSimply returned if Cartesian is the storage format, otherwise computedSimply returned if polar is the storage format, otherwise computedDesign 2: Store polar coordinates onlyComputed on demand, but not storedSimply returned Design 3: Store Cartesian coordinates onlySimply returned Computed on demand, but not stored Design 4: Store both types of coordinates, using four instance variablesSimply returned Simply returnedDesign 5: Abstract superclass with designs 2 and 3 as subclassesDepends on the concrete class usedDepends on the concrete class used Lethbridge.book  Page 59  Tuesday, November 16, 2004  12:22 PM<page> 60Chapter 2
Review of object orientation 
E31 Study the PointCPTest  class. It has a complex pair of loops for obtaining inputfrom the user.(a) Discuss whether you think the design is clear, and if not, why not.(b) Design, but do not yet implement, an alternative to 
PointCPTest  that does not have the nested loops. What are the drawbacks of this alternative design?(c) Implement and test your alternative design.
E32 In Design 5 of Table 2.1, we suggested creating an abstract superclass. Anotheralternative (we can call it Design 6) would instead involve turning 
PointCP  into an interface. Different classes corresponding to designs 1 to 4 would implementthis interface.(a) Design and implement this approach (with two different implementingclasses).(b) What advantages and disadvantages does this approach have? 
2.10 Measuring the quality and complexity of a program
It is very important for engineers to be able to measure properties of thematerials and devices they work with. A civil engineer, for example, needs toknow the load capacity of a beam so that he or she can decide on its requiredthickness or support. In software engineering, we work with pure informationas represented in programs, designs and other documents. Our goals ofmeasurement include: better prediction of the time and effort required fordevelopment, and, as was discussed in Section 1.5, improved control of aspectsof quality such as reliability, usability and maintainability.A metric is a well-defined method and formula for computing some value ofinterest to a software engineer. Below are some of the metrics relevant to thebasic principles of object-oriented programming and design we have discussedin this chapter. Each metric is useful as a rough indicator of some quality such as maintainability, or of work involved in development. However, each metricalso has disadvantages, which we will address.Lines of code: Y ou will often notice people describe the amount of work theyhave accomplished in terms of the number of lines of code they have written.This is a very easy metric to compute and is easy to understand. In large systems,the term KLOC is used, which means thousands of lines of code. A program withmore lines of code will typically take more time to develop and maintain than aprogram with fewer lines of code. Unfortunately, this is not always the case: asmaller program may be more technically complex than a larger program andtherefore require more development time; also, either program may be betterdesigned and therefore have fewer defects; finally, a programmer can addduplicate or unneeded lines to make the system appear bigger than it should be. Lethbridge.book  Page 60  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 66  Tuesday, November 16, 2004  12:22 PM<page> Section 3.269Incorporating reusability and reuse into software engineering
reuse of commercial off-the-shelf orCOTS software, and the extra codewritten is often called glue code. It iscommon to write the glue code usingscripting languages which run usingan interpreter.The elements reused in the latter three types of reuse are often collectively calledcomponents.Unfortunately, reuse is not as extensive in software engineering projects asmight be desirable. Some of the reasons for this are outlined in the next section.In this book, we want to encourage you always to think in terms of reuse whenyou develop software. Therefore, as a major part of this chapter, we will presenta reusable framework that will form the basis for many examples and exercises.
ExercisesE37
Search the Internet in order to build a list of sources of information about thefollowing things which can be reused during software development. Rate eachsource on a scale from low to high, where low means the source is veryuninformative (perhaps just offering to sell a product), and high means itprovides a wealth of practical information.(a) Wisdom and experience about software design (e.g. tips, guidelines etc.).(b) Written descriptions of standard algorithms.(c) Class libraries.(d) Code repositories.(e) Fourth-generation languages.(f) Macro packages you can add to spreadsheet or word processor programs.(g) Frameworks.(h) Scripting languages used to glue together COTS programs.
E38 Pick a couple of the best sources of information from the last exercise anddiscuss how they can help you achieve the reuse objective. 
3.2 Incorporating reusability and reuse into software engineering
In order for reuse to occur, software developers must not only reuse existinggood-quality components, but must also contribute to reusable componentsthat others can use.Newton on reuse
Reuse is not a new concept. It wasIsaac Newton who said,  ‘If I have seenfurther it is by standing on theshoulders of giants.’ Lethbridge.book  Page 69  Tuesday, November 16, 2004  12:22 PM<page> 74Chapter 3
Basing software development on reusable technology 
Horizontal and vertical frameworks
A framework can be horizontal or vertical (Figure 3.1). A horizontal frameworkprovides general application facilities that a large number of applications canuse. For example, if many applications need to have a ‘preferences’ dialog thatallows users to specify many kinds of options, then a horizontal frameworkcould be designed that would provide general ‘preferences dialog facilities’ formany different types of applications.
A vertical framework, often also called an application framework, provides facilities that will allow easy development of a more specific class of applicationprograms. The microwave oven, frequent-buyer and course registrationframeworks are vertical in nature, while the e-commerce framework might be ahybrid – a vertical framework composed of several horizontal frameworks thatperform the sub-functions (such as general secure payment facilities).A vertical framework will have a more complete implementation, and mayhave fewer slots and hooks. An interface in Java can be considered an extremeexample of a horizontal framework: there is no implementation, and all thespecified methods represent slots that must be filled.An application will typically use only a subset of the framework’s services. Forexample, a framework for a rental store could do such things as managemembership, handle deposits, process rentals and returns, and computepenalties for late returns. A developer using this framework to build anapplication for a video rental store would likely ignore the facilities for handlingdeposits, but would take advantage of the membership facilities. When buildinga car-rental system, the opposite would be true.Figure 3.1Horizontal and vertical frameworks showing services (at the top) and fillers of hooks and slots (at the bottom). One of the hooks is not filled
SlotVerticalframework
Code to be provided to adapt the frameworkto the needs of the applicationServices offeredby the framework
HookApplication Application
Horizontal frameworkSlot Hook HookSlot Lethbridge.book  Page 74  Tuesday, November 16, 2004  12:22 PM<page> Section 3.479The client–server architecture
T able 3.1Example client–server systemsSystemClientsServer The World Wide Web Browsers that display web pages and post forms, e.g. Netscape Navigator or Microsoft Internet ExplorerWeb servers that manage sets of web pages (as well as CGI programs and servlets), and send information to browsers when sent a URL EmailPrograms that read and send email. For example, Microsoft Outlook, EudoraA post-office program that receives email from remote sites and holds it until an email-reading client is activated. The program also forwards outgoing mail from the client to other sites Network file system Programs on any computer that access files that happen to be on other computersA program whose main purpose is to allow clients on other computers to access files. Unix NFS and Novell NetWare are examples Transaction processing system Programs that send specific requests to perform some kind of transaction, such as debiting a bank account or booking an airline ticketA program that centralizes all the functions of some business and processes transactions when they arrive Remote display system Programs that want to display information on the screen. Many Unix programs are capable of displaying graphical output on any computer running an X-Windows serverA program that manages the screen and allows applications, perhaps running on other computers, to display their output. A Unix X-Windows server is an important example Communication system A program that allows users to send a message or maintain a conversation with users on another computerA program that routes messages. It can have features such as ‘forwarding’ that people are familiar with from the telephone network Database systemAny application program that wants to query a databaseA database management system that responds to requests to query or update the database Lethbridge.book  Page 79  Tuesday, November 16, 2004  12:22 PM<page> Section 3.485The client–server architecture
– making the wrong choice can sometimes result in an overloaded network.Depending on the nature of the system, either a fat-client or a thin-client systemmay take the fewest network resources. In some cases, a thin-client system willneed to communicate the least because it generally sends only simple userrequests to the server. On the other hand, a thin client might need tocommunicate with the server much more frequently than a fat client and todownload voluminous results of the server’s calculations.
ExerciseE46
In each of the following systems, list: (i) the work normally performed on theserver side; (ii) the work normally performed on the client side; (iii) the typesof information transmitted in both directions over the network; (iv) whetherthe system is thin-client, fat-client or intermediate; (v) what could be done toFigure 3.5Threads in a client–server system
Figure 3.6A thin-client system (a) and a fat-client system (b). The clients are at the top and the servers are at the bottomkill client disconnectreply to messagecreatereply to messageconnect
displaydisconnectdisplay replydisplay replycreate
send messagesend messageClient Side (Client A) Server Sideinteractwith user wait forserver events wait forconnections
wait formessages:client Await formessages:client B interact withserver user
simplecommandsresultsfor displayHeavy computation(a)
Heavy computationLight computation
Light computationrequestsfor servicesresultsof requests(b)Heavy computation
Light computation Lethbridge.book  Page 85  Tuesday, November 16, 2004  12:22 PM<page> 86Chapter 3
Basing software development on reusable technology 
increase or decrease the proportion of work done on the client side; (vi) whateffects such changes would have on the network.(a) to (e) The systems from Exercise E45.(f)The world wide web in general (with browsers and web servers).(g)The email system that you use. 
Messages in a client–server system: communications protocols
The types of messages the client is allowed to send to the server form a language. The server has to be programmed to understand that language. Similarly,another language consists of the types of messages the server is allowed to sendto the client.When a client and a server are communicating, they are in effect having aconversation using these two languages. As with a human conversation, therehave to be rules to ensure, for example, that the communicating parties taketurns to speak. The rules also describe the sequences of messages that the clientand server must exchange, in order to reach agreement on something or toaccomplish some other task.The two languages and the rules of the conversation, taken together, are calledthe protocol. The design of protocols can be very complex; in simple systems,such as those discussed in this book, the protocol is merely a list of servicerequests and their responses.
Example 3.2 Sketch a protocol for a simple program for manipulating files on a remotecomputer. The following illustrates the kinds of messages sent between clients and theserver.
The above protocol does not deal with such things as security and logging in;nor does it suggest how the information would be presented to the user in afriendly way.Messages to server Possible replies to client
getFile  name fileContent , accessDenied , noSuchFileOrDir , failed  
saveFile  name content successful , accessDenied , failed  
rename  oldname newname successful , accessDenied , noSuchFileOrDir , failed  
delete  name successful , accessDenied , noSuchFileOrDir , failed  
listDir  fileList , accessDenied , failed  
changeDir  name successful , accessDenied , noSuchFileOrDir , failed  
createDir  name successful , accessDenied , failed   Lethbridge.book  Page 86  Tuesday, November 16, 2004  12:22 PM<page> Section 3.587T echnology needed to build client–server systems
ExerciseE47
Propose a simple protocol for the systems described in question E45. 
Tasks of the software engineer when developing a client–server system
When designing a client–server system, the software engineer should make useof a framework that provides much of the underlying mechanism. We willdescribe such a framework later; however, the designer still has four key thingsto design:1.The primary work to be performed by both client and server; i.e. thecomputations to be performed, data to be stored, etc.2.How the work will be distributed – thin client, fat client, or intermediate.3.The details of the set of messages that will be sent from the client to the serverand vice versa in order to accomplish the main activities, i.e. thecommunications protocol.4.What has to happen in the client and server when they start up, handleconnections, send and receive messages, and terminate.
3.5 T echnology needed to build client–server systems
In order to build a client–server system you need a computer network as well assoftware facilities for sending and receiving messages. There are severalstandards for data communication, and most modern programming languagesinclude suitable data communication packages. This section discusses basicInternet and Java technology you can use to construct client–server systems.
Some important network concepts
In order to be able to understand how a client and a server communicate witheach other, you must understand a few basic concepts about computer networks.Many books have been written about networks, but the few details discussedhere will be enough to enable you to understand client–server design.Since most computers today are connected to the Internet, we will assumethat clients and servers will communicate with each other using the Internet’smain communications mechanism, TCP/IP.‘IP’ stands for ‘Internet Protocol’ . The main function of IP is to route messagesfrom one computer to another. Long messages are normally split up into smallpieces which are sent separately and then reassembled at the destinationcomputer. Since the Internet is a large heterogeneous network of manycomputers and other devices, this routing process is quite complex. Luckily,Internet users rarely need to worry about the complexity. Lethbridge.book  Page 87  Tuesday, November 16, 2004  12:22 PM<page> Section 3.589T echnology needed to build client–server systems
use port 80 for any other kind of server since confusion will result. In this book,we will by default run servers on port 5555 if it is not already occupied by someother server. In general, when you create a new server, you must pick a portnumber and publish both the host name and port number so that clients knowwhere to connect. Taken together, the host name and port number are often justcalled the address of the server. By convention, if a client wants to talk to a serveron the same computer, it can use the special host name localhost (IP address 127.0.0.1).
Establishing a connection in Java
Java includes a package specially designed to permit the creation of a TCP/IPconnection between two applications: it is called 
java.net . The class Socket  is the central element of this package; instances of this class encapsulate informationconcerning each connection. Both the client and the server must have aninstance of 
Socket  in order to exchange information.Before a connection can be established, the server must start listening to oneof the ports. To do this, it uses the resources of the class 
ServerSocket . This is typically done as follows:
ServerSocket serverSocket = new ServerSocket(port);
where port is the integer representing the port number on which the servershould be listening.In order for a client to connect to a server, it uses a statement like thefollowing, passing the host name (or numeric IP address) and port number ofthe server:
Socket clientSocket = new Socket(host, port);
For the connection to be accepted, the server must have a thread constantlylistening for connections using a statement like the following, embedded in aloop:
Socket clientSocket = serverSocket.accept();
The above statement will wait indefinitely in the accept  method until a client tries to connect, then it will try to create an instance of 
Socket  to handle the new connection. If this is successful, both client and server now have instances of
Socket  and can communicate freely with each other.All of the above assumes the network is working properly, and appropriatevalues are specified for 
host and port. If communication fails for any reason,these statements will throw an 
IOException . Appropriate code must be written tohandle such exceptions, e.g. notifying the user of the failure or trying again.Once a connection is established, the exchange of communication maycommence. From now on, both client and server can send messages to eachother at any time. The connection is said to be symmetric, meaning that the client communicates with the server in the same way as the servercommunicates with the client. Lethbridge.book  Page 89  Tuesday, November 16, 2004  12:22 PM<page> 90Chapter 3
Basing software development on reusable technology 
Normally there will be two distinct streams of information: from server toclient and from client to server. Each program uses an instance of 
InputStream
to receive messages from the other program, and an instance of OutputStream  to send messages to the other program. These classes are found in the package
java.io , and their instances can be created as follows:
output = clientSocket.getOutputStream();input = clientSocket.getInputStream();
When a message is sent from one program using its OutputStream , it may be read by the other connected program using its 
InputStream . However, InputStream
and OutputStream  d e a l  w i t h  m e s s a g e s  c o m p o s e d  m e r e l y  o f  b y t e s ,  t h e  m o s tprimitive form of data. Programmers often want to exchange moresophisticated types of data without having to worry about how to translate theminto a byte stream. To do this, Java provides a series of filters which convert the raw bytes into other forms. For example, 
DataOutputStream  and DataInputStream
allow direct transmission of the Java primitive types such as int and double . Another pair of filters, 
ObjectOutputStream  and ObjectInputStream , allows the exchange of Java objects. For maximum flexibility, we will use this latter pair ofclasses in our client–server framework.To send an object, Java uses a process called serialization. This is a technique by which every object is converted by an 
ObjectOutputStream  into a binary form for transmission, and then reconstructed when it is received by an
ObjectInputStream . Most objects can be serialized; the only requirements are thatthey be instances of classes that implement the interface 
java.io.Serializable , and that the data in their instance variables also be serializable. Serialization isalso the mechanism used to save objects into a binary file.In order to use an object stream, you must wrap it around a binary stream inthe following manner:
output = new ObjectOutputStream(clientSocket.getOutputStream());
Y ou can then send an object thus:
output.writeObject(msg);
In order to receive objects, you create an object input stream thus:
input = new ObjectInputStream(clientSocket.getInputStream());
and then arrange for the following statement to be executed in a loop:
msg = input.readObject();
The readObject  method will wait until an object is received over the socket, oruntil an I/O error occurs. An I/O error will occur if the program at the other endof the connection is terminated. Lethbridge.book  Page 90  Tuesday, November 16, 2004  12:22 PM<page> Section 3.999An instant messaging application using the OCSF
will take to stop the listening thread. The default value of 500 ms is suitable formost applications.
3.9 An instant messaging application using the OCSF
To illustrate the use of OCSF, we present here a simple client–server instantmessaging system. We call this SimpleChat, and its source code can be found onthe book’s web site. The version presented here is Phase 1 of SimpleChat.Various project exercises found at the end of this and subsequent chapters askyou to add features to SimpleChat.The server side of SimpleChat is particularly simple. All the server does isecho messages coming from clients to all the connected clients; thus the class iscalled 
EchoServer . EchoServer  itself has no user interface; once started its processmust be killed or it will run indefinitely.As Figure 3.8 shows, 
EchoServer  is simply a subclass of AbstractServer . The main
method creates a new instance and starts listening for server connections bycalling 
listen . To provide feedback, all the callback methods simply print outmessages to the user’s console. The 
main methods are underlined since they arestatic.
The 
handleMessageFromClient  method does one more thing: it calls
sendToAllClients  in order to echo any messages. The following is the code for
handleMessageFromClient .
public void handleMessageFromClient (  Object msg, ConnectionToClient client){  System.out.println    ("Message received: " + msg + " from " + client);  this.sendToAllClients(msg);}
On the client side, ChatClient  is a subclass of AbstractClient  that overrides one method, 
handleMessageFromServer . This method does nothing but arrange forFigure 3.8Extending the OCSF framework to build the SimpleChat applicationAbstractClient
ClientConsoleaccept()display()main()«interface»ChatIFdisplay() AbstractServer
1
1clientUI
client
ChatClienthandleMessageFromServer()handleMessageFromClientUI()quit()EchoServer
handleMessageFromClient()
serverStarted()
serverStopped()
main() Lethbridge.book  Page 99  Tuesday, November 16, 2004  12:22 PM<page> 100Chapter 3
Basing software development on reusable technology 
messages to be displayed to the end-user, as discussed below. ChatClient  also has two other methods that are called by the user interface.The user interface of the client is carefully separated from the functional partof the client. A Java interface, 
ChatIF , is provided that specifies that any userinterface must implement a single method, 
display . One class called
ClientConsole  implements this interface; some other class could be substituted inplace of 
ClientConsole . For example, on the book’s web site you will find a classcalled 
ClientGUI . This substitute class simply has to implement the display
operation to work properly with ChatClient .When the client starts, the 
main method in ClientConsole  runs. This creates instances of 
ClientConsole  and ChatClient  (which runs as a second thread), andthen calls a method called 
accept  to await user input. The accept  method runs in a loop until the program is terminated; it sends all input to the instance of
ChatClient  by calling its handleMessageFromClientUI . This in turn calls sendToServer . The code for 
handleMessageFromClientUI  is written as follows:
public void handleMessageFromClientUI(String message){  try  {    sendToServer(message);  }  catch(IOException e)  {    clientUI.display       ("Could not send message to server. Terminating client.");    quit();  }}
Communication coming from the server works as follows. The frameworktriggers a call to 
handleMessageFromServer . This in turn calls the display  operation of 
ChatIF , which results in a call to the display  method in the user interface class
ClientConsole . The code for handleMessageFromServer  is as follows.
public void handleMessageFromServer(Object msg) {  clientUI.display(msg.toString());}
In the exercises at the end of the chapter, you will make some changes to Phase1 of SimpleChat. In subsequent chapters, you will have the chance to make manyother improvements and additions to its design. If you follow all the exercises,you will end up being able to transmit drawings in real time with the program. Lethbridge.book  Page 100  Tuesday, November 16, 2004  12:22 PM<page> Section 3.12105For more information
Test that this works by connecting a client to a server using a differentport from the default. If the port is omitted from the command line, then thedefault value should still be used.Server side:(c)Currently the server ignores situations where clients connect or disconnect . Modify the server so that it prints out a nice message whenever a clientconnects or disconnects. Hint: you will simply have to write code inEchoServer that overrides certain methods found in AbstractServer – studythe AbstractServer description above to determine which methods youhave to override.
E50 Make further modifications to the SimpleChat application, as follows:Client side:(a)Currently, the client simply sends to the server everything the end-user types.When the server receives these messages, it simply echoes them to all clients . Add a mechanism so that the user of the client can type commands thatperform special functions. Each command should start with the ‘#’ symbol– in fact, anything that starts with that symbol should be considered acommand.Y ou should implement commands specified as follows:(i)
#quit  causes the client to terminate gracefully. Make sure theconnection to the server is terminated before exiting the program.(ii)
#logoff  causes the client to disconnect from the server, but not quit.(iii)
#sethost <host>  calls the setHost  method in the client. Only allowed if the client is logged off; displays an error message otherwise.(iv)
#setport <port>  calls the setPort  method in the client, with the sameconstraints as 
#sethost .(v)
#login  causes the client to connect to the server. Only allowed if theclient is not already connected; displays an error message otherwise.(vi)
#gethost  displays the current host name.(vii)
#getport  displays the current port number.Server side:(b)Currently, the server does not allow any user input . Study the way user input is obtained from the client, using the 
ClientConsole  class, which implements the 
ChatIF  interface. Create an analogous mechanism on the server side.Design hint: you will have to add a new class you can call ServerConsole Lethbridge.book  Page 105  Tuesday, November 16, 2004  12:22 PM<page> 106Chapter 3
Basing software development on reusable technology 
that also implements the ChatIF  interface. Following your modifications,the following should be true:(i) Anything typed on the server’s console by an end-user of the servershould be echoed to the server’s console and to all the clients.(ii) Any message originating from the end-user of the server should beprefixed by the string ‘
SERVER MSG> ’.(c) In a similar manner to the way you implemented commands on the clientside, add a mechanism so that the user of the server can type commandsthat perform special functions. Y ou should implement commands specifiedas follows:(i)
#quit  causes the server to quit gracefully.(ii)
#stop  causes the server to stop listening for new clients.(iii)
#close  causes the server not only to stop listening for new clients, butalso to disconnect all existing clients.(iv)
#setport <port>  calls the setPort  method in the server. Only allowed ifthe server is closed.(v)
#start  causes the server to start listening for new clients. Only valid ifthe server is stopped.(vi)
#getport  displays the current port number.
E51 Make further modifications to the SimpleChat application, as follows.In Phase 1, clients are always anonymous. When a message is sent from aclient, it is echoed to all the other clients, but nobody knows who sent it. In thisexercise, you will implement a basic mechanism by which clients have a ‘loginid’ that is known both to the client and the server.Client side:(a) Add a new ‘login id’ command line argument to the client. This should bethe first argument, before the host name and port, because the host nameand port are optional in the sense that if they are omitted, defaults areused. The login id should be mandatory; the client should immediatelyquit if it is not provided. Design hint: the login id should be stored in aninstance variable in 
ChatClient . Y ou might ask the question: why not putthe instance variable in 
ClientConsole ? The reason is to separate the userinterface (how information is displayed and input) from the other aspectsof the system.(b) Whenever a client connects to a server, it should automatically send themessage ‘
#login <loginid> ’ (i.e. the string #login  with the login id appended to it) to the server. Note that this use of the ‘
#’ is different from what we Lethbridge.book  Page 106  Tuesday, November 16, 2004  12:22 PM<page> Section 3.12107For more information
have seen so far: the #login  is sent to the server; it is not handled by theclient as was the case with 
#quit , #logoff  etc.Server side:(c) Arrange for the server to receive the #login <loginid> command from theclient. It should behave according to the following rules:(i) The 
#login  command should be recognized by the server. Design hint:modify 
handleMessageFromClient  s o  t h a t  i t  d o e s  m o r e  t h a n  j u s t  e c h omessages.(ii) The login id should be saved, so that the server can always identify theclient. Design hint: use the 
setInfo  method to set the login id and the
getInfo  method to retrieve it again later.(iii) Each message echoed by the server should be prefixed by the login id ofthe client that sent the message.(iv) The 
#login  command should only be allowed as the first commandreceived after a client connects. If 
#login  is received at any other time,the server should send an error message back to the client.(v) If the 
#login  command is not received as the first command, then theserver should send an error message back to the client and terminatethe client’s connection. Hint: use the method called 
close  found in
ConnnectionToClient .
E52 Now that you have completed Phase 2 of SimpleChat, you can execute the testcases provided in the web site for Phase 2. Y ou should execute all the test casesthat are indicated to apply to Phase 2, along with a sample of test cases that aremarked as relevant only to Phase 1. When testing, use your own server withsomebody else’s client and vice versa. If you have followed the instructionsabove consistently, then you should have no trouble doing this. Lethbridge.book  Page 107  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 108  Tuesday, November 16, 2004  12:22 PM<page> Section 4.1111Domain analysis
The section is best placed at the start of the domain analysis document so thatyou can subsequently use the defined terms.C.General knowledge about the domain. Summarize important facts or rulesthat are widely known by the domain experts and which would normally belearned as part of their education. Such knowledge includes scientificprinciples, business processes, analysis techniques, and how any technologyworks. This is an excellent place to use diagrams; however, where possible,point the reader for details to any readily accessible books or other documents.This general knowledge will help you acquire an understanding of the data youmay have to process and computations you may have to perform.D.Customers and users. Describe who will or might buy the software, and inwhat industrial sectors they operate. Also, describe the other people who workin the domain, even peripherally. Mention their background and attitude aswell as how they fit into the organization chart, and relate to each other.E.The environment. Describe the equipment and systems used. The new systemor extensions will have to work in the context of this environment.F.Tasks and procedures currently performed. Make a list of what the variouspeople do as they go about their work. It is important to understand both theprocedures people are supposed to follow as well as the shortcuts they tend totake. If, for example, people are supposed to enter certain information on aform, but rarely do so, this suggests that the information is not useful. Taskslisted in this section may be candidates for automation.G.Competing software. Describe what software is available to assist the usersand customers, including software that is already in use, and software on themarket. Discuss its advantages and disadvantages. This information suggestsideas for requirements, and highlights mistakes to avoid.H.Similarities across domains and organizations . Understanding what is generic versus what is specific will help you to create software that might bemore reusable or more widely marketable. Therefore, determine whatdistinguishes this domain and the customer’s organization from others, as wellas what they have in common.Be careful not to write an excessive amount of detailed information. It is a wasteof effort to duplicate the original source material; your domain analysis shouldsimply include a brief summary of the information you have found, along withreferences that will enable others to find that information.No serious software project should be undertaken without a sound domainanalysis; a good knowledge of the domain of application considerably increasesyour chances of success. Many of the most successful software products havebeen developed by people who were actively working in the domain before theybecame software developers – such people have a better feel for what is reallyneeded. Lethbridge.book  Page 111  Tuesday, November 16, 2004  12:22 PM<page> 112Chapter 4
Developing requirements 
Once software engineers have a good grasp of the domain, they can move onto requirements analysis, which includes defining the problem to be solved andwhat software will be created to solve it. However, domain analysis should neverreally end: software engineers have the responsibility to continue improvingtheir understanding as development proceeds. An extension to the systemadded for a subsequent release will often merit a domain analysis of its own sub-domain.
Example 4.1 Outline in one paragraph the information you would need to gather in order toperform domain analysis for an airline reservation system. Y ou would attempt to learn as much as possible about such things as how airlineflights are scheduled; how fares are set and structured; and how ticketing andbooking works in the customer’s airline and other airlines. Y ou would study howthe various people in the airline reservation business, including travel agentsand airline employees, do their jobs; what existing reservation systems arecapable of doing and how they work; and what laws, regulations and other rulesgovern the industry. Y ou would study the functionality of competingreservation systems, particularly the many web-based systems currentlyavailable.
Example 4.2 Imagine you are performing a domain analysis in order to develop a new and bettertelephone response and dispatch system for medical emergencies. The system will beused by operators and paramedics who respond to calls to the emergency number911 (in North America) or 999 (in the UK). Summarize the information you wouldexpect to learn. Structure your answer using the categories of information wesuggest for a domain analysis document. A.Introduction. The domain is ‘Medical Emergency Dispatch’ . Y ou already knowthat the motivation for the domain analysis is to develop a new system thatwould improve upon existing systems. Y ou would want to record the qualitiesthat are valued in such systems; these presumably include accurate guidance tothe paramedics, fast response time, flexibility, and, above all, saving lives.B.Glossary. Much of the special terminology for this domain will be medical innature, but there will also be terminology related to communicationsequipment, emergency vehicles and rescue equipment.C.General knowledge about the domain. Y ou should obtain statistics about thecalls received and the types of cases handled; this will help you understand thelevel of performance the system must achieve. Other examples of informationto learn include: what are the different categories of emergency situations, andhow is each handled? how are addresses described (it is critically importantthat no mistake is made when communicating an address to an ambulancedriver)? how do dispatchers decide whether police, fire-fighters or other specialservices should also be dispatched? Lethbridge.book  Page 112  Tuesday, November 16, 2004  12:22 PM<page> Section 4.1113Domain analysis
D.Customers and users. In this domain, everyone, including operators, drivers,paramedics and doctors in hospitals, has a clearly defined role. Y ou shouldunderstand the knowledge they possess and what they need to learn during theprocess of handling an emergency. Y ou might discover that some dispatch workersare opposed to the introduction of any new software – they might have developedconsiderable skill with the existing methods, and fear a new system will render theirskills redundant, or even put them out of a job. Knowing this fact, you can takeactions to address their concerns and thus avoid any political problems.E.The environment. Study the computers and communications gear currently used.Y our customers may be willing to upgrade generic hardware, but your system willhave to work with specialized hardware that would be too expensive to replace.F.Tasks and procedures currently performed. The procedures that are currentlyused by dispatchers and paramedics will help you decide the functions that youhave to implement. These procedures are normally very well defined so thatthey can be followed without any decision-making delay even in a major crisis.Examples of procedures include: how decisions are made about whichambulance to dispatch to which address; how dispatchers and ambulancedrivers decide upon a route, especially when traffic is heavy or blocked; howpriorities are established in a disaster, when there are not enough ambulances;how communications are established among the dispatcher, the paramedicsand doctors in hospitals; and how records of each call are logged. The study ofthese procedures will help you identify what aspects can be improved and howthe software will become an asset to your customer. Y ou will also have to learnabout any standards, regulations and laws that may exist, so that the softwarecan conform to them.G.Competing software. Y ou might discover that there is widely used and well-respected emergency management software on the market. Y ou might come torealize that you have little chance of economically developing something thatwould be as good. In such a case, you would propose that your customer buythe widely used software. On the other hand, you might find that the market isunder-developed, with many opportunities for a product like yours to excel.With extra effort you might be able to create a generic product, rather than acustom product, and sell it to many different municipalities.H.Similarities across domains and organizations . The task of dispatching ambulances could be generalized as the problem of allocating the closestresource to a consumer. Y ou might therefore consider developing a genericframework for this aspect of the problem.
ExercisesE53
Describe as many sources of information as you can think of, that should beconsulted in order to perform a domain analysis for each of the following Lethbridge.book  Page 113  Tuesday, November 16, 2004  12:22 PM<page> 114Chapter 4
Developing requirements 
systems (see Appendix C for the descriptions of systems).(a) The police information system.(b) The household alarm system.(c) The GPS automobile navigation system.(d) The investments system.(e) The woodworking design system.
E54 Write a short domain analysis for one of the systems listed in Exercise E53using the format we proposed in this section. Record only the most importantinformation a software engineer would need to know in order to develop yourchosen system. Gather whatever information you can from several sources. Beresourceful in your hunt for information! Do not forget to consider includingany general or specific knowledge you might already possess. 
4.2 The starting point for software projects
When a development team starts work on a software project, their starting pointcan vary considerably. We can distinguish different types of project, based onwhether or not software exists at the outset, and whether or not requirements exist at the outset. The four broad categories of starting point are illustrated inFigure 4.1.
In projects of type A or B, the development team starts to develop newsoftware from scratch – this is sometimes called green-field development, alluding to constructing a new building where none existed before. In cases Cand D the team evolves an existing system, a rather more common situation.In cases A and C, the development team has to determine the requirementsfor the software – they either have a bright idea for something that might sell, orelse they are asked to solve a problem and have to work out the best way to solveFigure 4.1Starting points for software projects
Requirementsmust be determinedClients haveproduced requirementsNewdevelopment
AB
Evolution ofexisting systemCD Lethbridge.book  Page 114  Tuesday, November 16, 2004  12:22 PM<page> 116Chapter 4
Developing requirements 
above example, if we had stated: ‘the system will automate all the functions ofthe registrar’s office’ , that leaves open the possibility of including such featuresas fee payment, printing class lists and allocating rooms to courses.One way to set the scope is to list all the sub-problems you might imaginethe system attacking. To narrow the scope, you can then exclude some of thesesub-problems – perhaps they can be left for another project. Figure 4.2illustrates this.
Sometimes, an inappropriate choice of problem statement can result in ascope that is too narrow or completely wrong. To determine whether this isthe case, think about what will be the user’s ultimate high-level goal when they use the system, and the customer’s high-level goal for having itdeveloped.In the university registration example you could consider a student’s goal tobe ‘completing the registration process’ . However, you can see that thestudent’s higher-level goal might be, ‘obtaining their degree in the shortestreasonable time while taking courses that they find most interesting andfulfilling’ . This new goal sheds a different light on the problem; you mightconsider adding features to the system that would not otherwise haveoccurred to you, such as actively proposing courses based on an analysis of thestudent’s academic and personal-interest profiles.All the requirements gathering and analysis techniques described later inthis chapter can help in defining the problem and hence the system’s scope.Interviewing can give you the stakeholders’ personal perspectives;brainstorming can generate lists of ideas from which you can extract a suitableproblem or problems; use case analysis can give you a list of the possible thingsthe system could do; and prototyping can give everybody a better perspectiveabout what might be possible.It is a good idea to define the problem and scope as early as possible, beforegetting deeper into analysis of the detailed requirements. This prevents youfrom working on unnecessary requirements. However, as with domain analysis,your perspective on the problem will improve as analysis continues, hence theproblem statement may need to be refined several times.Figure 4.2Narrowing the project’s scope
Initial list of problemswith very broad scope NarrowedscopeScope ofanother system
exam schedulingroom allocationfee paymentbrowsing coursesregisteringfee paymentbrowsing coursesregistering
exam schedulingroom allocation Lethbridge.book  Page 116  Tuesday, November 16, 2004  12:22 PM<page> 118Chapter 4
Developing requirements 
user interface, which leads the clerks to put information in the wrong places.What, however, is the real problem and how might understanding this affectpotential solutions?The stated problem suggests that the solution is to clean up the user interface.However, the real problem is that many errors are made. Thinking about the realproblem leads us to realize that a better solution might involve completelyeliminating the data entry process, or at least reducing it. Perhaps some or all ofeach patient’s information could be obtained from a database (e.g. onemaintained by the government or insurance companies), or by scanning apatient’s driver’s license or some other document. Another issue to investigate iswhether all the information typed by the clerks is actually needed – if they haveto type less information, then maybe they will be able to spend more timechecking the accuracy of the important information.
Example 4.5 This is the inverse of the last example. This time, you are told by the customerthat the problem is, ‘the data-entry system is not “high-tech” enough’. Hence youare asked to write a system that scans drivers’ licenses and other documents inorder to enter a new patient’s name and address accurately and quickly. Whatmistake could you be making if you accept this problem statement and proceed todo exactly what the customer asks?Y ou should never accept a problem statement that merely says the technologylacks sophistication – simple technology is often perfectly adequate or evensuperior. The customers may not realize that software that accurately scansarbitrary documents and puts the relevant information in the correct fields willbe difficult to write, and hence would be expensive. In fact there is aconsiderable risk that the accuracy achieved by this approach might beinadequate, and that much maintenance would be needed – for example asdocument formats change. Once again, you should base your analysis on thereal problem – that clerks make too many errors. Y ou might discover that yourreal focus should be on improving the user interface of the existing system.
ExercisesE55
Define a possible scope for the following systems. First, list a wide range ofthings that the system could do. Then narrow down the scope. To do this, selecta minimal set of the most important features that you would implement in thefirst release of the system.(a) A police information system.(b) A system for real-estate agency.(c) A system for a public library.(d) A system for a car-rental agency. Lethbridge.book  Page 118  Tuesday, November 16, 2004  12:22 PM<page> 130Chapter 4
Developing requirements 
G.Steps. Describe each step of the use case using a two-column format, with theleft column showing the actions taken by the actor, and the right columnshowing the system’s responses.H.Postconditions. What state is the system in following the completion of thisuse case.In general, a use case should cover the full sequence of steps from the beginningof a task until the end.A use case should describe the user’s interaction with the system, not thecomputations the system performs. For example in a use case for withdrawingmoney from an automated teller machine, you would describe the fact that theuser inserts his or her card, responds to various prompts by pressing somebuttons, and then removes his or her card and money. Y ou would not describehow communication with the bank is established or how the system computesany fees it charges. The latter information is clearly important, but it belongs ina different part of the functional requirements.A use case should also be written so as to be as independent as possible fromany particular user interface design. In Example 4.10, for example, instead ofwriting, ‘Push the “Open… ” button’ as the first steps, we write ‘Choose the“Open… ” command’ . The command could then be implemented as a button, amenu item, a keystroke or a voice command. Similarly, we have not specifiedwhether the user types the file name or uses the mouse to select it from a list.Nor have we indicated what the ‘File open’ dialog looks like.
Example 4.10 Describe in a simplified format a use case for opening a file in an application. Use case: Open fileSteps:
Example 4.11 Briefly describe a use case for leaving a particular automated car park (parkinglot). Use case: Exit car park, paying cashActors: Car driversGoals: To leave the parking lot after having paid the amount due.Preconditions: The driver must have entered the car park with his or her car,and must have picked up a ticket upon entry.Actor actions System responses1. Choose ‘Open… ’ command. 2. Display ‘File open’ dialog.3. Specify filename.  4. Confirm selection. 5. Remove dialog from display. Lethbridge.book  Page 130  Tuesday, November 16, 2004  12:22 PM<page> Section 4.6131Use cases: describing how the user will use the system
Summary: When a driver wishes to exit the car park, he or she must bring hisor her car to the exit barrier and interact with a machine to pay the amount due.Related use case: Exit car park by paying using a debit cardSteps:
Note that we have not dealt with the case where the user has not entered enough
money at step 5. We will deal with this case later. A use case should normally include only actions in which the actor interactswith the system. For example, when developing use cases for a library system,you would not include actions such as ‘Get a book from the shelves’ or ‘Read thebook’ . However, if there is a manual task that must be done between twointeractions with the computer, then this can be part of the use case; forexample, ‘Stamp the book with the due date’ is a valid action in Example 4.12.
Example 4.12 Describe in detail the ‘Check out an item for a borrower’ use case as performed bythe checkout clerks at the circulation desk of a library. This is one of the use caseslisted in Example 4.9. Use case: Check out an item for a borrowerActors: Checkout clerk (regularly), chief librarian (occasionally)Goals: To help the borrower to borrow the item if they are allowed, and toensure a proper record is entered of the loan.Preconditions: The borrower must have a valid card and not owe any fines. Theitem must have a valid barcode and not be from the reference section.Steps:Actor actionsSystem responses1. Drive to exit barrier, triggering a sensor.2a. Detect presence of a car.2b. Prompt driver to insert his or her card.3. Insert ticket.4. Display amount due.5. Insert money into slot.6a. Return any change owing.6b Prompt driver to take the change (if any).6c. Raise barrier.7. Drive through barrier, triggering a sensor.8. Lower barrier.
Actor actionsSystem responses1. Scan item’s barcode and barcode of the borrower’s card.2. Display confirmation that the loan is allowed. Lethbridge.book  Page 131  Tuesday, November 16, 2004  12:22 PM<page> 132Chapter 4
Developing requirements 
Postconditions: The system has a record of the fact that the item is borrowed,and the date it is due.
ExerciseE63
Write use case descriptions for the following activities:(a) Paying a bill at an automatic teller machine.(b) Creating a table in a word processor.(c) Programming a microwave oven to turn on in five hours and heat somefood.(d) Read messages in a voice mail system.(e) Programming a thermostat to set the day and night temperatures.
Use case diagrams
Use case diagrams are UML ’s notation for showing the relationships among a setof use cases and actors. They help a software engineer to convey a high-levelpicture of the functionality of a system.It is not necessary to create a use case diagram for every system or subsystem.For a small system, or a system with just one or two actors, a simple list of usecases will suffice.As Figure 4.3 shows, there are two main symbols in use case diagrams: anactor is shown as a stick person and a use case is shown as an ellipse. Linesindicate which actors perform which use cases. Y ou do not actually need to writethe word ‘ Actor’ in each actor’s name; however, we find it useful to do this whenit helps prevent confusion with classes of the same names.
ExerciseE64
For the systems of Exercise E62, draw a use case diagram that shows whichactors perform which use cases. 
Extension, generalization and inclusion of use cases
Y ou may want to develop a group of distinct but related use cases. For example,when an actor interacts with a system to achieve a particular goal, he or she mayselect different options, perform some action repetitively, provide differentinputs, or answer too slowly causing a time-out error. Each variant or repetitive3. Stamp item with the due date.4. Confirm that the loan is to be initiated.5. Display confirmation that the loan has been recorded. Lethbridge.book  Page 132  Tuesday, November 16, 2004  12:22 PM<page> Section 4.6135Use cases: describing how the user will use the system
Use case: Attempt to open file that does not existRelated use cases:Extension of: Open file by typing name (extension point: step 4: Click ‘Open’)
Use case: Browse for file (inclusion)Steps:
The graphical notation for showing extension, generalization and inclusion isillustrated in Figure 4.4. The open triangle points to a generalization. The «extend»and «include» stereotypes show the other relationships between use cases. Note that actors can also be arranged in a generalization hierarchy. In Figure 4.4,‘System Administrator’ is a sub-actor of ‘Ordinary User’ . This means that all SystemAdministrators can also act as ordinary users, and do such things as open files.
ExercisesE65
Write the following use cases, which are related to the ‘Exit car park, payingcash’ use case of Example 4.11.(a) Exit car park by paying using a debit card.(b) Attempt to exit car park without initially entering enough money.(c) Exit car park.
E66 Draw a use case diagram showing the relationships among the use cases of thelast exercise. 
E67 Create a complete use case model for the systems you worked on in ExercisesE55 to E57.Actor actions System responses4. Click ‘Open’ . 4a. Indicate that file does not exist.4b. Correct the file name.4c. Click ‘Open’ . 5. Remove dialog from display.Actor actions System responses1. If the desired file is not displayed, select a directory.2. Display directory.3. Repeat step 1 until the desired file is displayed.4. Select a file. Lethbridge.book  Page 135  Tuesday, November 16, 2004  12:22 PM<page> 138Chapter 4
Developing requirements 
3.Y ou should be aware that when software requirements are derived from usecases, the software tends simply to mirror the way users worked before the software was developed. In other words, innovative solutions may not beconsidered. As an illustration of this last point, try to describe a use case foradjusting the wake-up time of an alarm clock. Y ou will probably follow theprocedure you use yourself to adjust your own clock, even though there mightbe more efficient and innovative ways to do it (for example, using speechrecognition).
Scenarios
A scenario is an instance of a use case that expresses a specific occurrence of theuse case with a specific actor operating at a specific time and using specific data.It can help to clarify the associated use case. It is also often simply called a use case instance.
Example 4.14 Describe a concrete scenario corresponding to the ‘Exit car park, paying cash’ usecase from Example 4.11. Steps:
4.7 Some techniques for gathering requirements
Y ou can gather requirements from the same sources of information as you usedfor domain analysis: i.e. from the various stakeholders, from other softwaresystems, and from any documentation that might be available.I n  t h i s  s e c t i o n  w e  l i s t  s o m e  s t r u c t u r e d  t e c h n i q u e s  t h a t  a r e  p a r t i c u l a r l yeffective at gathering (also known as eliciting) requirements. All of them can beused together to obtain a good set of requirements.The first gathering technique, observation, is used to obtain subtleinformation that stakeholders may not think of telling you. The next three,interviewing, brainstorming and prototyping, are complementary techniquesActor actions System responsesDrives to the exit barrier. Detects the presence of a car. Displays: ‘Please insert your ticket’ .Inserts ticket. Displays: ‘ Amount due $2.50’ .Inserts $1 into the slot. Displays: ‘ Amount due $1.50’ .Inserts $1 into the slot. Displays: ‘ Amount due $0.50’ .Inserts $1 into the slot. Returns $0.50. Displays: ‘Please take your $0. 50 change’ . Raises barrier.Drives through barrier, triggering sensor. Lowers barrier. Lethbridge.book  Page 138  Tuesday, November 16, 2004  12:22 PM<page> Section 4.7139Some techniques for gathering requirements
for actively asking for the opinions and knowledge of stakeholders as well asforcing the stakeholders to stretch their minds.Users participate in all four of these techniques, therefore they feel personallyinvolved in the project. This sense of involvement means that they will morereadily accept the final system. In Chapter 7, we will focus on users and discussother ways to make them feel personally involved.Gathering requirements is an iterative process that must be combined with aprocess of analyzing the requirements to systematically organize and prioritizethem. Building a use case model, as discussed in the last section, is a commonapproach to analysis. Y ou can also analyze requirements with the help of othertypes of UML diagrams discussed in Chapters 5, 8 and 9. The analysis processcan be done individually or in a group setting; often much analysis is done withusers during the brainstorming and iterative prototyping sessions we willdiscuss shortly.Whichever techniques you use, it is important to put adequate time and effortinto the requirements process. Many projects have run into problems becausethe software engineers rushed the requirements stage and jumped into design orcoding too early. Coding early can be fine as long as it is only rapid prototyping,not developing the final product.
Observation
Y ou can read documents and discuss requirements extensively with users, butoften only the process of observing the users at work will bring to light subtledetails that you might otherwise miss. For example, in a retail application youmay notice the manager bargaining with buyers over the price of certain items.In an interview, she may forget to tell you that this is something that ought to beautomated.In its simplest form, observation means taking a notebook and ‘shadowing’important potential users as they do their work, writing down everything theydo. Y ou can also ask users to talk as they work, explaining what they are doing.In another variation, you can videotape the session so that you can analyze it inmore detail later.Observation, and analyzing the resulting information, can consume a largeamount of time. Therefore it is best done only for the development of largesystems with which potential users will be performing complex tasks.
Interviewing
Interviewing is a widely used technique. However, a well-conducted series ofinterviews can elicit much more information than poorly planned ad-hocinterviews. Unfortunately, despite it being an important skill, software engineersare rarely trained in conducting interviews; the guidelines below should helpyou perform this important step effectively.F i r s t l y ,  p l a n  t o  h a v e  a s  m a n y  m e m b e r s  o f  t h e  s o f t w a r e  e n g i n e e r i n g  t e a minterview as many stakeholders as possible. Consider going beyond stakeholders, Lethbridge.book  Page 139  Tuesday, November 16, 2004  12:22 PM<page> 142Chapter 4
Developing requirements 
Brainstorming
Brainstorming is an effective way to gather information from a group of people.The general idea is that the group sits around a table and discusses some topicwith the goal of generating ideas. However, as with interviews, adding somestructure to the brainstorming process can help elicit a larger amount ofinformation. One of the keys to success is arranging for the brainstormingsession to be led, or moderated, by somebody trained in the process.The following is a suggested approach to organizing and running an effectivebrainstorming session:1.Call a meeting with representation from all stakeholders. Effective brain-storming sessions can be run with five to 20 people.2.Appoint an experienced moderator (also known as a facilitator) – that is,someone who knows how to run brainstorming meetings, and will lead theprocess. The moderator may participate in the discussions if he or she wishes.3.Arrange the attendees around the periphery of a table and give them plenty ofpaper to work with.4.Decide on a ‘trigger question’ . This is a key step in the process. A triggerquestion is one for which the participants can provide simple one-line answersthat are more than just numbers or yes/no responses.Examples of trigger questions include the following: What features areimportant in the system? What future sources of data should we anticipate?What outputs should be produced by the system? What classes do we need inour domain model? What interview questions should we ask? What issues havewe not considered? What are the risks or difficulties in this project? Whattrigger questions can we ask?The trigger question can be determined by the person who called the meeting,by the moderator, by a quick discussion, or by brainstorming followed by a vote.5.Ask each participant to follow these instructions:(a) Think of an answer to the trigger question, no matter how trivial orquestionable the answer is!(b) Write the answer down in one or two lines on a sheet of paper, one idea per sheet.(c) Pass the paper to the neighbor on your left (i.e. clockwise) to stimulate hisor her thoughts.(d) Look at the answers passed from your neighbor to the right and pass theseon to your left as well. Use the ideas you have read to stimulate your ownideas.6.Continue step 5 until ideas stop flowing or a fixed time (5–15 minutes) passes. Lethbridge.book  Page 142  Tuesday, November 16, 2004  12:22 PM<page> Section 4.7143Some techniques for gathering requirements
7.Moving around the table, ask everybody to read out one of the ideas on thesheets that happen to be in front of them. If anyone seeks an explanation, theoriginator of the idea may comment briefly (although he or she may choose notto say anything in order to remain anonymous). The moderator, or a secretary,writes each idea on a flip-chart. Then, optionally, the whole group may brieflydiscuss the idea.8.After a fixed time period, or after all ideas have been recorded on the flip-chart,the group may take a series of votes to prioritize them. For example, everyperson may be given a fixed number of votes that they can allocate to theanswers they think are the most important.The concept of passing ideas clockwise round the table is illustrated inFigure 4.5.
The main advantage of brainstorming is that in a moderated group session,people are energized and tend to spontaneously invent many good ideas,stimulated by what others have said. There are two advantages of using astructured approach as described above. First, introverted or timid people canhave their say effectively since anonymity can be assured. Sometimes, suchpeople think their ideas are not very good because they lack self-confidence.Second, a lot of thinking goes on in parallel: during the first phase, everybody isthinking of their own ideas and writing them down concurrently. The session istherefore more productive than if everybody had to wait their turn to expresstheir ideas.
ExerciseE71
Divide into groups of 7 to 12 people. Each group should then elect a moderatorand hold a brainstorming session for 20 minutes, following the proceduresdefined above. A possible trigger question might be: ‘what requirements couldFigure 4.5Phase 5 of structured brainstorming: passing ideas around the table to stimulate new ideas!!
! !!
! Lethbridge.book  Page 143  Tuesday, November 16, 2004  12:22 PM<page> Section 4.9149Reviewing requirements
well as to informal and formal requirements documents. Early prototypes ordrafts of requirements should be reviewed by the author and stakeholders, andthere may need to be several cycles of improvements and repeated review.The review process normally culminates with a formal requirements reviewmeeting at which all stakeholders are present. The stakeholders should havereceived the document well in advance in order for them to have read it. Ideally,most of the problems should have been eliminated by reviews of earlier drafts orprototypes, so that the formal review should not raise major controversies.However, if extensive changes are identified, then a further formal review maybe needed once the changes are made.Each individual requirement should be carefully reviewed. In order to beacceptable, a requirement should:1.Have benefits that outweigh the costs of development . Cost–benefit analysis is an important skill in software engineering. Y ou sum, in financial terms, thebenefits of the requirement (such as improvements in productivity or sales)and compare this to the sum of the costs (development cost, hardware neededfor users, training users, and ongoing maintenance, for example). Cost–benefitanalysis can be performed with considerable attention to detail; however, a veryrough estimate can often quickly show that a requirement will provide only aminimal benefit, but cost substantially more than this to develop. Suchrequirements should be immediately cut. In Chapter 11, we will discuss cost–benefit analysis in more detail and provide an example.2.Be important for the solution of the current problem . Many ideas might be useful to implement, and might have benefits that outweigh their costs;unfortunately you have to ruthlessly weed out the less important ideas in orderto reduce the total time required to develop the system, and to reduce risks bykeeping the software from becoming overly complex. The less important ideascan be deferred for future consideration.One of the most important rules in software engineering is the 80–20 rule,which says that 80% of the user’s problem can often be solved with 20% of thework. Y ou should initially consider producing only that first 20% of the system.The 80–20 rule is also called the Pareto principle.Building a list of requirements that does more than needed is sometimescalled ‘gold-plating’ or building a ‘Cadillac system’ .3.Be expressed using a clear and consistent notation . Each requirement should be expressed using language that the customers can understand and should beconsistent with the other requirements. Requirements are normally expressed ina natural language such as English, sometimes supplemented by a formal mathe-matical language, and often by some form of diagram. Whichever format is used,consistent style should be applied throughout the requirements document. Wesuggest that English sentences should use present tense, active voice, and expresswhat the system is to do in response to various inputs. For example, rather thanwrite: ‘The pharmacist will enter the patient ID number and then the patient’s Lethbridge.book  Page 149  Tuesday, November 16, 2004  12:22 PM<page> 150Chapter 4
Developing requirements 
medication record will be displayed’ ,write: ‘When the pharmacist entersthe patient ID number, the systemdisplays the patient’s medicationrecord. ’4.Be unambiguous. It is typical tofind that an English sentence canhave more than one interpretation.Often this is because words have several closely related meanings. For example,the following requirement has two ambiguities: ‘When the user selects anaircraft, the system assigns it to the flight. ’ The first ambiguity has to do withthe word ‘aircraft’: does this mean a specific plane, or does it mean a class ofaircraft (e.g. Boeing 747s)? Secondly, what does the word ‘flight’ mean? Is theaircraft being assigned just for a particular day’s departure, or is it beingassigned in general to a flight number that departs every day at the same time?5.Be logically consistent. Y ou should check consistency with any standards, withother requirements in the document, with higher-level requirements and withthe requirements for other subsystems. In a large system, it can be very hard tobe sure that a requirement does not contradict some other requirement insome subtle way. In fact, considerable research effort is spent finding ways toautomatically check requirements documents for consistency. However, sincesuch tools require the document to be written using a mathematical language,and do not yet work very well for large systems, careful proofreading is themain way to proceed.One of the most important ways to help ensure consistency is to avoidduplicating requirements. It is very common, for example, for a requirement tobe stated in the introduction to a document, and then repeated in more detail inthe body of the document. This is dangerous because if a change is made in oneplace, there is a tendency to forget to make the change in the other place. For thisreason, the introductions and conclusions of requirements documents shouldnot actually contain any requirements.Another aspect of consistency is consistency of the functional requirementswith the non-functional requirements and with the project plan. These areaddressed in the next two points.6.Lead to a system of sufficient quality. A requirement should contribute to asystem that is sufficiently usable, safe, efficient, reliable and maintainable. Ittakes a good deal of expertise to judge whether requirements meet these needs– special analysis techniques can also be applied that we will not discuss indetail in this book. For example, to assess the safety of a critical system, formalmathematical proof techniques may be employed. To assess usability, therequirements can be validated against a checklist of good user interface designprinciples. As we will discuss in Chapter 7, to fully validate a system’s usabilityyou have to observe users actually working with a prototype.Antoine de St. Exupéry on perfection
The importance of excluding unnecessaryrequirements brings to mind the words ofAntoine de St. Exupéry: ‘perfection is notachieved when there is nothing more toadd, but when there is nothing more todelete. Lethbridge.book  Page 150  Tuesday, November 16, 2004  12:22 PM<page> Section 4.9151Reviewing requirements
7.Be realistic with available resources. A requirement is realistic if thedevelopment team has the expertise and technology to implement it on therequired platform within the budget and time available. If there is any doubtabout whether a requirement is realistic, further analysis is required. Forexample, if there is uncertainty about whether an efficient algorithm can befound to perform some computation, then experimental prototypes should bedeveloped and tested before committing to make the computation arequirement.8.Be verifiable. The requirements document will not only be the basis for asystem’s design, but also for testing the system. There must be some way thatthe system can be tested so as to clearly conclude whether or not therequirement has been correctly implemented. As we mentioned earlier, thisissue is mostly a concern for quality and platform requirements. For example:‘ th e sea r c h r es ul t m us t be o b ta in ed ra p idl y’ is n o t v erifia b le beca use i t is t oovague; readers will wonder what ‘rapidly’ means. A better requirement wouldbe ‘the first results of the search must appear in less than 1 second on average,and in less than 3 seconds 95% of the time. ’9.Be uniquely identifiable. It is important to be able to refer to each individualrequirement. This is necessary in requirements review meetings so that peoplecan indicate which requirement they want to discuss. It is also necessary indesign documents to be able to say which requirement is being implemented bya given aspect of the design, a quality called traceability illustrated in Figure 4.7. The first step in making requirements identifiable is avoiding long paragraphs;ideally, each requirement should start a new paragraph. In some documents,each requirement is given a unique number – sometimes a hierarchical schemeis used, e.g. 4.7.12.3 means the third requirement in section 4.7.12. Numberingevery single point makes the document cluttered, however, and leaving off thefinal number, and requiring people to count a small number of paragraphs, isoften acceptable.
10.Not over-constrain the design of the system. As we have mentioned before, arequirement should avoid indicating how it will be implemented, in order togive the designer as much freedom as possible to make decisions.Figure 4.7Providing traceability by giving justification for what is written, either as pointers to requirements or as rationale
Designdocument....due torequirement 1.2Requirementsdocument1.1 XXXX.... because1.2 YYYY
rationale Lethbridge.book  Page 151  Tuesday, November 16, 2004  12:22 PM<page> 152Chapter 4
Developing requirements 
In addition to the above ten guidelines for individual requirements, there areseveral guidelines for requirements document as a whole:11.The document should be sufficiently complete . We already discussed how a document could either give a high-level overview or be more detailed.However, at the chosen level of granularity, it should cover all of thefunctionality of the system or subsystem. It should also include all appropriatequality, platform and process requirements.12.The document should be well organized. In particular, it should be carefullydesigned so that its structure can be easily understood; it can be quicklyscanned, and any given requirement can be easily found. This means giving it aclear title and dividing it into sections with meaningful headings andsubheadings.13.Reasoning should be clear. Rationale should be provided for all requirementsthat involve a large amount of analysis, that are controversial or for whichseveral alternatives are considered. Providing rationale serves severalfunctions: it reduces the need for software engineers in the future to have torepeat your analysis when they make changes; it convinces the reader that youdid in fact consider the alternatives; and it alerts the reader to the fact that therequirement may be controversial. Rationale provides traceability of therequirements to their justifications, as shown in Figure 4.7.14.The document should be agreed to by all the stakeholders . Requirements should only be considered definitive when all the stakeholders agree they are tobe implemented. The process of negotiation might result in trade-offs beingmade – a group of stakeholders may agree to a certain requirement only if achange is made to some other requirement. For example, one group may wantto run the software on older computers. They may only agree to constrain thesoftware to run only on new, fast computers if a web interface is added so thatthey can still see the output on their older computers.We suggest that a complete requirements document should have sectionscovering the following types of information. Add a table of contents and anautomatically generated index if the document is more than a few pages.A.Problem. Provide a succinct description of the problem the system is solving. B.Background information. Give information that will help readers understandthe requirements. It should contain references to domain analysis documents,standards, and the requirements of related subsystems. In this section you canalso discuss important issues you considered, and the rationale for yourdecisions (you can also place such rationale directly in sections D and E as longas those sections do not become cluttered with lengthy discussion).C.Environment and system models. Provide the context in which the systemruns and a global overview of the system or subsystem. Diagrams are very Lethbridge.book  Page 152  Tuesday, November 16, 2004  12:22 PM<page> Section 4.9153Reviewing requirements
useful here. Y ou should describe the hardware on which the system will run,and any other subsystems or software with which it will interact.D.Functional requirements. As discussed earlier, describe the services providedto the user and to other systems. Describe inputs, outputs, computations andtiming. Diagrams can again be useful.E.Quality, platform and process requirements . As discussed earlier, describe any constraints that must be imposed on the design of the system.
Example 4.15 Review the following short statement of functional requirements, pointing out anyproblems you find.Requirements for a restaurant advisor system. This system will allow people tochoose a restaurant in a city. Users enter one or more of the following criteria, andthen the system searches its database for suitable restaurants: food type, pricerange, neighborhood, size, service type (fast food, cafeteria, buffet, full service),smoking arrangements (none allowed, separately ventilated section, non-separately-ventilated section, allowed on outdoor patio only). The user can alsospecify a desired day and time-period, and the number of people in their party.The system will tap into the reservation database (of participating restaurants)and only display restaurants that have available space. After entering the criteria,the user clicks on ‘search’, and the system displays a list of matching restaurants.For restaurants that participate in the automated reservation system, the user canclick on ‘reserve’ next to a selection in order to make a reservation. Some of the problems with the above requirements:(i) Duplication of ‘the system searches for suitable restaurants’/‘the systemdisplays matching restaurants’ .(ii) ‘Food type’ , ‘price range’ , ‘neighborhood’ and ‘size’ are inadequatelydefined. Are these taken from a fixed set of values, or does the databasejust contain free-form information? It will be hard for the user to searchunless the values of these items are standardized.(iii) There is ambiguity regarding the ‘reservation database’ and the‘automated reservation system’ . Are these the same thing or not?(iv) It appears that some of the listed restaurants are not in the reservationsystem/database. If the user specifies the desired day and time-period,and the number of people in the party, what does the system do withrestaurants that are not ‘participating’? Are they omitted from the list?(v) Can the user select just one option or more than one option for ‘type offood’? The same question applies to ‘smoking arrangements’ (the usermay not care). Lethbridge.book  Page 153  Tuesday, November 16, 2004  12:22 PM<page> 154Chapter 4
Developing requirements 
(vi) If the user selects ‘reserve’ , there must presumably be some way for thesystem to record identifying information about the user, so that therestaurant knows who made the reservation. This is omitted.It should be noted that the document was called a ‘short statement of functionalrequirements’ , therefore we will hesitate to criticize the fact that it lacks qualityrequirements and rationale, or that it is just one large paragraph. However, itswriters should take care of these matters as they add more detail for the nextiteration.
ExercisesE73
The following are short statements of functional requirements for softwareapplications. Review each of them, listing as many problems as you can. Justifyyour answers by referring to the guidelines. (This exercise is particularlyeffective when done in groups of two or three.) (a)Simple interest calculation program. This is a handy utility for users whoare considering borrowing or lending money. A window pops up when theprogram starts. This has three fields entitled: ‘Principal:’ , ‘ Annual interestrate:’ and ‘Monthly interest payment:’ . Whenever the user edits one of thefields the other two fields are automatically computed.(b)Dispatcher automation system. This system helps speed up the process ofambulance dispatching. When an emergency call is received, an automatedvoice recognition system classifies the case into categories depending onthe level of emergency. All urgent cases are transmitted to the ambulancedispatcher, who will receive the patient’s record, a summary of the conversation with the operator, as well as the patient’s address and medicaldetails if known. The dispatcher uses the system to obtain the number ofthe closest available ambulance. The ambulance operator receives all theinformation about the case.(c)Inventory recording system. This system runs on dedicated computers atthe shipping and receiving gate of a warehouse. It is used by all warehousestaff. Whenever an item enters or leaves the warehouse, a staff member must record that fact in the system. A window is always visible on the screen to record items entering thewarehouse. This window has three fields, labeled ‘Product code’ , ‘Number’and ‘Description’ . Below these fields is an ‘OK’ key. To process an item, thestaff member simply has to enter the product id and click ‘OK’ , or press the‘return’ key. The ‘Number’ field defaults to one.If the clerk does not enter a product id, a dialog box appears with a listof valid product ids and their descriptions; the staff member selects a codefrom this list. The staff member can also type a description to add aproduct code. Lethbridge.book  Page 154  Tuesday, November 16, 2004  12:22 PM<page> 160Chapter 4
Developing requirements 
3. The system will be designed anticipating incorporation of input from aninertial navigation unit that would take over in cases where GPS signals fail.
ExerciseE77
Perform a requirements review of the GANA system described in this section. 
4.12 Requirements for a feature of the SimpleChat instant messaging program
A.Problem. Sometimes a user wants to prevent messages received by a givenclient from appearing on his or her screen. This might be because the client’suser is being deliberately annoying, or because the client’s user is sending lotsof public messages that are useful to other users but are not useful to thecurrent user.We therefore wish to add a facility to SimpleChat that will allow a given userto block messages coming from another specified user.B.Background information. See the requirements for SimpleChat Phase 2(exercises E49–E51 starting on page 104) for the system on which theserequirements are based. The features described in these requirements are partof Phase 3.Issues considered:Issue 1:Can the user block more than one other user at a time?Decision: Yes; however, he or she will have to issue a sequence of blockcommands.Issue 2:The user needs some way of finding out if he or she has anyblocking in progress, otherwise the user might forget that he orshe had earlier established blocking.Decision: Add a command called 
#whoiblock  that will list those clients I amblocking.Issue 3:It would be useful for a user to know if anyone is blockingmessages that come from him or her.Decision: Add a command called 
#whoblocksme  that will do this. Issue 4:Should the server be able to block messages?Option 4.1:Do not allow the server to block messages.Advantage:This would be simpler.Option 4.2:The server should be able to block ordinary messages fromclients, but not administrative messages such as 
#forward  etc. Advantage:This would prevent a malicious user from overwhelming theserver’s display. Lethbridge.book  Page 160  Tuesday, November 16, 2004  12:22 PM<page> Section 4.12161Requirements for a feature of the SimpleChat instant messaging program
Decision: Choose option 4.2.Issue 5:What types of messages should the user be able to block?Option 5.1:Block only private messages, but not public or channelmessages.Advantages:The user can always avoid public or channel messages bychanging channel.Disadvantages:Forcing the user to change channel is not really satisfactory –what if the user is interested in other messages on that channel?Option 5.2:Block private, public and channel messages.Decision: Choose option 5.2.Issue 6:How should this feature interact with forwarding? Theproblem: imagine we have clients A, B and C, with A set toforward all messages to B.Scenario 6.1:A blocks messages from C: should a message from C to A beforwarded to B as normal, or should it be blocked?Decision: Blocked.Scenario 6.2:B blocks messages from C (but A does not): should a messagefrom C to A be forwarded to B, or should it be blocked?Decision: Blocked.Scenario 6.3:B blocks messages from A (even though A has forwardedincoming messages to B).Option 6.3.1:Do not allow the blocking. However, this could be veryannoying for B; after all, it is not B that requested theforwarding. Maybe the forwarding is just another harassmenttactic of A.Option 6.3.2:Allow the blocking but continue allowing forwarding. Theproblem with this is that the forwarding effectively allows A tocircumvent B’s block.Option 6.3.3:Cancel the forwarding and establish a block.Decision: Choose option 6.3.3.Issue 7:Does it make sense to block messages from myself?Decision: No.Issue 8:Can a user block messages from the server?Decision: Yes.Issue 9:How does a user unblock messages?Decision: The 
#unblock  command with no arguments will cancel allblocking that a user has set up. The 
#unblock  command with anargument will cancel blocking for messages from that user only. Lethbridge.book  Page 161  Tuesday, November 16, 2004  12:22 PM<page> 168Chapter 4
Developing requirements 
chapter. The main difference from SimpleChat is that this project will involvemore complex object-oriented modeling and design.We suggest you work in groups of three or four on this project.The short description of functional requirements for this project is below. Onthe book’s web site (www.lloseng.com) we present a fully worked-out exampleof a project similar to this. Y ou may choose instead to base your project on oneof the system descriptions in Appendix C.The goal of this project is to create a system to manage the front-deskactivities of the ‘Interface Rapids Hotel’ . Y ou have been contracted to replace theexisting paper-based system, since your customers believe an automated systemwill save money and help them to serve guests better. The system will be used toenter reservations as well as to check guests in and out of the hotel.The hotel contains rooms in which guests can stay. Some hotel rooms adjoinothers; that is, there are internal doors between them. Each hotel room isassigned a quality level (e.g. a larger room or a room with a view would be betterthan a smaller room without a view). Each room also has a certain number andtype of beds, a room number, and a smoking/non-smoking status. Each qualitylevel has a maximum daily rate, although the rate that a guest pays may be less.When a hotel guest wishes to make a reservation, the hotel clerk asks him orher which nights he or she wants to stay and the type of room he or she wants.The system must verify if room(s) are available on those nights before allowinga reservation to be made.The hotel needs to record basic information about each guest, such as his orher name, address, telephone number, credit card etc. A reservation can becanceled at any time but some fees (a percentage of the room price) may becharged if the cancelation is done too late.When a guest checks in, a room is allocated to him or her until he or shechecks out. When the customer requests a specific room, this can be allocatedin advance at the discretion of the manager. The system must keep track of theguest’s account, and print his or her bill.
E81 Perform a domain analysis about hotel reservations. This will help you toresolve certain ambiguities that might be present in the above statement ofrequirements.
E82 Develop a full requirements definition for the above problem. Among thetechniques you should consider employing are the following: interview somepeople who run hotels, and take a look at existing front-desk systems; usebrainstorming techniques to refine the requirements; perform use caseanalysis, to determine who the actors are and what tasks they must perform. Asyou do the above, narrow the problem statement, excluding features that willnot be needed in the first release. Before you complete your requirementsdefinition, make sure you hold a formal review. Lethbridge.book  Page 168  Tuesday, November 16, 2004  12:22 PM<page> 182Chapter 5
Modeling with classes 
5.4 Generalization
We discussed generalization in Chapter 2, and presented several examples. Y ouwill remember that they are represented using a small triangle pointing to thesuperclass. They must follow the isa rule, and several other rules as well. Here,we will present some more issues to consider when creating generalizations.
Avoiding unnecessary generalizations
A common mistake made by beginners is to overdo generalization. Figure 5.11shows a taxonomy of different types of products that might be sold by a musicstore. However, to justify the existence of each class, there must be someoperation that will be done differently in that class. In the case of Figure 5.11, itwould be hard to imagine that there would need to be different methods writtenfor most of the classes. For example, 
JazzRecording , ClassicalRecording  and
BluesRecording  would not differ with regard to how they are sold, nor with regardto what kinds of information clients can find out about them.
A better way to model the information in Figure 5.11 is to create a classdiagram such as that in Figure 5.12 (a). Most of the classes from Figure 5.11 nowbecome instances of 
RecordingCategory , and the hierarchy itself becomes ahierarchy of instances, as shown in Figure 5.12 (b). In fact, Figure 5.12 (b) is anexample of an object diagram – we will discuss these further shortly.
Handling multiple generalization sets
A generalization set is a labeled group of generalizations with a commonsuperclass; the label describes the criteria used to specialize the superclass intotwo or more subclasses. It is clearest to unite all thegeneralizations in a set using a single open triangle. Y ou placethe label next to the open triangle.Two examples of generalization sets, as used in a zoologyprogram, are shown in Figure 5.13. Animals can be divided upby habitat into aquatic and land animals, or by type of food, into carnivores and herbivores.Figure 5.11A hierarchy of classes in which there would not be any differences in operations. This should be avoidedClassicalRecording BluesRecording RockRecording JazzRecordingMusicVideoRecording
VideoRecording AudioRecording
Discriminators
In earlier versions of UML,generalization set labels werecalled discriminators. That termis now obsolete. Lethbridge.book  Page 182  Tuesday, November 16, 2004  12:22 PM<page> 184Chapter 5
Modeling with classes 
lower level in the hierarchy. The drawback to this is that all the featuresassociated with the second generalization set would also have to be duplicated.For example, you would have to provide a 
prey association for both
AquaticCarnivore  and LandCarnivore . Another problem with this solution is thatthe number of classes can grow very large. If you wanted to add omnivores, youwould have to add both 
AquaticOmnivore  and LandOmnivore . Figure 5.14 therefore is not an ideal solution.
Another possible solution, using multiple inheritance, is shown in Figure 5.15. This approach uses even more classes and generalizations but avoids duplicationof features. However, multiple inheritance generally adds too much complexity.This example illustrates one reason why it should normally be avoided; a secondreason is that multiple inheritance does not exist in Java.
In the next chapter, we will discuss the player–role pattern, which provides a superior solution to the problem of multiple generalization sets.
Avoiding having objects change class
Another issue that can arise when creating generalizations is avoiding the needfor objects to change class. In general, an object should never need to changeFigure 5.14Allowing different combinations of features by duplicating a generalization set label at a lower level of the hierarchy. Duplication like this should be avoidedAnimal
habitat
typeOfFood typeOfFoodAquaticAnimal LandAnimal
LandCarnivore LandHerbivore AquaticCarnivore AquaticHerbivore
Figure 5.15Allowing different combinations of features by using multiple inheritance. This is complex and should be avoidedAnimal
habitat
LandCarnivore LandHerbivore AquaticCarnivore AquaticHerbivoreAquaticAnimal LandAnimal Carnivore HerbivoretypeOfFood Lethbridge.book  Page 184  Tuesday, November 16, 2004  12:22 PM<page> Section 5.4185Generalization
class. In most programming languages, changing class is simply not possible;therefore you have to completely destroy the original object and create a newinstance of the second class. This is complex and error prone because you haveto copy all the instance variables and make sure that all links that connected tothe old object now connect to the new one.The need for an object to change class is illustrated in Figure 5.16. It is clearthat during his or her studies, the attendance status of a student can change fromfull-time to part-time and vice versa. Y ou do not want to model this situation inyour system by destroying a 
PartTimeStudent  and creating a FullTimeStudent , or the opposite, each time the student’s status changes. For this reason Figure 5.16is a poor model. A possible solution is simply to make 
attendanceStatus  an attribute of 
Student  and to omit the two subclasses completely. The problem withthis is that we lose the advantage of polymorphism for any operations thatwould differ in 
PartTimeStudent  and FullTimeStudent . The player–role pattern, discussed in the next chapter, can again provide a better solution.
ExerciseE90
Draw a class diagram corresponding to the following situations.(a) An organization has three categories of employee: professional staff,technical staff and support staff. The organization also has departmentsand divisions. Each employee belongs to either a department or a divisionA s s u m e  t h a t  p e o p l e  w i l l  n e v e r  n e e d  t o  c h a n g e  f r o m  o n e  c a t e g o r y  t oanother.(b) A grocery store has some items sold by weight, and some per unit. Someitems are taxable, while others are not. Some items have special prices whensold in groups (e.g. 3 for $2). Finally, some items have special prices if youhave certain ‘membership cards’ . There could be several differentmembership prices on the same item, but you can only use onemembership card per purchase.(c) A media player that can handle sound, images and sequences of images.Each type of media requires a ‘plugin’ , although some plugins can handlemore than one type of media.Figure 5.16A situation in which objects will need to change class from time to time. Generalizations of this type should be avoidedStudent
FullTimeStudent PartTimeStudentattendance Lethbridge.book  Page 185  Tuesday, November 16, 2004  12:22 PM<page> 186Chapter 5
Modeling with classes 
5.5 Object diagrams
Class diagrams tell us what classes will exist in a given system, but they are quiteabstract. Sometimes it can be hard to visualize the relationships among theobjects that will exist at run-time.An object diagram shows an example configuration of objects and links thatmay exist at a particular point during execution of a program. Objects are shownas rectangles, just like classes; the difference is that the name of the class isunderlined and preceded by a colon,
:Employee , for example. Y ou can also give aname to each instance before the colon, as in 
Pat:Employee , or even omit the class name entirely if it is clear from the context, such as 
Pat:. A link between two objects is shown as a simple line. Y ou can imagine thateach of the two objects contains a pointer to the other object joined by the link.The reality can be a little more complex than this, but while we are doinganalysis, a simple vision suffices.It is important to understand the relationship between a class diagram and anobject diagram. A class is an abstract representation of all the instances of thatclass that can ever exist. Similarly, an association represents all the links betweentwo classes that can ever exist. It should be clear from this that while we putmultiplicity symbols on associations, we never put them on links.We say that a given object diagram is generated by a class diagram. This means that it contains instances and links of the classes and associations present in theclass diagram. It also means that the numbers of links among instances areconsistent with the multiplicity of that class diagram. A class diagram cangenerate an infinite number of object diagrams.We have already used an object diagram in Figure 2.2 to represent examplesof instances, including their attributes.Figure 5.17 shows object diagrams generated from two of the class diagramsof Figure 5.3.   
Figure 5.17Object diagrams generated from class diagrams
Wayne:Em ployeePat:Employee
OOCor p:Com pany OOCor p's Boar d:
UML inc:Com pany UML inc’ s Boar d: Carla:Em ployee
Terry:EmployeeAli:Em ployee Lethbridge.book  Page 186  Tuesday, November 16, 2004  12:22 PM<page> 198Chapter 5
Modeling with classes 
Figure 5.25(d) is similar to Figure 5.25(c), except that two subclasses of
Person  have been added. This allows for the removal of a constraint, but isotherwise of minimal benefit. The 
sex attribute of person is now removed. Apolymorphic operation would now have to be provided that has differentmethods in 
Woman  and Man. These methods might both return constant values,either 
"female"  or "male" .
ExercisesE97
Using Figure 5.25(d), describe how the following operations of class Person
would be performed. Y ou do not need to write code; simply describe how theavailable information would be used to compute the result.
(a) getSiblings(b) getHalfSiblings(c) getStepSiblings(d) isMarried
(e)getNumberOfMarriages  
E98 Write OCL constraints expressing the following facts about Figure 5.25(d):(a) Y ou cannot die before you are born.(b) The date of a marriage always precedes the date of that marriage’s divorce.
E99 Give the advantages and disadvantages of Figure 5.25(d), as opposed toFigure 5.25(c).
E100 A possible variation of Figure 5.25(c) would be to create a class Marriage  that is a subclass of 
Union .(a) Describe the two classes 
Union  and Marriage  in terms of their associationsand attributes.(b) What would be the advantages and disadvantages of this change, asopposed to Figure 5.25(c)?
E101 Extend the genealogical example to handle the following situations:(a) Adoption and adopting parents.(b) Same-sex unions (but still ensuring that the biological parents of a childmust be of opposite sex).  Lethbridge.book  Page 198  Tuesday, November 16, 2004  12:22 PM<page> Section 5.9199The process of developing class diagrams
5.9 The process of developing class diagrams
So far in this chapter we have discussed the syntax of class diagrams, and haveraised some issues about what constitutes a good or bad model. Y ou may,however, be left wondering: where do I start, and what steps should I take toensure I build an effective model? This section provides some guidance on thisissue.
Models of the domain, versus models of the system
Y ou can create class diagrams or other UML models at different stages in thesoftware engineering process and with different purposes and levels of detail.Three types of model are listed in Table 5.1.First, you can create informal class diagrams while performing domainanalysis – these constitute part of what we call an exploratory domain model. Such diagrams represent what you have learned about the various entities andrelationships in the domain; they help in understanding that domain. They arenot, however, intended to model the software you will develop. They normallyhave some classes, associations and attributes that are outside the scope of thesystem. Also, in an exploratory domain model, you would not normally beconcerned with operations and polymorphism, nor with many of the modelingprinciples we have discussed so far, such as avoiding multiple inheritance.During requirements analysis or the early stages of design you will need todevelop a model that also contains domain classes, associations and attributes.But this time, the model represents data that will actually be manipulated andstored by the system. W e call this the system domain model; most of the class diagrams discussed so far in this chapter can be considered to be of this type.When we say ‘domain model’ we are referring by default to the system domainmodel, not the exploratory one. The classes in this model become real softwaremodules and the instances of most of these classes normally end up being storedClass diagrams versus entity-relationship diagrams
Database designers have for many years used a notation called Entity Relationship Diagrams (ERDs).This notation has much in common with UML’s class diagrams; in fact, the developers of OMT, apredecessor to UML, took many ideas from ERDs. In ERDs, the ‘entities’ are similar to classes andthe ‘relationships’ are similar to associations. Relationships are shown using a large diamond symbol,which is one of the features that makes them substantially more bulky than class diagrams. Also,standard ERDs do not show operations. Traditional ERDs did not show inheritance either, butExtended ERDs (EERDs) do.ERDs are still widely used in the database community, although many database designersprefer now to use UML class diagrams. Those who prefer to continue using ERDs do sobecause the database community has developed many ERD tools and considerable expertiseat using both the notation and the tools. Lethbridge.book  Page 199  Tuesday, November 16, 2004  12:22 PM<page> Section 5.9205The process of developing class diagrams
(f) The woodworking design system.
Identifying associations and attributes
Once you feel you have a good initial list of classes, it is time to turn yourattention to identifying associations and attributes.The best way to do this is to start with the class or classes that you think aremost central and important to the system. For each of these, decide on the clearand obvious data it must contain and its relationships to other classes. Thenwork outwards towards the classes that are less important.As you add an association or attribute, make sure it is relevant to theapplication – that it will be needed to implement some requirement. Forexample, you might be tempted to add many different attributes to a class
Person: name , height , weight , dateOfBirth , educationLevel  etc. But do you really need all this information in your application? If there is no requirement tomanipulate certain information, then representing that information in yourmodel adds unnecessary complexity.As you are adding attributes and associations, follow the principles of goodmodeling discussed in the earlier sections of this chapter. For example, analyzeeach association to make sure its multiplicity is correct.
Tips about identifying and specifying valid associations
To find out whether an association should exist, ask yourself if one classpossesses, controls, is connected to, is related to, is a part of, has as parts, is a member of, or has as members some other class in your model. Y ou will oftenfind statements of these types by scanning the document from which youextracted the original list of classes.As you add each association, remember to specify the multiplicity at bothends and label it clearly.An association is only legitimate if its links will survive beyond the executionof any particular operation. Associations in domain models will normally bestored in a database. So, if you do not think that the information captured by anassociation will need to be stored, then perhaps the association should beeliminated.A common mistake is to represent actions as if they were associations. Forexample, imagine you had classes 
LibraryPatron  and CollectionItem  (where a
CollectionItem  might be a book, video recording, etc.) Y ou might initially thinkthat 
borrow  and return  should be associations between these two classes. On thesurface this seems reasonable since you might want to keep a record of each ofthese actions. However, the correct way to model this information is to use aseparate class 
Loan, as shown in Figure 5.27.
Tips about identifying and specifying valid attributes
Attributes can be identified by looking at the description of the system andsearching for information that must be maintained about instances of each class. Lethbridge.book  Page 205  Tuesday, November 16, 2004  12:22 PM<page> 214Chapter 5
Modeling with classes 
a1. (public) The instance of SpecificFlight  makes a unidirectional link tothe instance of 
Airplane , and then calls operation a2.a2. (non-public) The instance of 
Airplane  makes a unidirectional link backto the instance of 
SpecificFlight .(b)Creating an object and linking it to an existing object ; e.g. creating a
FlightLog , and linking it to a SpecificFlight .b1. (public) The instance of 
SpecificFlight  calls the constructor of FlightLog
(operation b2); then, when it is complete, makes a unidirectional link tothe new instance of 
FlightLog .b2. (non-public) Class
 FlightLog ’s constructor, among its other actions,makes a unidirectional link back to the instance of 
SpecificFlight . (c)Creating an association class, given two existing objects ; creating an instance of 
Booking , for example, which will link a SpecificFlight  to a
PassengerRole .c1. (public) The instance of 
PassengerRole  calls the constructor of Booking
(operation c2).c2. (non-public) Class
 Booking ’s constructor, among its other actions, makesa unidirectional link back to the instance of 
PassengerRole , makes a unidirectional link to the instance of 
SpecificFlight , and calls operations c3 and c4.c3. (non-public) The instance of 
SpecificFlight  makes a unidirectional linkto the instance of 
Booking .c4. (non-public) The instance of 
PassengerRole  makes a unidirectional linkto the instance of 
Booking .(d)Changing the destination of a link; e.g. changing the 
Airplane  linked to a
SpecificFlight , from airplane1:  to airplane2: .d1. (public) The instance of 
SpecificFlight  deletes the link to airplane1:
makes a unidirectional link to airplane2: , calls operation d2, and thencalls operation d3.d2. (non-public) 
airplane1:  deletes its unidirectional link to the instance of
SpecificFlight .d3. (non-public) 
airplane2:  makes a unidirectional link to the instance of
SpecificFlight .(e)Searching for an associated instance; e.g. searching for a crew memberassociated with a 
SpecificFlight  that has a certain name.e1. (public) Create an 
Iterator  over all the crewMember  links of the
SpecificFlight , and for each of them call operation e2, until it finds amatch.e2. (may be public) The instance of 
EmployeeRole  returns its name. These types of collaborations are applicable in many different systems. Lethbridge.book  Page 214  Tuesday, November 16, 2004  12:22 PM<page> Section 5.9215The process of developing class diagrams
Notice that it would be very harmful for any of the non-public methods to becalled directly – they would end up only performing part of a completeresponsibility, leaving the system in an unstable state.
ExercisesE108
Add operations to the examples you worked on in Exercises E102 to E104 andE106. 
E109 Add operations to the genealogical example of Figure 5.25(c), which you alsoworked on in Exercise E107.
E110 Use the techniques described in this section to extend the airline system. Y ourextended system should include the requirements listed below. Y ou shouldproduce a single class diagram showing classes, attributes and generalizations.Do not show operations yet.(a) Flights fly from one airport terminal to another, but may also have severalintermediate stops. A passenger can be booked on one or more of the legsof a flight.(b) Passengers can query the system to determine at what times flights areavailable from their desired origin city to their desired destination city(they do not care about which terminal or airport is used by the airline).(c) Flights have scheduled departure and arrival times, but they can be late,therefore they have actual departure and arrival times as well.(d) The airline may add charter flights that are not regularly scheduled.(e) The airline publishes prices that apply between any pair of cities to which itflies. Business class, regular and seat-sale fares are available.(f) Passengers buy tickets and are charged the prices in effect when theirtickets were booked. Each ticket involves a complete itinerary, composed ofa sequence of one or more legs. The fare type is not necessarily the same foreach leg of the flight.(g) Passengers are automatically part of a frequent-flier plan. They accumulatepoints based on the distance they flew and their fare type (business class ornot).
E111 (a) Determine the responsibilities needed to implement the requirementslisted in the previous exercise (omitting the responsibilities that merelyinvolve setting and getting attributes).(b) Determine all the operations needed to implement the responsibilities –specifying in which classes they belong.  Lethbridge.book  Page 215  Tuesday, November 16, 2004  12:22 PM<page> Section 5.10217Implementing class diagrams in Java
private List crewMembers; // of EmployeeRoleprivate List bookings;
The following shows the code needed to implement a responsibility in
RegularFlight  to create a new SpecificFlight . This follows the pattern of responsibility (b) from the last section.
class RegularFlight{  private List specificFlights; ...  // Method that has primary responsibility  public void addSpecificFlight(Calendar aDate)  {    SpecificFlight newSpecificFlight;    newSpecificFlight = new SpecificFlight(aDate, this);    specificFlights.add(newSpecificFlight);  }...}class SpecificFlight{  private Calendar date;  private RegularFlight regularFlight; ...  // Constructor that should only be called from  // addSpecificFlight  SpecificFlight(    Calendar aDate,    RegularFlight aRegularFlight)  {    date = aDate;    regularFlight = aRegularFlight;  }}
To implement an association where the multiplicity at the other end has a small,fixed upper bound, you can use a regular array. An example is the 0..2multiplicity in the association between 
PersonRole  and Person  in Figure 5.31. Remember that if you do this you should make sure you are not limiting theflexibility of the system.
Person  would declare the following instance variable:
private PersonRole[] roles = new PersonRole[2]; Lethbridge.book  Page 217  Tuesday, November 16, 2004  12:22 PM<page> Section 6.2225The Abstraction–Occurrence pattern
AntipatternsThese antipatterns are examples of real mistakes made by beginners.One inappropriate solution, shown in Figure 6.2(a), is to use a single class.This would not work, because information would have to be duplicated in eachof the multiple copies of a book. For example, the different copies of Moby Dick can be borrowed by different people; there would, therefore, have to be separate‘Moby Dick’ instances, listing the same name, author and ISBN.
Another very bad solution, shown in Figure 6.2(b), is to create a separatesubclass for each title (i.e. a class 
GulliversTravels  and another class MobyDick  ). Information such as name, author, etc. would still be duplicated in each of theinstances of each subclass. Furthermore, this approach seriously restricts theflexibility of the system – you want to be able to add new books without havingto program new classes.Figure 6.2(c) shows another invalid solution: making the abstraction class asuperclass of the occurrence class. This would not solve the original problempresented in this pattern, since, although the attributes in the superclass areinherited by the subclasses, the data in those attributes is not. For example, eventhough there is a 
name attribute defined in the superclass Title , we would still have to set the value of this attribute in every instance of 
LibraryItem . RelatedpatternsWhen the abstraction is an aggregate, the occurrences are also typicallyaggregates. The result is the Abstraction–Occurrence Square pattern, illustratedin Figure 6.3.ReferencesThis pattern is a generalization of the Title–Item pattern of Eriksson and Penker(see the ‘For more information’ section at the end of the chapter).
ExerciseE113
Apply the Abstraction–Occurrence pattern in the following situations. For eachsituation, show the two linked classes, the association between the classes, andthe attributes in each class.Figure 6.2Inappropriate ways to represent abstractions and occurrencesLibraryItemnameauthorbarCodeNumberisbnpublicationDatelibOfCongress
(a)LibraryItemnameauthorbarCodeNumberisbnpublicationDatelibOfCongress
MobyDick GulliversTravels(b)TitlenameauthorisbnpublicationDatelibOfCongress
LibraryItembarCodeNumber
(c) Lethbridge.book  Page 225  Tuesday, November 16, 2004  12:22 PM<page> 228Chapter 6
Using design patterns 
RelatedpatternsThe Reflexive Association, discussed in Section 5.3, can be considered to be apattern. Figures 5.8, 5.12(a) and 5.25(a) show that hierarchies of objects can bemodeled using asymmetric reflexive associations. Doing so, however, does notallow for the special «NonSuperiorNode» classes that occur in the context of theGeneral Hierarchy pattern.The Composite pattern is a specialization of the General Hierarchy pattern. Inthe Composite pattern, the association between «SuperiorNode» and «Node» isan aggregation. A Composite is a recursive container; that is, a container thatcan contain other containers. This is the case with directories in a file system(Figure 6.4) as well as instances of 
GUIComposite  (Figure 6.5). ReferencesThe Composite pattern is one of the ‘Gang of Four’ patterns. See the book byGamma, Helm, Johnson and Vlissides in ‘For more information’ .
ExercisesE114
Figure 5.21 shows a hierarchy of vehicle parts. Show how this hierarchy mightbe better represented using the General Hierarchy pattern (or more precisely,by the Composite pattern). 
E115 Revisit Exercise E91. Did you use the General Hierarchy pattern? If not, thenredo the exercise, showing a hierarchy of various levels of government. Imaginethat municipalities are the lowest levels of government. 
E116 An expression in Java can be broken down into a hierarchy of subexpressions.For example, 
(a/(b+c))+(b-func(d)*(e/(f+g)))  has (a/b+c))  as one of its higher- level subexpressions.(a) Using the General Hierarchy or Composite pattern, create a class diagramto represent expressions in Java. Hints:(i) A higher-level expression might have more than two parts. (ii) The parts of a higher-level expression are connected by operators; howcan these be represented? (iii) Think about what the «NonSuperiorNodes» must be. (iv) Some expressions are surrounded by parentheses, while others neednot be; how can this be represented?(b) Using your class diagram from part (a), create an object diagram for theexample above.
6.4 The Player–Role pattern
ContextThis modeling pattern can solve modeling problems when you are drawingmany different types of class diagram. A role is a particular set of features Lethbridge.book  Page 228  Tuesday, November 16, 2004  12:22 PM<page> Section 6.4229The Player–Role pattern
associated with an object in a particular context. An object may play different roles in different contexts.For example, a student in a university can be either an undergraduate studentor a graduate student at any point in time – and is likely to need to change fromone of these roles to another. Similarly, a student can also be registered in his orher program full-time or part-time, as shown in Figure 5.16; in this case, astudent may change roles several times. Finally, an animal may play several ofthe roles shown in Figure 5.15, although in this case the roles are unlikely tochange.ProblemHow do you best model players and roles so that a player can change roles orpossess multiple roles?ForcesIt is desirable to improve encapsulation by capturing the information associatedwith each separate role in a class. However, as discussed in Chapter 5, you wantto avoid multiple inheritance. Also, you cannot allow an instance to changeclass.SolutionCreate a «Player» class to represent the object that plays different roles. Createan association from this class to an abstract «Role» class, which is the superclass of a set of possible roles. The subclasses of this «Role» class encapsulate all thefeatures associated with the different roles.If the «Player» can only play one role at a time, the multiplicity between«Player» and «Role» can be one-to-one, otherwise it will be one-to-many.Instead of being an abstract class, the «Role» can be an interface. The onlydrawback to this variation is that the «Role» usually contains a mechanism,inherited by all its subclasses, allowing them to access information about the«Player». Therefore you should only make «Role» an interface if this mechanismis not needed.ExamplesFigure 6.6 shows how an 
Animal  or a Student  can take on several roles to solve theproblems posed by Figures 5.14 and 5.15.The example in the middle of Figure 6.6 shows that an object can have avarying number of roles. An animal could be aquatic, land-based or both. Notethat we could also have used a role class to record whether an animal is acarnivore, herbivore or omnivore; however, since this information remains thesame for the life of an animal, we can just use ordinary subclasses.The bottom example in Figure 6.6 shows that you can have two separate«Role» superclasses. In this case, a student is characterized by his or herattendance status (full-time or part-time) and by whether he or she is a graduateor undergraduate. Both of these types of status can change during the life of a
Student  object. The Player–Role pattern with two one-to-one associations makesit possible to create a full-time undergraduate student, a part-time graduatestudent or any other combination.The Player–Role pattern is also used in the airline system to allow a person tobe both a passenger and an employee. This is illustrated in Figure 5.31. Lethbridge.book  Page 229  Tuesday, November 16, 2004  12:22 PM<page> 230Chapter 6
Using design patterns 
AntipatternsOne way to implement roles is simply to merge all the features into a single«Player» class and not have «Role» classes at all. This, however, creates an overlycomplex class – and much of the power of object orientation is lost.Y ou could also create roles as subclasses of the «Player» class. But, as we havealready discussed, this is a bad idea if it results in the need for multipleinheritance or requires an instance to change class.RelatedpatternsThe Abstraction–Occurrence pattern has a similar structure to the Player–Rolepattern: the player has many roles associated with it, just like the abstraction hasmany occurrences. However, the semantics of the two patterns is quite different.A key distinction is that in the Abstraction–Occurrence pattern, an abstractionis, as the name says, abstract, while its occurrences tend to be real-world thingssuch as copies of books. The inverse is true in the Player–Role pattern: the playeris normally a real-world entity (e.g. a person) while its roles are abstractions.ReferencesThis pattern appears in the OMT book by Rumbaugh et al. (1991), referred to inthe ‘For more information’ section of Chapter 5. At the time that book waswritten, however, the term ‘pattern’ had not yet taken on its current use.Figure 6.6Template and examples of the Player–Role design pattern«Player» «AbstractRole»
«Role1» «Role2»
attendance levelStudent
GraduateStudent UndergraduateStudent PartTimeStudent FullTimeStudentLevelRole AttendanceRoletypeOfFood
Carnivore OmnivoreAnimal
Herbivorehabitat0..2HabitatRole
AquaticAnimal LandAnimal1
11 11 Lethbridge.book  Page 230  Tuesday, November 16, 2004  12:22 PM<page> 232Chapter 6
Using design patterns 
ExerciseE118
Discuss how the Singleton pattern could be generalized to the case where aclass could be limited to have a maximum of N instances.
6.6 The Observer pattern
ContextWhen you create a two-way association between two classes, the code for theclasses becomes inseparable. When you compile one, the other one has to beavailable since the first one explicitly refers to it. This means that if you want toreuse one of the classes, you also have to reuse the other; similarly, if you changeone, you probably have to change the other.ProblemHow do you reduce the interconnection between classes, especially betweenclasses that belong to different modules or subsystems? In other words, how doyou ensure that an object can communicate with other objects without knowingwhich class they belong to?ForcesY ou want to maximize the flexibility of the system to the greatest extent possible.SolutionCreate an abstract class we will call the «Observable» that maintains a collection of «Observer» instances. The «Observable» class is very simple; it merely has amechanism to add and remove observers, as well as a method 
notifyObservers
that sends an update  message to each «Observer». Any application class candeclare itself to be a subclass of the «Observable» class. This is illustrated inFigure 6.8.«Observer» is an interface, defining only an abstract 
update  method. Any class can thus be made to observe an «Observable» by declaring that it implementsthe interface, and by asking to be a member of the observer list of the«Observable». The «Observer» can then expect a call to its 
update  method whenever the «Observable» changes.Figure 6.7Template and example of the Singleton design patternif (theCompany==null)  theCompany= new Company();return theCompany;«Singleton»
theIns tance
getInstance()
Company
theCom panyCompany() «private»
getInstance() Lethbridge.book  Page 232  Tuesday, November 16, 2004  12:22 PM<page> 234Chapter 6
Using design patterns 
ExercisesE119
Look at the Java documentation and explain the similarities or differencesbetween the mechanism behind the 
ActionEvent  and ActionListener  classes and the Observer pattern.
E120 Use the Observer pattern to model a small system where several differentc l a s s e s  w o u l d  b e  n o t i f i e d  e a c h  t i m e  a n  i t e m  i s  a d d e d  o r  r e m o v e d  f r o m  a ninventory.
6.7 The Delegation pattern
ContextY ou need an operation in a class and you realize that another class already hasan implementation of the operation. However, it is not appropriate to make yourclass a subclass and inherit this operation, either because the isa rule does notapply, or because you do not want to reuse all the methods of the other class.ProblemHow can you most effectively make use of a method that already exists in theother class?ForcesY ou want to minimize development cost and complexity by reusing methods.Y ou want to reduce the linkages between classes. Y ou want to ensure that workis done in the most appropriate class.SolutionCreate a method in the «Delegator» class that does only one thing: it calls amethod in a neighboring «Delegate» class, thus allowing reuse of the method forwhich the «Delegate» has responsibility. By ‘neighboring’ , we mean that the«Delegate» is connected to the «Delegator» by an association. This is illustratedin Figure 6.9.Normally, in order to use delegation an association should already exist betweenthe «Delegator» and the «Delegate». This association may be bidirectional or elseunidirectional from «Delegator» to «Delegate». However, it may sometimes beappropriate to create a new association just so that you can use delegation –provided this does not increase the overall complexity of the system.Delegation can be seen as providing selective inheritance.ExamplesAs shown in Figure 6.9, a 
Stack  class can be easily created from an existingcollection class such as 
LinkedList . The push method of Stack  would simply call the 
addFirst  method of LinkedList , the pop method would call the removeFirst
method and the isEmpty  method would delegate to the method of the samename. The other methods of the 
LinkedList  class would not be used since theydo not make sense in a 
Stack .The bottom example in Figure 6.9 shows two levels of delegation in the airlinesystem. 
Booking  has a flightNumber  method that does nothing other than delegate to the method of the same name in its neighbor, 
SpecificFlight . This in turn delegates to 
RegularFlight . Lethbridge.book  Page 234  Tuesday, November 16, 2004  12:22 PM<page> 236Chapter 6
Using design patterns 
F i n a l l y ,  y o u  w a n t  t o  e n s u r e  t h a t  i n  d e l e g a t i o n  a  m e t h o d  o n l y  a c c e s s e sneighboring classes. For example it would not be good for 
Booking ’s flightNumber
method to be written as:
return specificFlight.regularFlight.flightNumber();
This is bad because the further a method has to reach to get its data, the moresensitive it becomes to changes in the system. Maintenance becomes easier ifyou know that a change to a class will only affect its neighbors.RelatedpatternsThe Adapter and Proxy patterns, discussed below, both use delegation.ReferencesThe Delegation pattern is mentioned in the book by Grand (see ‘For moreinformation’ at the end of the chapter).
ExerciseE121
Find as many situations as you can where the Delegation pattern should beapplied in Figure 5.25(c). 
6.8 The Adapter pattern
ContextY ou are building an inheritance hierarchy and you want to incorporate into it aclass written by somebody else – that is, you want to reuse an existing unrelatedclass. Typically the methods of the reused class do not have the same name orargument types as the methods in the hierarchy you are creating. The reusedclass is also often already part of its own inheritance hierarchy.The Law of Demeter
A fundamental principle of the Delegation pattern is that a method should only communicate withobjects that are neighbors in the class diagram.  This is a special case of the ‘Law of Demeter’, whichwas formulated by a team from Northeastern University in Boston.The Law of Demeter says, in short, ‘only talk to your immediate friends’. In softwaredesign, this means that a method should only access data passed as arguments, linked viaassociations, or obtained via calls to operations on other neighboring data.  The rationale isthat this limits the impact of changes, and makes it easier for software designers tounderstand that impact. If each method only communicates with its neighbors, then it shouldonly be impacted when those neighbors change, not when changes occur in more distantparts of the system.The Law of Demeter was named after Demeter, the ancient Greek goddess of agriculture,because its developers were interested in ‘growing’ software incrementally.  Adhering to theLaw of Demeter should make incremental development much easier. Lethbridge.book  Page 236  Tuesday, November 16, 2004  12:22 PM<page> Section 6.8237The Adapter pattern
ProblemHow do you obtain the power of polymorphism when reusing a class whosemethods have the same function but do not have the same signature as the othermethods in the hierarchy?ForcesY ou do not have access to multiple inheritance or you do not want to use it.SolutionRather than directly incorporating the reused class into your inheritancehierarchy, instead incorporate an «Adapter» class, as shown in Figure 6.10. The«Adapter» is connected by an association to the reused class, which we will callthe «Adaptee». The polymorphic methods of the «Adapter» delegate to methods of the «Adaptee». The delegate method in the «Adaptee» may or may not havethe same name as the delegating polymorphic method.
Other code that accesses facilities of an «Adapter» object will be unaware thatit is indirectly using the facilities of an instance of the «Adaptee».Instead of being part of an inheritance hierarchy, an «Adapter» can be one ofseveral classes that implement an interface.ExampleAs shown in Figure 6.10, imagine you are creating a hierarchy of three-dimensional shapes. However, you want to reuse the implementation of anequivalent class called 
TimsTorus . Y ou do not want to modify the code of
TimsTorus , since it is also being used by others; therefore you cannot make
TimsTorus  a subclass of Shape3D . Y ou therefore make Torus  an «Adapter». Its instances have a link to an instance of 
TimsTorus , and delegate all operations to
TimsTorus .Adapters are sometimes called wrappers. The Java wrapper classes 
Integer ,
Float , Double  etc. are adapters for the Java primitive types.A variation of the Adapter design pattern is used in an extended version of theOCSF framework, as explained in Section 6.14.Figure 6.10Template and example of the Adapter design pattern«Adaptee»
adaptedMethod«Superclass»
polymorphicMethod()
TimsTorus
calcVolume()Shape3D
volume()
Sphere Torusvolume()return  adaptee.calcVolume(); { }polymorphicMethod()return  adaptee.adaptedMethod(); { }«Adapter»11
11 Lethbridge.book  Page 237  Tuesday, November 16, 2004  12:22 PM<page> 240Chapter 6
Using design patterns 
return a new Circle  if the changeScale(x,y)  would result in the semi-major axisequaling the semi-minor axis.RelatedpatternsThe Read-Only Interface pattern, described next, provides the same capabilityas Immutable, except that certain privileged classes are allowed to make changesto instances.ReferencesThis pattern was introduced by Grand (see ‘For more information’ at the end ofthe chapter).
ExerciseE124
Imagine that all the classes in Figure 2.8 were immutable. What other methodsmight be added to the system that would return instances of a different class from the class in which they are written? 
6.11 The Read-Only Interface pattern
ContextThis is closely related to the Immutable pattern. Y ou sometimes want certainprivileged classes to be able to modify attributes of objects that are otherwiseimmutable.ProblemHow do you create a situation where some classes see a class as read-only (i.e.the class is immutable) whereas others are able to make modifications?ForcesProgramming languages such as Java allow you to control access by using the
public , protected  and private  keywords. However, making access public makes itpublic for both reading and writing.SolutionCreate a «Mutable» class as you would create any other class. Y ou pass instancesof this class to methods that need to make changes. Then create a public interface we will call the « ReadOnlyInterface», that has only the read-only operations of «Mutable» – that is, only operations that get its values. Y ou pass instances of the «ReadOnlyInterface» to methods that do notneed to make changes, thus safeguarding these objects from unexpectedchanges. The «Mutable» class implements the «ReadOnlyInterface».This solution is shown in Figure 6.12.ExampleFigure 6.12 shows a 
Person  interface that can be used by various parts of thesystem that have no right to actually modify the data. The 
MutablePerson  class exists in a package that protects it from unauthorized modification.The Read-Only Interface design pattern can also be used to send data toobjects in a graphical user interface. The read-only interface ensures that nounauthorized modifications will be made to this data. We present this usage inthe description of the MVC architecture in Chapter 9. Lethbridge.book  Page 240  Tuesday, November 16, 2004  12:22 PM<page> Section 6.13243The Factory pattern
of obtaining the real «HeavyWeight» object. The proxy only needs to obtain the«HeavyWeight» once; subsequently it is available in memory and access istherefore fast.Some proxies may have implementations of a limited number of operationsthat can be performed without the effort of loading the «HeavyWeight».In some systems, most of the variables manipulated by the domain modelactually contain instances of «Proxy» classes.ExamplesIn Figure 6.13, a software designer may declare that a variable is to contain a
List. This variable would, however, actually contain a ListProxy , since it would be expensive to load an entire list of objects into memory, and the list might notactually be needed. However, as soon as an operation accesses the list, the
ListProxy  might at that point create an instance of PersistentList  in memory. On the other hand, the 
ListProxy  might be able to answer certain queries, such as thenumber of elements in the list, without going to the effort of loading the
PersistentList .Now, imagine that the 
PersistentList  was actually a list of students. Theseobjects might also be proxies – in this case, instances of 
StudentProxy . Again, instances of 
PersistentStudent  would only be loaded when necessary.The Proxy pattern is widely used in many software architectures. We willdiscuss it again in the context of the Broker architectural pattern in Chapter 9.AntipatternsInstead of using proxy objects, beginner designers often scatter complex codearound their application to load objects from databases.A strategy that only works for very small systems is to load the whole databaseinto memory when the program starts.RelatedpatternsThe Proxy pattern is one of several patterns that obtain their power fromdelegating responsibilities to other classes, hence it uses the Delegation pattern.ReferencesThe Proxy pattern is one of the ‘Gang of Four’ patterns.
ExerciseE126
Discuss the advantages of using an image-proxy when manipulating the photosin a digital photo album application. What operations could conceivably beperformed by the proxy without loading the heavyweight image into memory?
6.13 The Factory pattern
ContextY ou have a reusable framework that needs to create objects as part of its work.However, the class of the created objects will depend on the application.ProblemHow do you enable a programmer to add a new application-specific class«ApplSpecificClass» into a system built on such a framework? And how do you Lethbridge.book  Page 243  Tuesday, November 16, 2004  12:22 PM<page> Section 6.13245The Factory pattern
ExercisesE127
In a given game, carnivore and herbivore animals are created at randominstants by the game engine. Depending on the country selected by the user, afactory for the appropriate carnivores and herbivores is loaded (e.g. one thatwill create lions and gazelles in Kenya, but cougars and beavers in Canada).Draw the class diagram to represent this idea.
E128 Find the design pattern that would be most appropriate for the followingproblems:(a) Y ou are building an inheritance hierarchy of products that your companysells; however, you want to reuse several classes from one of your suppliers.Y ou cannot modify your suppliers’ classes. How do you ensure that thefacilities of the suppliers’ classes can still be used polymorphically?(b) Y ou want to allow operations on instances of 
RegularPolygon  that will distort them such that they are no longer regular polygons. How do you allow theoperations without raising exceptions?(c) Y our program manipulates images that take a lot of space in memory. Howcan you design your program so that images are only in memory whenneeded, and otherwise can only be found in files?(d) Y ou have created a subsystem with 25 classes. Y ou know that most othersubsystems will only access about 5 methods in this subsystem; how canyou simplify the view that the other subsystems have of your subsystem?(e) Y ou are developing a stock quote framework. Some applications using thisframework will want stock quotes to be displayed on a screen when theybecome available; other applications will want new quotes to trigger certainfinancial calculations; yet other applications might want both of the above,plus having quotes transmitted wirelessly to a network of pagers. How can you design the framework so that various different pieces of applicationcode can react in their own way to the arrival of new quotes?
E129 The Iterator  interface, as defined in Java, is an implementation of what is calledthe ‘Iterator’ design pattern. Study the Java documentation describing 
Iterator , then using the format discussed in this chapter, write a description of theIterator pattern, with sections that define its context, problem, forces andsolution.
E130 (Advanced) In order to improve the access to information stored in a database,several applications use the concept of a cache. The basic principle is to keep inlocal memory objects that would normally be destroyed, because it is expectedthat these objects will be requested again later on. In this way, when they areindeed required again, access to them is very fast. Lethbridge.book  Page 245  Tuesday, November 16, 2004  12:22 PM<page> Section 6.14247Enhancing OCSF to employ additional design patterns
createConnection  method in this interface. Y our factory class will in turn createinstances of your own subclass of 
ConnectionToClient . The second key is the method
setConnectionFactory  found in AbstractServer . Y our server class calls this to ensurethat whenever a new client attempts to connect, your factory will be directed toinstantiate your subclass of 
ConnectionToClient to handle the connection.To use the OCSF factory mechanism, you therefore need to do the following:1.Create your subclass of 
ConnectionToClient . Its constructor must have the samesignature as 
ConnectionToClient , and it must call the constructor of
ConnnectionToClient  using the super  keyword. Y our class will also normally wantto override 
handleMessageFromClient ; if this method returns true, the version of
handleMessageFromClient  in your server class will also be subsequently called. 2.Create your factory class that simply defines a method for the 
createConnection
operation of the AbstractConnectionFactory  interface. Typically, the methodwould look like this:
protected ConnectionToClient createConnection(   ThreadGroup group, Socket clientSocket,   AbstractServer server) throws IOException {        return new Connection(group,clientSocket,server);}
3.Arrange for the server make the following call before it starts listening:
setConnectionFactory(new MyConnectionFactory());
Observable layer
A second extension to the OCSF framework is the addition of an Observablelayer. We will describe the client side, but the server side works the same way.In the basic 
OCSF, a message received by a client is processed by the subclass of
AbstractClient  that implements the handleMessageFromServer  abstract method. Each time a new application is developed, therefore, the 
AbstractClient  class must be subclassed.The Observer pattern provides an alternative mechanism for developing aclient. Any number of «Observer» classes can ask to be notified when something‘interesting’ happens to the client – the arrival of a message or the closing of aconnection, for example. We would therefore like to have a subclass of
AbstractClient  that is an «Observable». Unfortunately, since Java does notpermit multiple inheritance, we cannot make it a subclass of the 
Observable  class itself. Instead, we use the Adapter pattern, as shown in Figure 6.15.The extended OCSF has the class 
ObservableClient . This has exactly the same interface as 
AbstractClient , except that it is a subclass of Observable . It is also an adapter: it delegates methods such as 
sendToServer , setPort , etc. to instances of a concrete subclass of 
AbstractClient  called AdaptableClient . Designers using
ObservableClient  never need to know that AdaptableClient  exists. Lethbridge.book  Page 247  Tuesday, November 16, 2004  12:22 PM<page> Section 7.3261The basics of user interface design
contribute. Various other aspects of usability contribute to it, as does the graphicdesign.
Basic terminology of user interface design
User interface designers use specific terms that you should understand:DialogThe word dialog (also sometimes spelled dialogue) is used generically to describe the back-and-forth interaction between user and computer. The termsdialog or dialog box are used to mean a specific window with which a user caninteract, other than the main UI window. Control orwidgetThese words are used interchangeably to describe specific components of auser interface. Typical widgets include menus, lists, input fields and scrollbars.AffordanceThe affordance is the set of operations that the user can do at any given point intime. Examples of operations include typing into an input field, clicking on abutton or selecting an item from a menu. Clicking a button or selecting a menuitem are commands because they cause the system to perform somecomputations. UI designers say ‘a button affords clicking’ if clicking on it wouldcause some action to occur.StateAt any stage in the dialog, the system is displaying certain information in certainwidgets, and has a certain affordance. Taken together, these are the system’s user interface state. The UI state usually changes when the user issues a command. Italso changes when the system itself notifies the user of some happening, such asthe completion of an earlier command or the arrival of a message.ModeA mode is a situation in which the UI restricts what the user can do – that is, itrestricts the affordance. For example, if a dialog appears saying ‘Do you reallywant to delete a file?’ and all the user can do is click ‘Cancel’ or ‘OK’ , then thesystem is in a mode.Modal dialogA modal dialog is one in which the system is in a very restrictive mode. The usercannot interact with any other window until he or she has dismissed the modaldialog. The most restrictive type of modal dialog has a single ‘OK’ button todismiss the dialog. A non-modal dialog is a separate window with which the usercan choose to interact, but is not forced to. Palettes and toolbars are examples ofnon-modal dialogs.FeedbackWhenever the user does something, the response from the system is calledfeedback. Feedback includes displaying a message, changing a color ordisplaying a dialog.EncodingtechniquesThese are ways of representing information so as to communicate it to the user.Tables 7.1 and 7.2 list some of the most common encoding techniques, alongwith their advantages and disadvantages.     Lethbridge.book  Page 261  Tuesday, November 16, 2004  12:22 PM<page> 262Chapter 7
Focusing on users and their tasks 
7.4 Usability principles
In this section, we discuss twelve principles that you should apply whendesigning and evaluating a user interface. After we list the principles, we willgive an example of a user interface that violates many of these principles, as wellas an improved version of the same system.
The twelve principles
Usability Principle 1: Do not rely only on usability guidelines – always test with usersEach situation is different and there are exceptions to the principles in thissection. Y ou should therefore ask the opinions of users and evaluate how theyuse prototypes. Evaluation is the topic of Section 7.5.Usability Principle 2: Base UI designs on users’ tasks as expressed in use casesPerform a first iteration of use case analysis and then design the UI based on this. As you evaluate your prototype UI, you will have to go back and revise youruse case model as well as your UI. Usability Principle 3: Ensure the sequences of actions to complete a task correctly are as simple aspossibleMake sure users can move from step to step easily as they perform their tasks.Y ou want the user to have to read the smallest amount of text, to navigate theleast, to type the least and not to be led into making errors. In particular, makesure the user does not have to select menu items repeatedly to complete asingle task. Also, avoid sequences of modal dialogs, since they slow usersT able 7.1Ways of encoding information to be transmitted using sound. Unless backed up by visual cues, these are inaccessible to deaf peopleMedium Uses and advantages ProblemsSpoken wordsEssential when there is no screen or only a small screen (e.g. a telephone system). Important for blind people who otherwise must rely on tools that convert text into BrailleCan be overheard, violating privacy. Sequential, therefore the user has to request replay if he or she misses a part. Slower for most users than reading text MusicCan convey mood. Can add attractivenessDoes not usually convey meaning. People have different tastes in music Abstract sounds (e.g. beeps) Can give useful feedback about actions that are taking placeCan be hard to interpret All of the aboveAttract attention rapidly at onset, even if the person is not looking at the screenCan be distracting and annoying Lethbridge.book  Page 262  Tuesday, November 16, 2004  12:22 PM<page> Section 7.4263Usability principles
T able 7.2Ways of encoding information to be transmitted visually. Except for text, which can be spoken or converted to Braille, these are generally inaccessible to blind peopleMediumUses and advantagesProblems
Text written in a language the user can readHas unlimited ability to express meaning. Simple to generate and display. Accessible by blind people using Braille translatorsTakes a lot of space. Writing clearly and unambiguously is hard. Not usable by young children or the illiterate. Hard for users to scan quickly Fonts (including font family, as well as bold, italics and size attributes)Add emphasis to text, and reinforce its structure, thus simplifying and highlighting informationUsing too many fonts results in confusion and a cluttered appearance. Decorative or unusual fonts can be distracting Icons (simple and abstract graphics, each representing a specific action or object)Allow many commands or objects to be listed in less space than is possible with text. Users can scan the screen to find an icon faster than they can scan to find particular textNotoriously difficult for users to interpret or distinguish. Require artistic skill to createDiagrams (convey objects and their relationships)Can communicate or summarize complex concepts or mechanisms more easily than other techniquesCan be hard for users to interact with or interpret. Can be expensive to generate automatically Photographs and hand-drawn images of realityCan help users better appreciate realityCan take a lot of space on screen and can slow response time due to downloading Animations and videoProvide high impact communication of complex information. Entertaining and hence attractive for usersBandwidth-intensive, hence reduce response time. Sequential, requiring replay if users miss parts. Users cannot quickly scan them. Expensive to produce. May be annoying Purely decorative graphicsMake the interface attractive and helps to emphasize its organizationCan be distracting or annoying ColorsDraw attention to specific items. Convey organization (items colored similarly are related). Makes the UI more attractive. Users can almost instantly notice a small spot of color on the screenUsers cannot distinguish among large numbers of colors. Some color combinations clash. Color-blind people cannot see differences in hue. Some colors (e.g. bright red) can be distracting if overused Grouping, bordering and organizing in columns or tablesHelp to convey the organization of information and reduce its perceived complexityNo problemsFlashingRapidly draws attention to items Distracting and annoying. Fast flashing can cause epileptic seizures and migraine headaches Lethbridge.book  Page 263  Tuesday, November 16, 2004  12:22 PM<page> Section 7.4265Usability principles
2.The message should state which file (including which directory) could not bewritten.3.The message should tell the user the reason or reasons why it could not writethe file. These might include: the existing file is write-protected (for everybodyor for specific users), the directory is write-protected, the file system isinaccessible (if it is on a network), the file is locked by another program, thereis not enough space to write the file, or the disk appears to be damaged.4.The message should give the user as much information as possible to help himor her to solve the problem. Such information might include: a) the name andlogin ID of user who has permission to write to the file or directory, b) thename and process ID of the program that is locking the file, and c) how muchspace must be freed before there is enough space to write the file. 
Usability Principle 6: Ensure that the user can always get out, go back or undo an actionUsers will always make mistakes; they will issue incorrect commands ornavigate to somewhere they had not intended to go. Therefore you must ensure,where possible, that the user can back out of any action.In particular, make sure that users can easily undo any operation, even if it hasresulted in changes to data. Also make sure that they can easily exit any dialogbox and cancel any operation in progress. Providing both these facilities helpsusers to recover from mistakes, and ensures that they are not afraid ofexperimenting with the system.Occasionally it is not possible to undo an action – for example, formatting adisk. If such an action may have serious consequences, you should warn usersbefore they perform the action, and ask them to confirm that they really want todo it.Usability Principle 7: Ensure that response time is adequateResponse time is the time that elapses from when a user issues a command (byselecting a menu item, clicking on an icon etc.) to when the system providessufficient results that the user can continue his or her work. Response time canbe a problem when processing large volumes of information or transmittingdata over a network.Users’ perceptions of what is acceptable are determined largely by otherapplications they use. If your application runs more slowly than users areaccustomed to, then users will have a sense that the system is wasting their time.Operations such as the popping up of menus and echoing of input shouldappear instantaneous to users. Most other operations should take a second orless, so that the user’s train of thought is not interrupted. A few operations maybe allowed to take up to about 10 seconds if the user understands that they arenaturally time-consuming. An example is loading a complex web page over a Lethbridge.book  Page 265  Tuesday, November 16, 2004  12:22 PM<page> 268Chapter 7
Focusing on users and their tasks 
T able 7.3Some types of information that can differ among locales
Locale-dependent feature Issues the UI designer needs to be aware of Language Different languages use different amounts of space, different character sets, different fonts, and run in different directions. Employ a skilled technical translator and ensure he or she runs the system in both languages to verify it Character set and fonts Unicode can handle most world character sets, but you also have to ensure that appropriate fonts are available Direction for reading text Text in some languages runs left to right or top to bottom. Laying out screens so that they can automatically accommodate this is a challenge Collating sequences (sort order of words) Some languages order characters with accents or diacritics at the end of an alphabet, whereas others order them as if the accent or diacritic were absent. Often, the sort order for names in phone books is special The order and components of peoples’ names. Family name comes first in some cultures, last in some, and is non-existent in others. In some cultures, a person’s legal name differs from their commonly used name. Salutations such as Mr and Dr vary widely Currency and format for displaying currencies An application may use more than one currency at once. The number of decimal places and the magnitude of values may differ widely. The language somebody uses may not correspond to the currency they use Time zones Time-zone abbreviations are not used consistently. Daylight savings time starts and ends on different dates in different places, or may not exist at all Format for dates, times and numbers There are many ways of writing dates, times and numbers. Even though the international standard is YYYY/MM/DD, this is often not followed Calendars and holidays Although international business is based on the Gregorian calendar, the calendars of particular cultures and religions are also used in some places Formats for phone numbers, addresses, postal codes, credit card numbers, etc. Y ou should almost never require a specific format for these items since they differ so widely and can change at any time. Allow free-form input of whatever the user wants to type. A common error is not to allow sufficient characters, or not to allow extensions to be recorded for telephone numbers Laws and business practices Y ou have to accommodate different ways of calculating taxes, performing accounting, or keeping records. Patents and other regulations might place restrictions on designs Icons and metaphors Icons and other encoding techniques can invoke different impressions in people of different cultures Lethbridge.book  Page 268  Tuesday, November 16, 2004  12:22 PM<page> Section 7.6277Implementing a simple GUI in Java
1.Component . These are the basic building blocks of any graphical interface.Important subclasses are 
Button , TextField , TextArea , List, Label , and ScrollBar . 2.
Container . The role of these is to contain the components that constitute theGUI; the main subclasses are 
Frame , Dialog  and Panel . In Java, a Frame  is an independent window, with a title and border. A 
Dialog  is also a window, but is owned by another window. A 
Panel  is designed to be included in another
Container , even another Panel . It therefore also acts as a Component . Panel s are used to compose complex GUIs.3.
LayoutManager . These are classes that define the way Component s are laid out in a
Container . The simplest layout manager is the GridLayout  that divides a Container
into a grid where all Component s occupy equal-sized rectangles. Another usefullayout manager is the 
BorderLayout . This time, the Container  is divided into five areas, designated as Center, North, South, East and West. When a 
Container
with a BorderLayout  is resized, the West and East regions grow vertically only,while the North and South regions grow horizontally only. The Center areagrows in both directions.As an illustration, let us examine how a graphical interface for the SimpleChatprogram (Phase 1) can be built. The resulting GUI is shown in Figure 7.4.
The first step consists of creating the main window by defining a subclass of
Frame . All the widgets that compose the window will be attributes of this class.
public class ClientGUI extends Frame implements ChatIF{  private Button closeB =     new Button("Close");  private Button openB =      new Button("Open");  private Button sendB =      new Button("Send");  private Button quitB =      new Button("Quit");  private TextField portTxF = new TextField("12345");  private TextField hostTxF = new TextField("localhost");Figure 7.4Simple graphical user interface (GUI) for Phase 1 of SimpleChat
 Lethbridge.book  Page 277  Tuesday, November 16, 2004  12:22 PM<page> 278Chapter 7
Focusing on users and their tasks 
  private TextField message = new TextField();  private Label portLB =      new Label("Port: ", Label.RIGHT);  private Label hostLB =      new Label("Host: ", Label.RIGHT);  private Label messageLB =   new Label("Message: ", Label.RIGHT);  private List messageList =  new List();
Note that this class also implements the ChatIF  interface, as required by the
ChatClient  class.In order to add a title to the 
Frame , to define its size and to make it visible, theconstructor contains the following lines:
public ClientGUI(String host, int port){   super("Simple Chat");  setSize(300,400);  setVisible(true);
The window is composed of a List, which is meant to display all the receivedmessages, as well as a series of other widgets located at the bottom of thewindow. These are laid out using a 
BorderLayout , with the List at the Center and the remaining widgets in the South region. However, since only one 
Component
can be placed in the South region, a Panel  called bottom  is created to contain all the widgets. The following lines, also in the constructor, accomplish this:
  setLayout(new BorderLayout(5,5));  Panel bottom = new Panel();  add("Center", messageList);  add("South", bottom);
The bottom panel uses a GridLayout  of 5 lines and 2 columns to lay out its
Component s, as follows:
  bottom.setLayout(new GridLayout(5,2,5,5))  bottom.add(hostLB);  bottom.add(hostTxF);  bottom.add(portLB);  bottom.add(portTxF);  bottom.add(messageLB);  bottom.add(message);  bottom.add(openB);  bottom.add(sendB);  bottom.add(closeB);  bottom.add(quitB);  ...}
When a message is received, the ChatClient  instance calls the display  method of the associated 
ChatIF . The message thus received by the ClientGUI  is displayed in the 
List widget as follows: Lethbridge.book  Page 278  Tuesday, November 16, 2004  12:22 PM<page> Section 7.6279Implementing a simple GUI in Java
public void display(String message){  messageList.add(message);  messageList.makeVisible(messageList.getItemCount()-1);}
When a user wants to send a message, he or she has to type the message into the
TextField  named message  and then push the ‘Send’ button. The send method that actually sends the message is written as follows:
public void send(){  try   {    client.sendToServer(message.getText());  }  catch (Exception ex)  {    messageList.add(ex.toString());    messageList.makeVisible(messageList.getItemCount()-1);    messageList.setBackground(Color.yellow);  }}
We must arrange for the above method to be called whenever the user pushesthe ‘Send’ button. This can be achieved by creating what Java calls an
ActionListener . ActionListener  is in fact an interface with only one abstractoperation called 
actionPerformed . This operation will be called each time a userpushes the associated button. To associate a 
Button  with an ActionListener  you must proceed as follows (these lines are normally located in the constructor ofthe 
Frame ):
sendB.addActionListener(new ActionListener(){  public void actionPerformed(ActionEvent e)  {    send();  }});
These lines introduce a feature of Java called an anonymous class – refer to a Javamanual for more details on this technique. The basic idea is that we are creatinga class which implements the 
ActionListener  interface without explicitly namingthe new class. We merely give a definition to the abstract method
actionPerformed , defined in that interface. The sendB button is now associated with an 
ActionListener  that has an actionPerformed  method. That method in turn calls the 
send method described earlier. The net effect of this is that when youpush the ‘Send’ button, the 
send method is automatically called. Lethbridge.book  Page 279  Tuesday, November 16, 2004  12:22 PM<page> Section 7.9283For more information
(d) Now, using AWT or a GUI building tool, develop Java code to implementyour interface, replacing the 
ConsoleChat  class.(e) Evaluate your user interface by arranging for several members of someother group to use it. Take note of any problems they encounter, and updateyour interface to reduce the problems.
E149 On the book’s web site, you will find a class called DrawPad . Associated with this there is a class called 
StartDraw  that allows you to create an instance of DrawPad
and draw some simple lines and curves using the mouse. Without changing
DrawPad  at all, add a feature to SimpleChat that will allow you to communicatewith other users of SimpleChat by drawing pictures. This would work byhaving two clients simply open 
DrawPad s and start drawing. The drawing actionsshould be transmitted as commands via the server. The result of your work willbe Phase 6 of SimpleChat.
E150 The SimpleChat system is not internationalized. Its most severe problem is thatall the displayed messages are hard-coded in English. Design and implement aninternationalized version of SimpleChat that obtains all the displayed messagesfrom a message file. Arrange for the system to determine the locale from theoperating system, and then select an appropriate message file. Hint: you cannumber each message (but do not display numbers to end-users). Y ou will needto develop a way to embed parameters in messages.
E151 Develop a prototype user interface for the Small Hotel Reservation System, asfollows. If possible, involve users from the hotel industry.(a) Do some parallel design of paper prototypes. Then pick the best features ofeach paper prototype to create a final version.(b) Review your prototype, following the guidelines discussed in this chapter.Change it as necessary.(c) Use a rapid prototyping tool to create a partially functional prototype basedon your paper prototype. This prototype will not actually manipulate anydata and it will not, therefore, make use of the object model you havedeveloped.(d) Have people use your prototype. Observe the difficulties they have. Changethe prototype as necessary. Lethbridge.book  Page 283  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 284  Tuesday, November 16, 2004  12:22 PM<page> 290Chapter 8
Modeling interactions and behavior 
(b) To obtain the cousins of an individual, you must determine his or her twoparents. Y ou then obtain the siblings of these parents. For each of thesesiblings, you obtain their children (refer to Figure 5.25(c)).(c) A client wishes to open a new account at a bank branch. To do so, hisinstance of class 
Client  must first be retrieved from the central bank server.For a new client, an instance of 
Client  m u s t  b e  c r e a t e d .  A n  i n s t a n c e  o f
BankAccount  is then created using the Client  object. A deposit must thenimmediately follow, to complete the account creation process. 
Communication diagrams
A communication diagram shows several objects working together. It appears asa graph with a set of objects and actors as the vertices.A communication diagram is very much like an object diagram except that,a s  w e  w i l l  d i s c u s s  b e l o w ,  i t  s h o w s  communication links instead of links of associations. It also has much in common with a sequence diagram, except thatlifelines, activation boxes and combined fragments are absent. Instead, you drawa communication link between each pair of objects involved in the sending of amessage; the messages themselves are attached to this link.Y ou represent a message using an arrow, labeled with the message name andoptional arguments. Y ou specify the order in which messages are sent byprefixing each message using some numbering scheme.Figures 8.8 and 8.9 show examples of communication diagrams describingthe same interactions as the sequence diagrams of Figures 8.1 and 8.4.  
Communication links can exist between two objects whenever it is possiblefor one object to send a message to the other one. Several situations can makethis possible:Figure 8.8A communication diagram representing the same interaction as the sequence diagram of Figure 8.1
Figure 8.9A communication diagram corresponding to the sequence diagram of Figure 8.4
:Cour seSection :Registration :Student1: create
3: addToRegistrationList2: addToSchedule
4: create3: hasPrerequisite :=hasPassedCourse(prereq)«parameter» 6: addToRegistrationList«parameter»:Cour seSection :Cour se
:RegistrationaStudent :
Student1: requestToRegister(aStudent)«local»
2: prereq := getPrerequisite
5: addToSchedule«parameter»:GUI Lethbridge.book  Page 290  Tuesday, November 16, 2004  12:22 PM<page> 292Chapter 8
Modeling interactions and behavior 
On the other hand, you may prefer a communication diagram when you arederiving an interaction diagram from a class diagram. This is becausecommunication diagrams are effectively object diagrams with communicationlinks instead of association links. Communication diagrams can in fact be usedto help validate class diagrams – a communication diagram might suggest, forexample, that you should add a new association in order to make the interactionpossible.
Communication diagrams, patterns and collaborations
A communication diagram can be used to represent aspects of a design pattern– such as those discussed in Chapter 6. Figure 8.10(a) shows the two stepsinvolved in the main interaction of the Proxy pattern. First, a client object makesa request to a «Proxy» object. Then, if the «HeavyWeight» is needed and is notalready loaded, the «Proxy» causes it to be loaded, before returning the result tothe client. Compare this to Figure 6.13.
The collaboration between the classes involved in an interaction can berepresented in a class diagram using a dashed ellipse, as shown in Figure 8.10(b).Dashed lines link the ellipse to classes that fulfill the various roles of thecollaboration. Here, for example, 
PersistentStudent  has the role of «HeavyWeight». This notation is particularly convenient for showing the classesfulfilling the roles in a design pattern.
8.2 State diagrams
A state diagram, also known as a state machine diagram, is another way of expressing dynamic information about a system. It is used to describe theexternally visible behavior of a system or of an individual object.At any given point in time, the system or object is said to be in a certain state. It remains in this state until an event occurs that causes it to change state. BeingFigure 8.10Using a communication diagram and a collaboration symbol to represent the Proxy design pattern(a)
(b)1: request2: [information neededand not loaded]loadHeavyWeight
:Hea vyWeight :Proxy :Client
heavyWeight
clientproxy PersistentStudent StudentCourseSection
Proxy Lethbridge.book  Page 292  Tuesday, November 16, 2004  12:22 PM<page> 294Chapter 8
Modeling interactions and behavior 
Elapsed-time transitions
The event that triggers a transition can be a certain amount of elapsed time.Figure 8.12(a) illustrates the use of such elapsed-time transitions to model a simple traffic signal.
There are three main states in Figure 8.12(a), corresponding to the threecolors of the traffic signal at point 1 of Figure 8.13. The initial state has atransition to ‘RedLight’ state to indicate what happens when the system startsup. After startup, the system indefinitely rotates among green, yellow and red,therefore there is no end state.
The red light only stays on for 30 seconds, at which time the green light comeson. The green light stays on for 25 seconds, at which time the system moves tothe ‘Y ellowLight’ state. After five more seconds the yellow light gives way to thered light again. Note that the traffic signal at point 2 of Figure 8.13 would havethe same state diagram, except that when it goes green, the signal at point 1would go red, and vice versa.Figure 8.12(b) extends the above scenario by showing a slightly differentpattern for the signal at point 2. In this case, traffic moving from point 2 to 3always has a green light unless a vehicle arrives at point 1 and triggers a sensor.When the sensor at point 1 is triggered, the system moves to ‘Y ellowLight’ state,but only after the traffic coming from point 2 has had at least 25 seconds of greenlight. An extra state ‘GreenLightChangeTriggered’ is used to model this lattersituation. Without this state and its outgoing transition, a steady series ofFigure 8.12State diagrams of a simple traffic light, illustrating elapsed-time transitions
YellowLightGreenLight
RedLightafter(25s)
after(5s)after(30s)
(a) (b)vehicleWaitingToTurn
after(25s since exitfrom state RedLight)
after(5s)after(30s)
RedLightYellowLightGreenLightChangeTriggeredGreenLightNoTrigger
Figure 8.13Street layout for the traffic signals of Figure 8.12R
Y
G
R
Y
G12
3 Lethbridge.book  Page 294  Tuesday, November 16, 2004  12:22 PM<page> 296Chapter 8
Modeling interactions and behavior 
There is no end state (the target symbol) because we will keep a permanentrecord of the course section, whatever happens. The 
requestToRegister  transitions in Figure 8.14 shows that a transition canlead from a state back to the same state. Also, the 
/createRegistration  notation designates an action; this is discussed in the next subsection.
ExercisesE155
Enhance Figure 8.11 to show the conditions that should be present todetermine when the system should transition to each of the end states (‘X Win’ ,‘O Win’ and ‘Tie’) or to the regular states ‘X Turn’ and ‘O Turn’ .
E156 Given the state diagram in Figure 8.14, in what state would the system be inafter the following sequences of events? Assume that 
minimum  is set to 3 and
maximum  is set to 5.(a)
openRegistration , requestToRegister  (repeated twice), cancel . (b)
openRegistration , requestToRegister  (repeated 8 times in total),
closeRegistration  
E157 Enhance Figure 8.14 to handle the following situations:(a) The course section can be canceled when in any state, except after it hasbeen taught.(b) A student can drop out at any time, except after the course section has beentaught.
E158 Figure 8.12(b) shows the state diagram for a sensor-activated light at point 2 ofFigure 8.13, where the light remains green until the sensor is triggered bytraffic wishing to move from point 1 to point 3. Show the correspondingdiagram for point 1 (where the light remains red until the sensor is triggered).
E159 Draw a state diagram for a four-way intersection (also known as a crossroads).There will be several different signals controlling the different directions offlow. Y ou have to consider which lights are on at any given time. In the basiccase, the signals facing north will look the same as the signals facing south, andthe signals facing east will appear the same as those facing west. Thus thesystem as a whole can have the following states, where NS means north andsouth, and EW means east and west: ‘NSRed-EWGreen’ , ‘NSChanging-EWY ellow’ , ` ‘NSGreen-EWRed’ and ‘NSY ellow-EWChanging’ .
E160 Enhance your answer to the last exercise by considering a set of traffic signalsfor an intersection with turning lanes controlled by separate turning signals.Y ou may want to study a real intersection to understand what states can occur. Lethbridge.book  Page 296  Tuesday, November 16, 2004  12:22 PM<page> 298Chapter 8
Modeling interactions and behavior 
performed when entering or exiting a state, then it is written in the state boxwith the notation 
enter/action  or exit/action .Figure 8.16 illustrates the use of actions in the state diagram for a garage dooropener. Upon entry into each state, a particular action occurs that has an effecton the garage door motor: the motor controller can be told to start the motorrunning forwards (opening the door), to start the motor running in reverse(closing the door), or to stop the motor. For example, whenever the garage doorbecomes completely open, it enters ‘Open’ state; the action taken when thisoccurs is to stop the motor.
Normally the controller cycles around the four states in a clockwise manner,a button being used to initiate opening or closing. When closing the door,however, there is a safety mechanism: if the button is pressed while the door isclosing, the motor is immediately thrown into the forwards direction, causingthe door to start opening again.Figure 8.17 shows another example of the use of actions. This is a partial statediagram of a tape recorder. In this case, there is an exit action that stops therecording process no matter what causes the ‘Recording’ state to be exited. Inaddition, the 
startOfTape  transition has a stop action that occurs during the transition to the ‘Wait’ state.
Figure 8.17 is clearly incomplete, since there is no transition out of ‘Wait’ state.An important part of validating a state diagram is to ensure that each state hasat least one outgoing transition, and at least one incoming transition. Y ou shouldalso make sure that it is possible to get from any state to any other state,otherwise the system can reach what is called ‘livelock’ . We will discuss thisconcept in Chapter 10.Figure 8.16State diagram for a garage door opener, showing actions triggered by entry into a stateopeningCompletedclosingCompletedpressButtonpressButtonpressButton
Closing Open
enter/ stop motorClosedOpening
enter/ run motor in reverseenter/ stop motor enter/ run motor forwards
Figure 8.17Partial state diagram for a tape recorder showing an action on a transition and an action on exiting a stateRecording
exit/stopRewinding
WaitstartOfTape/stop endOfProgramendOfTape Lethbridge.book  Page 298  Tuesday, November 16, 2004  12:22 PM<page> Section 8.2299State diagrams
Nested substates and guard conditions
A state diagram can be nested inside a state. The states of the inner diagram arecalled substates.Figure 8.18 shows a state diagram of an automatic transmission; at the toplevel this has three states: ‘Neutral’ , ‘Reverse’ and a driving state, which is notexplicitly named. The driving state is divided into substates corresponding tothe three gears that the system automatically chooses. The advantage of thenesting is that it shows compactly that the driving substates are all very similarto each other – in particular, that they can all transition to ‘Neutral’ at any time,upon the user’s command. The start symbol inside the driving state shows thatit by default starts at the ‘First’ substate. However, the user can also manuallyselect ‘First’ or ‘Second’ to force the transmission to move into, and stay in, thesesubstates.
The notation 
reachSecondSpeed[driveSelected]  illustrates the use of a guard condition. The system will only respond to the indicated event(
reachSecondSpeed ) if the condition in square brackets is true. In Figure 8.18, thisis used to prevent the transmission from changing gear if the driver hadmanually selected first or second gear. A guard condition differs from the typeof condition we saw in Figure 8.14: a guard condition is only evaluated when itsassociated event occurs.Figure 8.19 shows how we have converted Figure 8.14 to use nested substates.Now we need to show only one 
cancel  transition and one requestToRegister
transition. Note that the ‘Planned’ state has a transition that points directly tothe ‘NotEnoughStudents’ substate, and both the transitions to the ‘Closed’ statecomes directly from the inner ‘EnoughStudents’ state. Finally, note that we haveadded an activity to the ‘Canceled’ state that deletes all registrations.
ExercisesE162
There is a missing transition in Figure 8.18. Study the diagram, and see if youcan find it (do not add any new states or event types). Figure 8.18State diagram for a car’s automatic transmission showing substatesselectDrivereachThirdSpeed[driveSelected]dropBelowThirdSpeedreachSecondSpeed[driveSelected]dropBelowSecondSpeed[driveSelected]selectFirst selectSecond selectNeutralselectNeutralselectReverse
selectFirst selectSecondReverse
Third Second FirstNeutral Lethbridge.book  Page 299  Tuesday, November 16, 2004  12:22 PM<page> 302Chapter 8
Modeling interactions and behavior 
affirmative, the thread proceeds to the join via the merge node, otherwiseregistration is disallowed and the whole activity diagram terminates.Either concurrent thread may reach the join first, at which time it will wait forthe other. It may be the case that neither thread, or only one thread, ever reachesthe join, due to the course being full or registration being disallowed. However,if both threads reach the join, then they are replaced by a single thread thatperforms the final activity – completing the registration.In Figure 8.20, the entire process comes to an end as soon as any of the endstates is reached. This implies that even if one thread is waiting at the join, it willbe terminated if the other thread reaches an end state.While state diagrams typically show states and events concerning only oneclass, activity diagrams are most often associated with several classes. Thepartition of activities among the existing classes can be explicitly shown in anactivity diagram by the introduction of swimlanes. These are boxes that form columns, each containing activities associated with one or more classes.Figure 8.21 shows how the activities of Figure 8.20 can be allocated to twodifferent classes.
8.4 Implementing classes based on interaction and state diagrams
Drawing the diagrams discussed in this chapter for every class, interaction andactivity would take too much time. However, you should certainly use thesediagrams for the parts of your system that you find most complex.For example, a state diagram is useful when different conditions will cause theinstances of a class to respond differently to the same event. This is particularlytrue when behavior is distributed across several use cases.Figure 8.20Activity diagram of the registration process[hasPermission][notFull][hasPrereqs][doesNotHavePrereqs]
[noPermission][full]CheckprerequisitesReceive courseregistration request
Checkspecialpermission
CompleteregistrationVerifycourse notfull Lethbridge.book  Page 302  Tuesday, November 16, 2004  12:22 PM<page> Section 8.4305Implementing classes based on interaction and state diagrams
  {    if(!closedOrCanceled) // must be in 'Planned' state    {      open = true; // to 'OpenNotEnoughStudents' state    }  }  public void closeRegistration()  {    // to 'Canceled' or 'Closed' state    open = false;    closedOrCanceled = true;    if (registrationList.size() < course.getMinimum())    {      unregisterStudents(); // to 'Canceled' state    }  }   public void cancel()  {    // to 'Canceled' state    open = false;    closedOrCanceled = true;    unregisterStudents();  }   public void requestToRegister(Student student)  {    if (open) // must be in one of the two 'Open' states    {      // The interaction specified in the sequence diagram of      // Figure 8.4      Course prereq = course.getPrerequisite();      if (student.hasPassedCourse(prereq))      {        // Indirectly calls addToRegistrationList        new Registration(this, student);      }       // Check for automatic transition to 'Closed' state      if (registrationList.size() >= course.getMaximum())      {        // to 'Closed' state        open = false;        closedOrCanceled = true;      } Lethbridge.book  Page 305  Tuesday, November 16, 2004  12:22 PM<page> Section 9.1311The process of design
final software product is the result of all the design decisions made; different setsof decisions lead to a different product.Y ou should try to explore different paths through design space – investigatingthe consequences of choosing different alternatives when major issues arise. InChapter 7, we recommended employing parallel design to do this. In paralleldesign, several different designers create their own designs. Following paralleldesign, you analyze the resulting designs to determine which combination ofchoices seems best for the final product.We also showed you the process of selecting among alternative designs inChapter 2, where several exercises asked you to choose among alternativedesigns of the 
PointCP  class. In Chapter 5, we studied alternative ways ofmodeling problems using class diagrams.Although there might be several ways to produce a good quality system, somedesign issues are critical. For these critical decisions, bad choices will lead to apoor system. For example, imagine that very early on in your design you chosenot to separate the user interface from the rest of the system. Such a decisionwould greatly constrain your ability to achieve a flexible, maintainable design.For example, it would become much harder to provide a web-enabled version ofyour system or to internationalize it.Each design decision should be recorded, along with the reasoning that wentinto making the decision (known as the design rationale). The entire record of the series of decisions becomes a design document. We will discuss the structureof design documents later in this chapter.
Parts of a system: subsystems, components and modules
It is now time to define some important terms that will help in furtherdiscussion. These terms are often used interchangeably, but in this book we willgive them the meanings below. The first two terms, component and module, describe concrete, implemented parts of a system.Componentany piece of software or hardware that has a clear role and can be isolated,allowing you to replace it with a different component with equivalentfunctionality. Many components are designed to be reusable, but in other casesFigure 9.1Part of a design space, showing alternative designs resulting from different choices when making design decisions. The lines represent options; the bold path is the set of decisions madeclient–server
monolithicseparate userinterface layerfor clientno separate userinterface layer for clientfat clientthin clientprogrammmed in Javaprogrammed in Visual Basicprogrammed in C++ Lethbridge.book  Page 311  Tuesday, November 16, 2004  12:22 PM<page> Section 9.2319Design Principle 2: Increase cohesion where possible
A communicationally cohesive module can be embedded in a layer. In otherwords, part of a layer’s API can involve manipulating a particular class of data.The objects manipulated by the layer may be returned to higher layers inresponse to calls to the API.The big advantage of communicational cohesion is the same key advantagewe ascribed earlier in this book to object orientation: when you need to makechanges to the data, you will find all the code in one place.Y ou should not sacrifice layer cohesion to achieve communicationalcohesion: for example, even though objects may be stored in a database or on aremote host, a class must only load and save objects using the services in the APIof lower layers.Figure 9.4 shows several examples of communicationally cohesive modules(marked with a ‘C’). These exist inside layers (marked ‘L ’) and call on services intheir own layer as well as lower layers. The services they call on may be inmodules with other types of cohesion.
SequentialcohesionThis is achieved when a series of procedures, in which one procedure providesinput to the next, are kept together – and everything else is kept out. This isillustrated in Figure 9.4 by the module marked ‘S’ .Y our objective should be to achieve sequential cohesion, once you havealready achieved the other types of cohesion listed above. Methods in twodifferent classes might provide inputs to each other and be called in sequence;but they would each be kept in their own class, since communicational cohesionis more important than sequential cohesion.As an example of sequential cohesion, imagine a text recognition subsystem.One module is given a bitmap as input and divides it up into areas that appearto contain separate characters. The output from this is fed into a second modulethat recognizes shapes and determines the probability that each areacorresponds to a particular character. The output from that is fed into a thirdmodule that uses the probabilities to determine the sequence of wordsembedded in the input. If all these modules were grouped together, then theresult would have sequential cohesion.Figure 9.4Cohesive modules, nested inside each other, using the services of other modules. The modules are labeled using the first letter of the type of cohesion they represent
L
L
C
PF C
UTT
FC
CC C
S Lethbridge.book  Page 319  Tuesday, November 16, 2004  12:22 PM<page> 320Chapter 9
Architecting and designing software 
ProceduralcohesionThis is achieved when you keep together several procedures that are used oneafter another, even though one does not necessarily provide input to the next. Itis therefore weaker than sequential cohesion. In Figure 9.4, the module marked‘P’ is procedurally cohesive.For example, in a university registration system, there would be a module toperform all the steps required to register a student in a course. The facilities fordoing separate activities, such as adding a new course, would be in othermodules.T emporalcohesionThis is achieved when operations that are performed during the same phase ofthe execution of the program are kept together, and everything else is kept out.This is weaker than procedural cohesion and is illustrated in Figure 9.4 by themodules marked ‘T’ .For example, a designer would achieve temporal cohesion by placing togetherthe code used during system start-up or initialization, so long as this did notviolate one of the other forms of cohesion listed above. Similarly, all the code forsystem termination, or for certain occasionally used features, could be kepttogether to achieve temporal cohesion.There may be a temporally cohesive module in a layer whose job is to initializethe services of that layer. The module would be called at startup time, and not atany other time.Although it would be temporally cohesive, it would be a violation ofcommunicational cohesion to create a module that directly initializes the static variables of several different classes or the services of different layers. However,it would be permissible to have a temporally cohesive module that calls the initialization procedures of other modules.UtilitycohesionThis is achieved when related utilities that cannot be logically placed in othercohesive units are kept together. A utility is a procedure or class that has wideapplicability to many different subsystems and is designed to be reusable. Autility module is marked ‘U’ in Figure 9.4.For example, the 
java.lang.Math  class has utility cohesion. Where possible, itwould be better to put mathematical functions in classes on whose instancesthey are applied; however, 
java.lang.Math  allows the grouping together offunctions that have no obvious single home.
ExercisesE172
Categorize the following aspects of a design by the types of cohesion that theywould exhibit if properly designed:(a) All the information concerning bookings is kept inside a particular class,and everything else is kept out.(b) A module is created to convert a bitmap image to the JPEG format. Lethbridge.book  Page 320  Tuesday, November 16, 2004  12:22 PM<page> Section 9.2321Design Principle 3: Reduce coupling where possible
(c) A separate subsystem is created that runs every night to generate statisticsabout the previous day’s sales.(d) A data processing operation involves receiving input from several sources,sorting it, summarizing information by input source, sorting according tothe input source that generated the most data and then returning the resultsfor the use of other subsystems. The code for these steps is all kept together,although utilities are called to do operations such as sorting.
E173 What is wrong with the following designs from the perspective of cohesion,and what could be done to improve them?(a) There are two subsystems in a university registration system that do thefollowing. Subsystem A displays lists of courses to a student, acceptsrequests from the student to register in courses, ensures that the studenthas no schedule conflicts and is eligible to register in the courses, stores thedata in the database and periodically backs up the database. Subsystem B allows faculty members to input student grades, and allows administratorsto assign courses to faculty members, add new courses, and change astudent registration. It also prints the bills that are sent to students.(b) In an electronic commerce application, a module is created to add books tothe ‘shopping basket’ and perform such operations as computing the totalamount the customer owes. A second module adds ‘special reward’merchandise to the shopping basket; this module also displays the contentsof the shopping basket on the screen and sends an email to the user tellinghim or her what he or she bought.
E174 Describe the kinds of cohesion present in the SimpleChat system. 
Design Principle 3: Reduce coupling where possible
Coupling occurs when there are interdependencies between one module andanother. Figure 9.5 illustrates the concept of a tightly coupled and looselycoupled system.
Figure 9.5Abstract examples of a tightly coupled system (left) and a loosely coupled system (right). The boldness of the arrows indicates the strength of the coupling Lethbridge.book  Page 321  Tuesday, November 16, 2004  12:22 PM<page> Section 9.2323Design Principle 3: Reduce coupling where possible
 public class Arch {   private Line baseline;  ...   void slant(int newY)   {     Point theEnd = baseline.getEnd();     theEnd.setLocation(theEnd.getX(),newY);   } } 
The content coupling occurs here even though the instance variables are private,and 
baseline , an instance of Line, is supposedly immutable ( Line has no setStart
or setEnd  methods). It is surreptitious because the Line is changed without ‘knowing’ it is changing.T able 9.2Different types of coupling. Y ou should reduce coupling where possible, but the types at the top are the strongest and hence the most important to avoidCoupling type CommentsContent A component surreptitiously modifying internal data of another component. Always avoid thisCommon The use of global variables. Severely restrict thisControl One procedure directly controlling another using a flag. Reduce this using polymorphismStamp One of the argument types of a method is one of your application classes. If it simplifies the system, replace each such argument with a simpler argument (an interface, a superclass or a few simple data items)Data The use of method arguments that are simple data. If possible, reduce the number of argumentsRoutine callA routine calling another. Reduce the total number of separate calls by encapsulating repeated sequencesType use The use of a globally defined data type. Use simpler types where possible (superclasses or interfaces)Inclusion/importIncluding a file or importing a package. Eliminate when not necessaryExternal A dependency exists to elements outside the scope of the system, such as the operating system, shared libraries or the hardware. Reduce the total number of places that have dependencies on such external elements Lethbridge.book  Page 323  Tuesday, November 16, 2004  12:22 PM<page> 324Chapter 9
Architecting and designing software 
Part of the problem is that this code does not adhere to the delegation pattern(and the law of Demeter) as discussed in Chapter 6: the 
slant  method is not accessing a neighboring object (the 
Line) but a more distant object (the Point ). Two things must be done to combat this form of content coupling:1.Make moving the end of a 
Line explicit, by adding a moveEnd  method to it. The
slant  method should call this. However, this is not enough since programmerscould still bypass the 
moveEnd  method.2.Make the 
Line class truly immutable. To do this it is necessary to use immutableclasses for its instance variables. If you do this, then you eliminate thepossibility of surreptitious modification. Y ou will notice that the 
PointCP  class discussed in Chapter 2 was immutable.CommoncouplingThis occurs whenever you use a global variable – all the modules using theglobal variable become coupled to each other, and to the module that declaresthe variable. The coupling occurs because changes to the variable’s declarationwill affect all the code that uses the variable. Also, changes to the way onemodule uses a variable will often have an effect on how the other modulesshould interpret the variable.The word ‘global’ , as used here, can mean that the variable is visible to allprocedures and objects in the system. However, a weaker form of commoncoupling occurs any time a variable can be accessed by all instances of a subsetof the system’s classes (e.g. a Java package).In older programming languages, the use of global variables was widespread;the name ‘common’ comes from the Fortran language in which it is the keywordused to declare global data. In Java, public static variables serve as globalvariables.The use of common coupling should be minimized, since it shares many ofthe disadvantages of content coupling. Occasionally, a case can be made tocreate global variables that represent system-wide default values – the argumentfor this is that it would be more complex to force a large number of routines topass around such information as their parameters. However, most of thesesystem-wide values are actually constants (i.e. declared 
final ), and not variables. For example, the 
java.lang.Math  package has the constants PI and E. As is the case with content coupling, common coupling can be reduced byencapsulation. For each global variable, create a module that has speciallydesignated public methods that can be called to get or set the data. The internalrepresentation of the data can then be more easily changed and it can beprotected from inappropriate changes made by ‘rogue’ code; also, the setmethod can verify that changes are valid.Encapsulation reduces the harm of global variables, but there is still someundesirable coupling, therefore avoid having too many such encapsulatedvariables. Note that the Singleton pattern, discussed in Chapter 6, providesencapsulated global access to an object; therefore avoid having too manysingletons. Lethbridge.book  Page 324  Tuesday, November 16, 2004  12:22 PM<page> Section 9.2325Design Principle 3: Reduce coupling where possible
ControlcouplingThis occurs when one procedure calls another using a ‘flag’ or ‘command’ thatexplicitly controls what the second procedure does. The following is an example:
public routineX(String command){  if (command.equals("drawCircle")  {    drawCircle();  }  else  {    drawRectangle();  }}
The method routineX  will have to change whenever any of its callers adds a newcommand. It should also probably be changed if any of its callers deletes acommand, otherwise it will have code that is said to be ‘dead’ .Control coupling can often be reduced by simply having the callers of 
routineX
directly call methods such as drawCircle  or drawRectangle . But the use of polymorphic operations is normally the best way to reduce control coupling. In theexample above, there could be two separate classes 
Circle  and Rectangle ; routineX
could then just call draw, with the system choosing the appropriate method to run.There are cases when control coupling cannot or should not be completelyavoided. For example, the SimpleChat server has the method
handleMessageFromClient . This is tightly coupled to the methods in theSimpleChat client that generate the commands. One way to reduce thecontrol coupling in this case would be to have a look-up table that mappeda command to a method that should be called when that command is issued.There is still some coupling, since the look-up table must be modified whencommands are changed; however, look-up tables are simpler in structurethan nested if-then-else statements.StampcouplingThis occurs whenever one of your application classes is declared as the type of amethod argument. Some stamp coupling is necessary; however, the followingsituation illustrates why it is best to try to reduce it.Imagine a class 
Employee  that has many instance variables such as name, address ,
email , salary , manager , etc., and many methods to manipulate these variables. Anymethod that is passed an instance of 
Employee  is given the ability to call any of itspublic methods. The method 
sendEmail  in the following Emailer  class, for example, has this ability.
public class Emailer{  public void sendEmail(Employee e, String text) {...} ...} Lethbridge.book  Page 325  Tuesday, November 16, 2004  12:22 PM<page> 326Chapter 9
Architecting and designing software 
The problem here is that the sendEmail  method does not need to be given access to the full 
Employee  object; it really only needs access to email  and name. Giving it full access represents unnecessary stamp coupling. Any time a maintainerchanges the 
Employee  class he or she will have to check the sendEmail  method to see if it needs to be changed. The 
Emailer  class is also not reusable – it can onlybe used in applications that use the 
Employee  class.There are two ways to reduce stamp coupling, a) using an interface as theargument type, and b) passing simple variables. The following illustrates thefirst way:
public interface Addressee{  public abstract String getName();  public abstract String getEmail();} public class Employee implements Addressee {...} public class Emailer{  public void sendEmail(Addressee e, String text) {...} ...}
The stamp coupling is reduced since the sendEmail  method now has access only to the 
name and email  data that it truly needs. Changes to the Employee  class will be far less likely to impact it. The 
sendEmail  method will still be impacted if the
Addressee  interface is changed, although that is probably unlikely to occur. Giventhat the 
Addressee  interface is easy to reuse, the Emailer  class now becomes reusable.Instead of creating a new 
Addressee  interface, you might have considered usinga superclass of 
Employee  (e.g. Person  ) as the type of the sendEmail  method. This can sometimes effectively reduce the stamp coupling; but using an interface isusually a more flexible solution. The second way to reduce stamp coupling is illustrated as follows:
public class Emailer{  public void sendEmail(String name, String email, String text)   {...} ...}
In this case the stamp coupling has been replaced with data coupling, discussedbelow.Data couplingThis occurs whenever the types of method arguments are either primitive or elsesimple classes such as 
String . Methods must obviously have arguments, Lethbridge.book  Page 326  Tuesday, November 16, 2004  12:22 PM<page> Section 9.2327Design Principle 3: Reduce coupling where possible
therefore some data coupling or stamp coupling is unavoidable. However, youshould reduce coupling by not giving methods unnecessary arguments.The more arguments a method has, the higher the coupling. This is becauseeach caller to the method must have code to prepare the data for each argument;and any changes to how the method declares or interprets each argument mayrequire changes to each caller’s code.There is a trade-off between data coupling and stamp coupling. In the case ofa single argument, data coupling is considered looser, and therefore better, thanstamp coupling. However, if you replace a single complex argument (stampcoupling) with many simple arguments (data coupling), the total resultingcoupling will be higher. In the above code, it was acceptable to eliminate stampcoupling at the expense of adding one extra argument to the 
sendEmail  method. It would not have been acceptable to add three or four extra arguments; in sucha case, sticking with the stamp coupling (using the 
Addressee  interface) would have been better.Routine callcouplingThis occurs when one routine (or method in an object-oriented system) callsanother. The routines are coupled because they depend on each other’s behavior,and the caller depends on the interface of the called routine.Routine call coupling is always present in any system. However, if you use asequence of two or more methods to compute something, and this sequence isused in more than one place, then you can reduce routine call coupling bywriting a single routine that encapsulates the sequence.For example, imagine that to use a graphics package, you had to write thefollowing sequence of code over and over again:
aShape.drawBackground();aShape.drawForeground();aShape.drawBorder();
Y ou would be better off creating a new method that encapsulated this sequence.Should the arguments of the above three methods ever change, the maintainerwould now only have to change your encapsulated method.T ype usecouplingThis occurs when a module uses a data type defined in another module. Typeuse coupling naturally occurs in typed languages such as Java. It occurs any timea class declares an instance variable or a local variable as having another class forits type.Type use coupling is similar to common coupling, but instead of data beingshared, only data types are shared. The impact of sharing data types is normallyless than the impact of sharing data, hence type use coupling is considered lessproblematic than common coupling.The consequence of type use coupling is that if the type definition changes,then the users of the type may well have to change.Stamp coupling is closely related to type use coupling, therefore thetechniques for reducing stamp coupling can also be applied to type use coupling.In particular, you should declare the type of a variable to be the most general Lethbridge.book  Page 327  Tuesday, November 16, 2004  12:22 PM<page> 328Chapter 9
Architecting and designing software 
possible class or interface that contains the required operations. For example,when creating a variable that is to contain a collection, you should normallydeclare its type to be 
List, that is, any class that implements the java.util.List
interface. The actual instance stored in the variable could be an ArrayList ,
LinkedList  or Vector , or perhaps some other class to be defined later. However,declaring the type to be 
List is sufficient since all the important operations aredefined in that interface. The benefit is that your code would be less likely toneed to change were you to later decide to use a different type of collection.Inclusion orimportcouplingImport coupling occurs when one component imports a package (as in Java);inclusion coupling occurs when one component includes another (as in C++).Doing this means that the including or importing component is now exposed toeverything in the included or imported component – even if it is not actuallyusing the facilities of that component. If the included or imported componentchanges something on which the includer relies, or adds something that raises aconflict with something in the includer, then the includer must change.The bigger the imported or included component, the worse the coupling.However, importing a standard package (e.g. one delivered with theprogramming language) is better than importing a homemade package.Some inclusion or import coupling is necessary – since it enables you to usethe facilities of libraries or other subsystems. However, it is important not toimport packages or classes that you do not need: in addition to having to worryabout changes to the things you are using, you then also have to worry aboutchanges to things you don’t use. For example, your system might suddenly fail ifa new item is added to an imported file, and this new item has the same nameas something you have already defined in your subsystem.ExternalcouplingThis occurs when a module has a dependency on such things as the operatingsystem, shared libraries or the hardware. It is best to reduce the number of placesin the code where such dependencies exist.The Façade design pattern can reduce external coupling by providing a verysmall interface to external facilities.
ExercisesE175
Another way to resolve control coupling in handleMessageFromClient  would be to use Java’s reflection mechanism. This permits Java to directly treat a string as amethod name, and then to call the method. Investigate reflection, anddetermine what changes would be required to 
handleMessageFromClient . Then discuss whether the use of reflection would actually be a good design decision,as opposed to keeping the control coupling. 
E176 Categorize the following aspects of a design by the types of coupling they exhibit. Lethbridge.book  Page 328  Tuesday, November 16, 2004  12:22 PM<page> 334Chapter 9
Architecting and designing software 
An important guideline for achieving portability is to avoid the use offacilities that are specific to one particular environment. Some programminglanguages, such as Java, make this easy because the language itself is designed toallow software to run on different platforms unchanged. Nevertheless, even withJava, there can be subtle differences regarding how some features work ondifferent platforms – knowing about these and avoiding them is important. Onesuch difference is class libraries; some companies have produced special Javalibraries that work only with that company’s compiler, which in turn runs ononly one platform. Attempting to port software that uses that library to anotherplatform can be difficult.Other languages such as C++ have many features that are very muchdependent on the particular hardware architecture. Y ou have to be aware, forexample, of the order of characters within a word (so-called big-endian versuslittle-endian), and the number of bits in an integer.Another important portability issue has to do with text files: the charactersused to terminate lines differ from platform to platform.
Design Principle 10: Design for testability
During design you can take steps to make testing easier. Testing, which is thesubject of the next chapter, can be performed both manually and automatically.Automatic testing involves writing a program that will provide various inputs tothe system in order to test it thoroughly. Therefore it pays to design a system sothat automatic testing is made easy.The most important way to design for testability is to ensure that all thefunctionality of the code can be executed without going through the graphicaluser interface. Y ou can achieve this by carefully separating the UI from thefunctional layer of the system. A test harness can then be written that calls theAPI of the functional layer. Another good strategy is to provide a command-lineversion of your system, such as the command-line version of SimpleChat thatwe presented at the beginning of this book. This will allow you to write a testprogram that automatically issues commands to your application.In order to design a Java class for testability you can create a 
main method in each class. Such 
main methods simply exercise the other methods of a class andreport any problems.
Design Principle 11: Design defensively
Y ou should never trust how others will try to use a component you aredesigning. Just like automobile drivers are taught not to trust other drivers, andtherefore to drive defensively, a software designer should not trust otherdesigners or programmers, and so should design defensively. In other words, in order to increase the reliability of your system, you not only need to make sureyou don’t add any defects yourself, but you must also properly handle all caseswhere other code attempts to use your component inappropriately. Lethbridge.book  Page 334  Tuesday, November 16, 2004  12:22 PM<page> 336Chapter 9
Architecting and designing software 
public boolean isWeekEnd(String aDate){  assert isValidDate(aDate); // precondition.  return (dayOfTheWeek(aDate)==SUNDAY ||           dayOfTheWeek(aDate)==SATURDAY);}
Under normal operation, the assertions should not be explicitly evaluated ineach method since they have always to be true. However, in the testing phase itis useful to have the assertions explicitly executed, so that you can quicklyidentify any methods that do not fulfill their contract. In Java, assertions areenabled at compile time by using the 
–ea switch of javac . In this mode, assert  will throw an 
AssertionError  if the expression evaluates to false . When assertion checking is disabled (default mode), the 
assert statements are simply ignored. Y ou should therefore always switch on assertion checking during developmentand testing, and turn it off when the system is finally released.Note that design by contract implies a level of trust. It is like having a drivinginstructor with you, clarifying the rules of the road, and stopping you fromhaving an accident while you are learning. However, if you make mistakes aftergetting your license (the assertion checking is off) you can still have an accident.Therefore at the boundaries between major components, such as layers, youshould always rigorously check inputs. At these boundaries, you wouldtherefore not use an assertion mechanism that can be turned off.
9.3 T echniques for making good design decisions
The principles discussed in the previous section suggest qualities you shouldstrive to build into software as you design it. In this section we describe twoapproaches that will help you to make decisions.
Using priorities and objectives to decide among alternatives
Before you start design, you should have established priorities and objectives forvarious aspects of quality. An objective is a measurable value you wish to attain.A priority states which qualities override others in those cases where you mustmake compromises.The qualities to consider when setting priorities and objectives includememory efficiency, CPU efficiency, maintainability, portability and usability. Ingeneral, the priorities and objectives should be obtained from the non-functional requirements.In order to make a design decision, you can perform the following steps:Step 1List and describe the alternatives for the design decision.Step 2List the advantages and disadvantages of each alternative with respect to yourobjectives and priorities. Lethbridge.book  Page 336  Tuesday, November 16, 2004  12:22 PM<page> 338Chapter 9
Architecting and designing software 
ExerciseE179
Y ou are given Table 9.4 showing the quality levels achieved by various softwarearchitectures. 
Determine which architecture you might choose if you had the followingobjectives and priorities. Justify your answer.(a) Objectives: runs on Windows; works on a 30 Kbps connection or faster;works on a 1 GHz machine or faster; requires no more than 25 MBmemory. General priorities, starting with first: bandwidth efficiency, CPUefficiency, portability, memory efficiency, maintainability.(b) Same as (a) except bandwidth drops to fourth priority.T able 9.3Algorithm evaluations Security Maintainability MemoryefficiencyCPU efficiencyBandwidthefficiencyPortability Algorithm A High Medium High Medium; DNMOLow Low Algorithm B High High Low Medium; DNMOMedium Low Algorithm C High High High Low; DNMOHigh Low Algorithm D — — — Medium; DNMODNMO — Algorithm E DNMO — — Low; DNMO——
T able 9.4Quality levels achieved by various software architectures
SoftwarearchitectureMaintain-ability MemoryrequiredCPU speedrequiredBandwidthrequiredPortable to which platforms? A High 20 MB 1 GHz needed35 Kbps Unix, Windows B High 14 MB 500 MHz needed1 Mbps Windows only C High 8 MB 2 GHz needed2 Kbps Windows, Macintosh D Medium 20 MB 1 GHz needed30 Kbps Unix only Lethbridge.book  Page 338  Tuesday, November 16, 2004  12:22 PM<page> Section 9.4341Model Driven Development
Since the earliest days of software engineering, people have used models; andsince the mid 1990s these have been typically developed in UML. However,often in the past the models were little more than diagrams – very usefuldiagrams, but just diagrams. Developers used the diagrams as a guide to theirprogramming. Gradually, various modeling tools were given the capability togenerate some of the code; programmers could then fill in the missing details.Now, tools are available which can take models and generate all of the code for certain types of applications. The model effectively becomes a form of high-levelprogram and all development work can take place exclusively in the model. Thisprocess, known as model-driven development, is expected to become more andmore widespread over the next 10–20 years as tools become more sophisticated.
Model-driven development does not, however, eliminate the need to codecertain types of detailed algorithms. That is why tools that generate entiresystems from UML models must also provide a language for implementing theactions and activities that we discussed in Chapter 8. UML provides a lot ofdetail about the semantics of the actions and activities that must be supportedby such a tool; however, it leaves the syntax of an appropriate action language to the tool. We will not discuss the details of UML actions any further, except to saythat tools can allow the developer to code the actions in a language such as Java.There are various different approaches to model-driven development. Anapproach developed by the OMG (who also develop UML) is called Model Driven Architecture (MDA).One of the important features of model-driven development is that themodels themselves can be created at several different levels of abstraction. InMDA, one first develops a Platform Independent Model (PIM). This describesthe system’s data and activities in a very general way. One then adds detail to
Increasing abstraction in programming
In the beginning (the early 1950s) people programmed in machine language: directly manipulating the binary op-codes that the CPU uses as its instructions. Then computer scientists had the bright ideaof creating assembly language: abstracting some of the detail away, making the machine code morehuman readable using mnemonics for each instruction, and adding higher-level macro capabilities todeal with repetitive tasks.  Assemblers translated this into machine language.The next stage in the evolution of programming was high-level languages: this started with Fortran and Cobol, and eventually led to modern languages such as Java, C#, etc. Compilersare programs that initially generated assembler code, and now directly generate machinecode or else bytecode for virtual machines. High-level languages added numerousabstractions to make programming simpler: types systems, higher level statements, classes,etc.Model-driven development simply takes this process further: by modeling in UML thedeveloper can take advantage of abstractions such as states and associations without havingto worry about the details of coding them. T ools can generate high-level language code,machine code or bytecode. Lethbridge.book  Page 341  Tuesday, November 16, 2004  12:22 PM<page> Section 9.5345Software architecture
2.Refine the architecture by identifying the main ways in which the componentswill interact, and by identifying the interfaces among them. Also, decide howeach piece of data and functionality will be distributed among the variouscomponents. Now is the time to determine if you can reuse an existingframework. If possible, you might decide to transform your architecture into ageneric framework that can be reused by others.3.Consider each use case, adjusting the architecture to make it realizable. At thisstage you try to finalize the interface of each component.4.Mature the architecture as you define the final class diagrams and interactiondiagrams.
Describing an architecture using UML
All UML diagrams can be useful to describe aspects of the architectural model.Remember that the goal of architecture is to describe the system at a very highlevel, with emphasis on software components and their interfaces. Use casediagrams can provide a good summary of the system from the user’sperspective. Class diagrams can be used to indicate the services offered bycomponents and the main data to be stored. Interaction diagrams can be usedto define the protocol used when two components communicate with eachother.In addition to the UML diagrams we have already studied in this book, threeother types of UML diagram are particularly important for architecturemodeling: package diagrams, component diagrams and deployment diagrams.These are used to describe different aspects of the organization of the system. Inthe next three subsections we will survey the essentials of these types ofdiagram.
Packages
Breaking a large system into subsystems is a fundamental principle of softwaredevelopment. A good decomposition helps make the system moreunderstandable and therefore facilitates its maintainability.In UML, a package is a collection of modeling elements that are groupedtogether because they are logically related. Note that a UML package is not quitethe same thing as a Java package, which is a collection containing only classes.However, a very common use of UML packages is to represent Java packages.A package in UML is shown as a box, with a smaller box attached above its topleft corner. The packages of the SimpleChat system are illustrated in Figure 9.6.Inside the box you can put practically anything, including classes, instances, textor other packages.When you define a package, you should apply the principles of cohesion andcoupling discussed earlier. Increasing cohesion means ensuring that a packageonly has related classes; decreasing coupling means decreasing the number ofdependencies as much as possible. Lethbridge.book  Page 345  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6347Architectural patterns
Deployment diagrams
A deployment diagram describes the hardware where various instances ofcomponents reside at run time. An example is shown in Figure 9.8. A node in adeployment diagram represents a computational unit such as a computer, aprocessing card, a sensor or a device. It appears as a three-dimensional box.
The links between nodes show how communication takes place. Each node ofa deployment diagram can include one or several run-time softwarecomponents. Various artifacts such as files can also be shown inside nodes.
9.6 Architectural patterns
The notion of patterns, introduced in Chapter 5, can be applied to softwarearchitecture. In this chapter we present several of the most importantarchitectural patterns, which are also often called architectural styles. Each allows you to design flexible systems using components that are as independent of eachother as possible.
The Multi-Layer architectural pattern
Building software in layers is a classical architectural pattern that is used inmany systems. It is so important that layer cohesion was one of the types ofcohesion we presented earlier when discussing Design Principle 2.As we discussed, in layered systems each layer communicates only with thelayers below it – in many cases, only the layer immediately below it. Each layerhas a well-defined API, defining the services it provides.A complex system can be built by superimposing layers at increasing levels ofabstraction. The Multi-Layer architectural pattern makes it possible to replace alayer by an improved version, or one with a different set of capabilities.It is particularly important to have a separate layer at the very top to handlethe user interface. Independence of the UI layer allows the application to haveseveral different UIs. These could be UIs running on different platforms, UIs for ‘professional’ versus ‘standard’ versions of the application, or UIs designed for different locales (discussed in Chapter 7). We will look at the UI layer in more detail below when we discuss the Model–View–Controller architectural pattern.Layers immediately below the UI layer provide the application functionsdetermined by the use cases. Layers at the bottom provide services such as datastorage and transmission. This is illustrated in Figure 9.3(a).Figure 9.8An example deployment diagramTCP/IP WirelesscommunicationClient1:Client2:Machine2:
Client2:Machine1:
Client1:GPSdevice
Server: Lethbridge.book  Page 347  Tuesday, November 16, 2004  12:22 PM<page> 348Chapter 9
Architecting and designing software 
Most operating systems are built according to theMulti-Layer architectural pattern, as shown in Figure9.3(b). A low-level kernel layer deals with such functionsas process creation, swapping, and scheduling. Higher-level layers deal with such functions as user accountmanagement, screen display, etc. The layers are oftenfurther subdivided into smaller subsystems.Most communications systems exhibit a layeredarchitecture. A simplified illustration of this is shown inFigure 9.3(c). At the bottom level, there are facilities fortransmitting and receiving signals. Above this is a layerthat deals with splitting messages into packets andreconstructing messages that are received. Still higher isa layer that deals with handling ongoing connectionswith a remote host (e.g. using sockets). At the top is alayer that handles various protocols, such as http, usedby application programs.The SimpleChat system uses a layered architecture toseparate the user interface from the core of the system.For example, the class 
ChatClient  is separated from the class 
ClientConsole . The Observable layer of the OCSF allows the core of a clientor server to be further separated into a layer that has the application logic, andone that deals with client–server communication.Although the normal assumption is that the communication between layerswill be by procedure calls, it can also be performed in some systems using inter-process communication. In other words, the lower layers can become serversand the higher layers can become clients. This illustrates how the Multi-Layerand Client–Server architectural patterns (discussed next) can be used together.If we did use inter-process communication to implement a layered architecture,we would typically redraw Figure 9.3 using a component diagram.The Multi-Layer architectural pattern helps you adhere to many of the designprinciples discussed earlier, in particular:
BDivide and conquer. The separate layers can be independently designed.
CIncrease cohesion. Well-designed layers have layer cohesion; in other words,they contain all the facilities to provide a set of related services, and nothingelse.
DReduce coupling. Well-designed lower layers do not know about the higherlayers. The higher layers can therefore be replaced without impacting the lowerlayers. Also, the only connection between layers is through the API.
EIncrease abstraction. When you design the higher layers, you do not need toknow the details of how the lower layers are implemented. This makesdesigning high-level facilities much easier.Patterns at different levels of abstraction
Patterns can be created for any activityinvolving human expertise. In softwareengineering, they occur at many levelsof abstraction.At the lowest level are pro-gramming idioms; these describepreferred ways to solve detailedprogramming problems, and are outof the scope of this book. Moving upthe abstraction scale are the designpatterns such as Delegation andObserver, and the modeling patternssuch as Abstraction–Occurrencepresented in Chapter 6.  At the topof the abstraction scale are thearchitectural patterns discussed here. Lethbridge.book  Page 348  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6349The Client–Server and other distributed architectural patterns
FIncrease reusability. The lower layers can often be designed generically so thatthey can be used to provide the same services for different systems.
GIncrease reuse. Y ou can often reuse layers built by others that provide theservices you need – a layer for loading and storing from a database, forexample.
HDesign for flexibility. Designing in layers gives you the flexibility to add newfacilities that build on lower-level services, or to replace higher-level layers.
IAnticipate obsolescence. Databases and UI systems tend to change; by isolatingthese in separate layers, the system becomes more resistant to obsolescence.
JDesign for portability. All the facilities that are dependent on a particularplatform can be isolated in one of the lower layers.
1)Design for testability. Individual layers, particularly the UI layer, database layer and communications layer, can be tested independently.
1!Design defensively. The APIs of layers are natural places to build in rigorouschecks of the validity of inputs. Y ou can design a system so that if a higher layerfails, the lower layers continue to run. The opposite can also be made true; forexample, if a database layer crashes, it could be made to restart automatically.
ExerciseE180
Describe how you might divide a video-game system into layers. Consider thatthe system has components which do some of the following activities: displaygraphics, manage the objects that are displayed on the screen, compute objectposition and speed, keep track of scores, keep track of various stages of thegame. 
The Client–Server and other distributed architectural patterns
We discussed the Client–Server architectural pattern in detail in Chapter 3. Itsbasic principles are: a) there is at least one component that has the role of server,waiting for and then handling connections, and b) there is at least onecomponent that has the role of client, initiating connections in order to obtainsome service.An important variant of the client–server architecture is the three-tier modelunder which a server communicates with both a client (usually through theInternet) and a database server (usually within an intranet, for security reasons).The server acts as a client when accessing the database server.A further extension to the Client–Server architectural pattern is the Peer-to-Peer architectural pattern. A peer-to-peer system is composed of varioussoftware components that are distributed over several hosts. Each of thesecomponents can be both a server and a client. Any two components can set upa communication channel to exchange information as required. Figure 9.9 Lethbridge.book  Page 349  Tuesday, November 16, 2004  12:22 PM<page> 350Chapter 9
Architecting and designing software 
shows a peer-to-peer architecture for instant messaging. Messages no longerhave to be sent through a central server. However, before two peers cancommunicate, they have to discover each other’s existence. A central server maystill be used for this.
Distributed architectures help you adhere to design principles such as thefollowing:
BDivide and conquer. Dividing the system into client and server processes is avery strong way to divide the system. Each can be separately developed.
CIncrease cohesion. The server can provide a cohesive service to clients. Forexample, it can provide a single service with no side effects and therefore befunctionally cohesive. A server also acts as a lower-level layer that the clientaccesses.
DReduce coupling. There is usually only one communication channel betweendistributed components, and the data being passed is usually simple messages.This helps reduce coupling, although there is normally control coupling(commands sent by the client control what the server does).
EIncrease abstraction. Separate distributed components are often goodabstractions. For example, you do not need to understand the details of how aserver operates.
GIncrease reuse. It is often possible to find suitable frameworks on which to buildgood distributed systems (e.g. OCSF). However, reusability may not be highsince client–server systems are often very application specific.
HDesign for flexibility. Distributed systems can often be easily reconfigured byadding extra servers or clients. Furthermore, as discussed in Chapter 3, clientsand servers can be developed by competing organizations, giving the customera choice. However, changing the protocol of the system can be difficult.
JDesign for portability. Y ou can write clients for new platforms without having toport the server.
1)Design for testability. Y ou can test clients and servers independently.Figure 9.9A peer-to-peer architecture for instant messaging, retaining a central server only to look up the addresses of clientsexchangemessages look upaddresses
Client2:Client1:
Server:
exchangemessages Lethbridge.book  Page 350  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6351The Broker architectural pattern
1!Design defensively. Y ou can put rigorous checks in the message handling code toe n s u r e  t h a t  n o  m a t t e r  w h a t  m e s s a g e s  y o u  r e c e i v e ,  y o u r  c o m p o n e n t  w i l l  n o tcrash.
ExerciseE181
The original Napster was the most famous and controversial of many peer-to-peer systems for sharing files; in its architecture, it retained a central registry ofusers. Other peer-to-peer file sharing systems, such as Gnutella and KAZAA,do not require a central registry. Do some research to determine how thevarious current file-sharing systems work, and how some are able to dispensewith a central server. What are the advantages and disadvantages of the twoapproaches?
The Broker architectural pattern
The idea of the Broker architectural pattern is to distribute aspects of thesoftware system transparently to different nodes. This is illustrated inFigure 9.10.Using the Broker architecture, an object can call methods of another objectwithout knowing that this object is remotely located. The use of the Proxydesign pattern (discussed in Chapter 6) can help achieve this goal. A Proxyobject calls the broker, which determines where the remote object can be found.CORBA is a well-known open standard that allows you to build this kind ofarchitecture – it stands for Common Object Request Broker Architecture. Javahas many classes that allow you to use CORBA facilities. There are also severalother commercial architectures that also provide broker capabilities.The Broker pattern is particularly useful in helping you follow these designprinciples:
BDivide and conquer. The remote objects can be independently designed.
FIncrease reusability. It is often possible to design the remote objects so thatother systems can use them too.
GIncrease reuse. Y ou may be able to reuse remote objects that others have created.
HDesign for flexibility. The broker objects can be updated as required, or you canredirect the proxy to communicate with a different remote object.
JDesign for portability. Y ou can write clients for new platforms while stillaccessing brokers and remote objects on other platforms.Figure 9.10The Broker architectural pattern«object request»
Proxy Remote ObjectBrokerClient
Proxy Lethbridge.book  Page 351  Tuesday, November 16, 2004  12:22 PM<page> 352Chapter 9
Architecting and designing software 
1!Design defensively. Y ou can provide careful assertion checking in the remoteobjects.Note that the separation of data between a proxy and a remote object tends toreduce communicational cohesion.
ExerciseE182
Do some research to determine the main broker platforms and theirdifferences. 
The Transaction Processing architectural pattern
In the Transaction Processing architectural pattern, a process reads a series ofinputs one by one. Each input describes a transaction – a command that typically makes some change to the data stored by the system. There is atransaction dispatcher component that decides what to do with eachtransaction; this dispatches a procedure call or message to a component that willhandle the transaction.For example, in the airline system, transactions might be used to add a newflight, add a booking, change a booking or delete a booking. This is illustratedin Figure 9.11.
The dynamic binding and dispatching of polymorphic methods is a furtherexample. In fact, it is best to design a system to use this implicit transaction-processing mechanism where possible, rather than designing an explicitversion.Transaction processing systems are often embedded in servers. A typicalexample is a database engine, where the transactions are various types of queriesand updates. The command handler mechanisms in SimpleChat’s server andclient classes are, in fact, transaction dispatchers, although the pattern would bemore strongly followed if they dispatched each command to a separate method.Transactions themselves vary in their level of complexity. In many cases anupdate transaction requires that several separate changes be made to a database.For example, as we saw in Chapter 5, booking a passenger on a flight requirescreating a 
Booking  object, as well as creating bi-directional links from it to a
SpecificFlight  and a PassengerRole . It is essential that this whole transaction befully completed, or else not done at all. Transaction dispatchers and handlerstherefore work together to assure the atomicity of transactions.Figure 9.11The transaction processing architecture used in an airline systemtransactions Transactioninput TransactiondispatcherHandler forflight reservationtransaction
Handler forflight cancellationtransaction Lethbridge.book  Page 352  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6353The Pipe-and-Filter architectural pattern
Many transaction processing systems work in environments where severaldifferent threads or processes can attempt to perform transactions at once. Inthese environments the data to be modified by the transaction must be lockedfirst, and the lock must be released afterwards. The situation is furthercomplicated by the fact that an application may need to do a query transaction,then process the data, and finally do an update transaction on the data, whilebeing assured that another thread has not changed the data in the meantime. Ifa lock is used, then other transactions are delayed until the whole process iscomplete. There are several strategies for handling this situation – you shouldread a database design book to learn about them. However, in the next chapterwe will raise some relevant issues when we talk about testing systems that havemultiple threads.The Transaction Processing pattern is particularly useful in helping youfollow these design principles:
BDivide and conquer. The transaction handlers are suitable system divisions thatyou can give to separate software engineers.
CIncrease cohesion. Transaction handlers are naturally cohesive units. They mayexhibit functional, sequential or procedural cohesion. However, they tend notto exhibit communicational cohesion.
DReduce coupling. Separating the dispatcher from the handlers tends to reducecoupling. However, you have to be careful that the coupling among thetransaction handlers is kept under control.
HDesign for flexibility. Y ou can readily add new transaction handlers.
1!Design defensively. Y ou can add assertion checking in each transaction handlerand/or in the dispatcher.
The Pipe-and-Filter architectural pattern
The Pipe-and-Filter architectural pattern is also often called thetransformational architectural pattern. It works as follows. A stream of data, ina relatively simple format, is passed through a series of processes, each of whichtransforms it in some way. The series of processes is called a pipeline. Data is constantly fed into the pipeline; the processes work concurrently (conceptuallyat least) so that data is also constantly emerging from the pipeline.The strength of this pattern is that the system can be modified easily byadding or changing the transformational processes. This is easiest if, at moststages of the pipeline, the data has the same general form. For example, the datamight be simply a stream of characters. The processes might do such things asconverting the characters to upper case; removing unneeded characters; orencrypting the text.Another example of a pipe-and-filter architecture is a speech transmissionsystem. This would continuously read sound coming from microphones,process it in various ways, compress it, transmit it over a network and then Lethbridge.book  Page 353  Tuesday, November 16, 2004  12:22 PM<page> 354Chapter 9
Architecting and designing software 
regenerate sound at a remote location. It would use several differenttransformational components to do this. The architecture is illustrated inFigure 9.12.
Some of the transformational processes are true filters: ‘cancel echo’ , ‘cancelnoise’ , ‘remove non-voice frequencies’ and ‘equalize dynamic range’ simplyremove some of the information, but leave it in the same format. The otherprocesses convert the information into distinctly different formats.The ‘cancel noise’ process illustrates how two pipelines can join together. It isalso possible for a pipeline to split into two.In Chapter 3, we saw the use of the classes 
ObjectOutputStream ,
DataOutputStream , OutputStream , and the corresponding input streams. These actlike filters passing data to each other: for example 
ObjectOutputStream  will convert an arbitrary object into bytes which it then passes to 
OutputStream  for transmission; after transmission, an 
InputStream  will receive the data and pass it to an 
ObjectInputStream  for reconstruction of the original objects.A pipe-and-filter system provides fulfils the following principles:
BDivide and conquer. The separate processes can be independently designed.
CIncrease cohesion. The processes generally have functional cohesion.
DReduce coupling. The processes have only one input and one output, normallyusing a standard format, therefore coupling is very low. Type use coupling canbecome an issue if the format of the data needs to change.
EIncrease abstraction. The pipeline components are often good abstractions,hiding their internal details.
FIncrease reusability. The processes can often be used in many different contexts.
GIncrease reuse. It is often possible to find reusable components to insert into apipeline.Figure 9.12A pipe-and-filter architecture for sound processingmicrophonesnearsoundsource
distantmicrophone
TCP/IP Transmissioncancelecho cancelnoiseremovenon-voicefrequencies equalizedynamicrangecompress transmit
receive decompressdecodersfor speakeroutputencoders formicrophoneinput
encoder forambientnoise Lethbridge.book  Page 354  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6359The Service-Oriented architectural pattern
The toughest challenge facing the developer of a Web service is security. The service opens the enterprise’s business operations and data to remotelydistributed clients. Special care must therefore be taken to protect bothcustomer and business information. Other important considerations arereliability, availability and scalability of the Web service.Two examples of well-known platforms you can use to build web-services-based applications are Sun’s J2EE platform and Microsoft’s .NET Framework.These can be seen as large horizontal frameworks providing, among many otherthings, the required functionality to build interoperable services. They bothprovide flexible security models and offer other mechanisms to assist withscalability and reliability.The Web services pattern helps you to adhere to the following designprinciples:
BDivide and conquer. The application is made of independently designed Webservices, which are distributed and accessible through the Internet.
CIncrease cohesion. Normally, the Web services are structured as layers, wherehigh-level services are built on top of lower-level services. Some Web servicescan also exhibit functional cohesion. 
DReduce coupling. Web-based applications are loosely-coupled applications builtby binding together distributed components. 
EIncrease abstraction. Since the clients communicate with each Web servicethrough well-defined interface, no details about the particular implementationof a given Web service need to be known. However, communication with aWeb service can sometimes be quite complex if the protocol is not defined atthe right level of abstraction.
FIncrease reusability. A Web service is a highly reusable component.
GIncrease reuse. Web-based applications are built by reusing existing Webservices.
IAnticipate obsolescence. If the technology used inside a given Web servicebecomes obsolete, then a new implementation of this service can be offeredwithout impacting the applications that use it. The web-service architecturecan be seen as a client–server architecture where the obsolescence risk isreduced by relying on open communication standards.
JDesign for portability. A service can be implemented on any platform thatsupports the required standard protocols.
1)Design for testability. Each service can be tested independently.
1!Design defensively. Web services enforce defensive design, since many differentapplications, written by various developers (including malicious ones), canaccess the service. Each Web service has therefore no choice but to detect andreject any inappropriate or improperly formatted request for service. Lethbridge.book  Page 359  Tuesday, November 16, 2004  12:22 PM<page> 360Chapter 9
Architecting and designing software 
ExerciseE185
Search the web for a company offering a public Web service. Describe theservice offered and give an example of an application that could use it.
The Message-Oriented architectural pattern
Also known as Message-Oriented Middleware (MOM), this architecture isbased on the idea that since humans can communicate and collaborate toaccomplish some task by exchanging emails or instant messages, then softwareapplications should also be able to operate in a similar manner. The core of thearchitecture is an application-to-application messaging system. Senders andreceivers need only to know what are the message formats; that is, a receiving(or sending) application does not have to know anything about the softwarecomponent that sent (or received) the message. Moreover, the twocommunicating applications do not even have to be available at the same time.This is illustrated in Figure 9.15.
The message, which is central to MOM architectures, is a self-containedpackage containing application data plus some network routing headers used bythe messaging system to transmit the message across the network. The messagesare sent through virtual channels, also called topics. Software components that send messages to topics are called publishers. To receive messages, an applicationmust subscribe to a topic. In general, any message sent to a given topic isdelivered to all the topic’s subscribers, each of them receiving a copy of themessage. This has similarities to the Observer design pattern discussed inChapter 6.The application can choose to ignore a received message or react to it by, forinstance, sending a reply containing requested information. The exchange ofthese messages is governed by two important principles. First, message deliveryis completely asynchronous; that means the exact moment at which a givenFigure 9.15The Message-Oriented architectural pattern
MOM client Message Server«publisher»
«subscriber»MOM client
«subscriber»
MOM clientMOM client
«subscriber»«publisher»«subscriber» Lethbridge.book  Page 360  Tuesday, November 16, 2004  12:22 PM<page> Section 9.6361The Message-Oriented architectural pattern
message is delivered to a given subscribing application is unknown. Secondly,reliability mechanisms are in place such that the messaging system can offer theguarantee that a given message is delivered once and only once.Text messaging using cellular phones can be seen as a simple message-oriented application, but more complex systems can also adopt this architecture.Consider, for example, a sales company where various vendors sell products toconsumers. When an item is sold, the vendor’s software system canautomatically send a message to the appropriate topic. The inventorycomponent, one of the subscribers of this topic, would then be informed andinitiate the product delivery process. At the same time, the sales office willreceive the same message and use it to, let’s say, accumulate statistics about salestrends. The accounting department would calculate the vendor’s commissionfrom the information received. And finally, another subscriber could be thefactory that would adjust the production rate based on the number of productssold. Clearly, the effectiveness of such system depends on the messaging systemthat is used to deliver the messages. Two approaches can be taken whendesigning such a system. The first is to use a centralized architecture where allmessages transit through a message server that is responsible for deliveringmessages to the subscribers. This is the simpler model, but all functionality thenrelies on the server. The alternative is to use a decentralized architecture wheremessage routing is delegated to the network layer and where some of the serverfunctionality is distributed among all message clients. The Java Message Service (JMS) is an API providing all the required features to develop and deploymessage-oriented applications. JMS-based components are portable and can beused by different applications that communicate using different messagingsystem service providers.This pattern allows us to adhere to the following design principles:
BDivide and conquer. The application is made of isolated software components,independently designed and distributed across a network.
DReduce coupling. The components are loosely coupled since they share onlydata format (a form of data coupling). 
EIncrease abstraction. The quality of the abstraction mainly resides in theprescribed format for the messages. These are generally fairly simple tomanipulate, all the application details being hidden behind the messagingsystem.
FIncrease reusability. A component will be reusable if its underlying prescribedmessage formats are flexible enough to adapt to different contexts.
GIncrease reuse. The different components can be reused as long as the newsystem can adhere to the formats proposed by each reused component. Lethbridge.book  Page 361  Tuesday, November 16, 2004  12:22 PM<page> 362Chapter 9
Architecting and designing software 
HDesign for flexibility. It is always easy to update or enhance the functionality of amessage-oriented system just by adding, removing or replacing components inthe system.
1)Design for testability. Each component can be tested independently.
1!Design defensively. Defensive design in the context of message-oriented systemsconsists of validating all received messages before processing them and ignorethe ones that cannot be properly interpreted.
ExerciseE186
Draw a diagram showing the components of an online auction applicationdesigned using a message-oriented architecture. Describe the messages to beexchanged.
E187 Sketch a possible architecture for the following systems. It will be helpful firstto sketch the most important use cases. Describe which architectural patternsyou are using.(a) A corporate payroll system. All the information about employees,including their monthly salary and bank account, is kept in a database.Every two weeks, the system pays employees by depositing their salary intheir bank account.(b) A system to buy stocks on the Internet. Clients perform their transactionsusing a web browser. They are to access their accounts by providing a userID and password. When an order is made, the system must process it bycommunicating with the appropriate stock market. The system also has tointeract with the bank account of the client once the amount of thetransaction is determined.(c) The GANA system whose requirements were described in Chapter 4.(d) A system for analyzing signals from a radio-telescope to see if there aresigns of extra-terrestrial intelligence. This system takes tapes containingradio signal data, and divides them up into small ‘work units’ that aredistributed to hundreds of thousands of computers running screen savers.These screen savers filter and transform the data in various ways, and thenanalyze it to detect different kinds of signals. Results are returned to thecentral site for further analysis. See setiathome.ssl.berkeley.edu for a realimplementation of such a system. 
9.7 Writing a good design document
Design documents serve two main purposes. Firstly, they help you, as a designeror a design team, to make good design decisions. The process of writing down Lethbridge.book  Page 362  Tuesday, November 16, 2004  12:22 PM<page> Section 9.11369For more information
(a) A capability to allow several servers to be linked together. A user couldconnect his or her client to any of the servers. The functions of the systemwould appear to the end-users to work in the same way as if there was justone server.(b) A capability to allow users to send files to each other. The receiving userwould have to acknowledge that he or she is willing to accept the file.(c) A ‘buddy-list’ capability. A client can ask to be notified when any of aparticular subset of other clients is logged on (currently the system tells youthe complete set of people who are logged on).(d) The ability to conduct votes among all the people on a channel. One user,who proposes a vote, specifies the question and several alternative answersthat people can vote for. Voting can be done in a way that is visible toeverybody, or else secretly (at the discretion of the proposer). Wheneverthe proposer desires, the results can be tabulated and transmitted toeverybody.
E189 Create a design for each of the features you specified in the last exercise. If youdiscover defects in the requirements, then update them.
E190 Implement the features you designed in the last exercise. If you discover flawsin the requirements or design, then update those documents as needed.
E191 This exercise requires you to do some research into basic cryptographictechniques. Specify and design an extension to SimpleChat that would allowyou to encrypt all the communication that occurs in a particular channel.
E192 Create a complete design document, including an architectural model, for theSmall Hotel Reservation System. Lethbridge.book  Page 369  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 370  Tuesday, November 16, 2004  12:22 PM<page> Section 10.3381Defects in ordinary algorithms
reversing comparison operators (e.g. > becomes < ), or mishandling the equality case (e.g. 
>= becomes > or vice versa).T estingstrategyUse equivalence class and boundary testing. To compute the equivalence classes,consider each variable used in the logical condition as an input.ExampleImagine that an aircraft’s alarm is supposed to sound if the landing gear is notdeployed when the aircraft is close to the ground. The specifications might statethis as follows: ‘The landing gear must be deployed whenever the plane is within2 minutes from landing or take-off, or within 2000 feet from the ground. Ifvisibility is less than 1000 feet, then the landing gear must be deployed wheneverthe plane is within 3 minutes from the landing or lower than 2500 feet. ’ Note thatin this case a false alarm is just as bad as a failure of the alarm to sound when itshould.Java code for the alarm might be written as follows (in deliberately bad style):
if(!landingGearDeployed &&  (min(now-takeoffTime,estLandTime-now))<    (visibility < 1000 ? 180 :120) ||  relativeAltitude <    (visibility < 1000 ? 2500 :2000)  ){  throw new LandingGearException();}
Unfortunately, this type of bad style that gives rise to defects is rather a commonpractice. There is at least one critical defect in this code – see if you canunderstand the code and find the defect. It is likely that a programmer might notnotice it due to the nested parentheses and the overall complexity of thecondition.As shown in Table 10.2, the inputs are the variables used in the condition. Thetotal number of system equivalence classes in the aircraft example would be3×3×3×2×2 = 108. Since this number is manageably small, and since this is asafety-critical system, all the classes should be tested.Figure 10.2 shows how the equivalence classes relate to each other. The grayarea indicates the classes where the alarm should sound if the landing gear is notdeployed. The most critical classes are those next to the boundary of the grayarea, each of which is marked with a letter. In these classes, a change in a singlevariable can affect the outcome. Table 10.3 describes the equivalence classes weneed to test areas a and d.    We also need to perform boundary tests for each of the equivalence classes.For example, testing what happens if the visibility is zero, very close to 1000feet, and unlimited. Particularly important boundary cases occur while theplane is on the ground, since it is likely that special processing might takeplace while there. Lethbridge.book  Page 381  Tuesday, November 16, 2004  12:22 PM<page> Section 10.3383Defects in ordinary algorithms
Y ou might ask the question, how can I test a landing-gear system like thissince it is to be embedded in a real aircraft? The answer is that the alarm moduleneeds to be thoroughly tested in a simulated environment before being tested ina real aircraft.
ExercisesE197
Write Java code for the aircraft landing-gear example and test it according tothe equivalence classes and boundary cases suggested. Record and fix anydefects. Note that to save time, you should write a program to test itautomatically (this is called a test harness). 
E198 Create tables that will help you test the conditions corresponding to thefollowing requirements.(a) User C sends a message to A. The message must be forwarded from A to Bif the following are all true: 1) A has requested that his or her messages beforwarded to B; 2) B is logged on; and 3) B has neither requested thatmessages from A be blocked nor that messages from C be blocked.Furthermore, if the message is declared to be an emergency message thenno blocking occurs.(b) Applicants under the age of 18 should use form A, while those 18 or aboveshould use form B. However, disabled people of any age, except those onsocial assistance, should use form C. People on social assistance shouldc o m p l e t e  f o r m  D  i n  a d d i t i o n  t o  e i t h e r  A  o r  B .  S e n i o r  c i t i z e n s  s h o u l dcomplete form E in addition to the other forms, unless they are on socialassistance or are living in a subsidized nursing home. Anybody who is notdisabled and not a senior citizen, and who earns over £15,000 per year,should complete form F in addition to other forms.(c) The navigation system must announce to drivers that they have to turnonto a new road two minutes in advance of the required turn. Exceptionsarise in the following circumstances. Firstly, if a driver is still completing aprevious turn, then the warning of the new turn should be delayed until thefirst turn is complete – although 15 seconds warning must still be given.Secondly, in a city environment (where a driver driving at the speed limitwould encounter at least one possible turn every 30 seconds), the systemshould warn the driver only 30 seconds before the turn is required.(d) The burglar alarm system should sound the alarm immediately if amovement of magnitude greater than 4 is detected while the alarm isactivated. An alarm should also sound if a movement of magnitude 3persists for more than 5 seconds, or a movement of magnitude 2 persistsfor more than 15 seconds. Additionally, an alarm should sound if the totalamount of magnitude 2 or 3 movement exceeds 30 seconds in any 2-minute Lethbridge.book  Page 383  Tuesday, November 16, 2004  12:22 PM<page> Section 10.3385Defects in ordinary algorithms
the programmer has made an error. The tester should analyze what causes arepetitive action to be stopped, and should run test cases that the testeranticipates might not be handled correctly.ExampleImagine that a program is supposed to count the total number of atoms in acomplex organic molecule. It might do this by starting at an arbitrary moleculeand traversing it from bond to bond, walking down each branch.A tester might wonder, however, whether the algorithm would work correctlyif there were one or more circular structures in the molecule; he or she might besuspicious that a circular structure could cause the algorithm to try to loopforever, counting ever higher as it went round and round the molecule. Ofcourse, any reasonable programmer should also have thought of this situation,but the tester must not trust this.
Not setting up the correct preconditions for an algorithm
DefectWhen specifying an algorithm, one specifies preconditions that state what must be true before the algorithm should be executed. A defect would exist if aprogram proceeds to do its work, even when the preconditions are not satisfied.T estingstrategyRun test cases in which each precondition is not satisfied. Preferably its inputvalues are just beyond what the algorithm can accept.ExampleIn the organic chemistry program, a precondition might be that the input is asingle molecule. The tester should therefore try to test by giving as input twodisjoint molecules.
Not handling null conditions
DefectA null condition is a situation where there normally exists one or more dataitems to process, but sometimes there are none. It is a defect when a programbehaves abnormally when a null condition is encountered. In these situations,the program should ‘do nothing, gracefully’ .T estingstrategyDetermine all possible null conditions and run test cases that would highlightany inappropriate behavior.ExamplesImagine you want to calculate the average sales of members of each division inan organization. But what if some division has no members? Perhaps they allquit, or the division has just been formed and nobody has been hired. A typicaldefect would be that this relatively unusual situation results in an attempt todivide by zero (zero sales, divided by zero members).As a related example, imagine you are asked to find the salesperson who hassold the most in the above division. In attempting to perform this calculation,an algorithm might loop zero times and hence never actually set the maximumvalue, or leave it set to some arbitrary, but incorrect value. Lethbridge.book  Page 385  Tuesday, November 16, 2004  12:22 PM<page> Section 10.5391Defects in timing and co-ordination: deadlocks, livelocks and critical races
(d) Y ou run a web site that implements micro-payments; it charges users athird of a cent for every page click. Y ou accumulate each client’s bill in aninteger where each unit represents a 10th of a cent. However, you recordthe money earned by each page in a float value. 
10.5 Defects in timing and co-ordination: deadlocks, livelocks and critical races
Timing and co-ordination defects arise in situations involving some form ofconcurrency. They occur when several threads or processes interact ininappropriate ways. In this section we will use the word ‘thread’ to mean both‘thread’ and ‘process’ .The three most important kinds of timing and co-ordination defects aredeadlocks, livelocks and critical races.  W a y s  t o  d e s i g n  s o f t w a r e  s o  a s  t o  a v o i dthese situations are discussed in books on real-time and concurrent software.Here we present the concepts of these defects and some thoughts about how totest for them.
Deadlock and livelock
DefectsA deadlock is a situation where two or more threads or processes are stopped,waiting for each other to do something before either can proceed. Since neithercan do anything, they permanently stop each other from proceeding. A classicexample of real-life deadlock is the ‘gridlock’ sometimes encountered in busycities. This is illustrated in Figure 10.3. Vehicles waiting to move in one directionhold up vehicles waiting to travel in other directions; however, each set ofvehicles is ultimately delaying itself. Everybody therefore waits indefinitely.As a software example of deadlock, imagine that thread A is waiting to accessobject O. Object O is locked by thread B, perhaps using Java’s synchronizationmechanism. Thread B, however, might be waiting to access object P , which is in turnlocked by thread A. Neither thread can ever continue its work unless some outsidethread forces a break in the deadlock. This situation is illustrated in Figure 10.4.     
Figure 10.3Two examples of gridlock: a form of deadlock Lethbridge.book  Page 391  Tuesday, November 16, 2004  12:22 PM<page> 392Chapter 10
T esting and inspecting to ensure high quality 
Livelock is similar to deadlock, in the sense that the system is stuck in aparticular behavior that it cannot get out of. The difference is as follows: whereasin deadlock the system is normally hung, with nothing going on, in livelock, thesystem can do some computations, but it can never get out of a limited set ofstates.The left part of Figure 10.5 shows livelock in traffic. Several cars are trappedin a grid of one-way streets, in which some directions are blocked, perhaps byaccidents or road construction. The cars can keep moving round and round incircles, but they cannot go anywhere outside of the loop.
The right part of Figure 10.5 shows a livelock situation in a state diagram.There are several transitions leading into states A and B; but once there, thesystem can only alternate backwards and forwards between the two states.Both deadlocks and livelocks can appear as ‘hung’ systems. The difference isthat in livelock the system can continue to consume CPU time. When youencounter a hung system it is certainly a failure, but it is not necessarily causedby a deadlock or livelock: the hang could result from a single thread waiting foran unavailable resource, an infinite loop, or a crash. Also, not all deadlocks andlivelocks will completely hang a system, since other threads may still be running.T estingstrategiesDeadlocks and livelocks tend to occur as a result of unusual combinations ofconditions that are hard to anticipate or reproduce. It is often most effective touse inspection to detect such defects, rather than testing alone. There are someFigure 10.4A deadlock situation in softwareA:Thr ead O: P: B:Thr ead
locklock
waitingto lock 
O: waitingto lock P:
Figure 10.5Livelock in traffic (left) and software (right)C
AFD
E
B Lethbridge.book  Page 392  Tuesday, November 16, 2004  12:22 PM<page> 394Chapter 10
T esting and inspecting to ensure high quality 
In Java, the synchronized  keyword can be used to ensure that no other thread canaccess an object until the synchronized method terminates.Unfortunately, overuse of locking can result in deadlocks or livelocks.Locking can also dramatically slow performance since it takes a lot of extra workto manipulate and check the locks.T estingstrategiesTesting for critical races is done using the same strategies as testing fordeadlocks and livelocks. Once again, inspection is often a better solution.It is particularly hard to test for critical races using black-box testing alone,since you often do not know the extent of the concurrency going on inside thesystem, and you cannot always manipulate the various threads to cause raceconditions. The timing differences that can give rise to problems can be on theorder of milliseconds. Therefore, even if you detect a critical race during testing,you may not be able to reproduce the problem reliably. One possible, althoughinvasive, strategy is to deliberately slow down one of the threads by adding a callto the 
sleep  method.
ExerciseE201
Write a short program to generate a critical race situation. Y our program willstart two threads that sleep for a random amount of time and then do acalculation based on a stored value. They also update the stored value. Theresult of the calculations should be different depending on which thread sleepsfor the longest period of time. This exercise is designed to heighten yourawareness of critical races, not to teach you good practice! 
10.6 Defects in handling stress and unusual situations
The defects discussed in this section are encountered only when a system isbeing heavily used, or forced to its limits in some other way. These defectsrepresent a lack of robustness. To test for such defects you must run the system(a) (b)Figure 10.7A critical race situation caused by a second thread unexpectedly accessing non-synchronized dataA:Thr ead Data: B:Thr ead
getget
calcputcalcputA:Thr ead Data: B:Thr ead
get
get
calcputcalcputwaiting for A:to complete itssynchronizedoperation Lethbridge.book  Page 394  Tuesday, November 16, 2004  12:22 PM<page> 396Chapter 10
T esting and inspecting to ensure high quality 
computer or of the network. On the other hand, the problem might be morepermanent, resulting from a failure of some other system.No matter what the cause, the program being tested should report theproblem in such a way that the user will understand. It should then either waitfor the problem to be resolved, terminate gracefully or deal with the situation insome other sensible way.T estingstrategiesIn any of these cases, the tester has to deny the program under test the resourcesit normally uses, by employing such methods as deleting files, concurrentlyrunning other resource-hungry programs, making less memory available, ordisconnecting the system from the network. The tester can also run a very largenumber of copies of the program being tested, all at the same time. To do thiseffectively, you have to write a special program called a load generator that constantly provides input to the system. Load generators are availablecommercially.
Inappropriate management of resources
DefectA program does not manage resources effectively if it uses certain resources butdoes not make them available to other programs when it no longer needs them.T estingstrategyRun the program intensively over a long period of time in such a way that it usesmany resources, relinquishes them and then uses them again repeatedly.ExamplesA program might open many files, but not close them so as to enable otherprograms to open them. Or a program might abusively consume a very largeamount of bandwidth on a network.A memory leak is a special case of in-appropriate management of resources.Programs written in C, C++ and certain other languages can request memorybut not release it when it is no longer needed. If this occurs repeatedly and aprogram runs for an extended period of time, the computer can eventuallybegin to perform poorly or even run out of memory. To detect a memory leak,a tester has to run a program for an extended period, and use a utility (see thesidebar) that indicates the amount of memory being used. If the amount ofmemory steadily increases, this suggests that a memory leak is present.Although memory leaks are a widespread problem in languages such as C++,you can also get a similar effect in Java if you add objects to an instance of somecollection class, and then do not remove them when no longer needed – thegarbage collector only removes objects that are not referenced by any otherobject.
Defects in the process of recovering from a crash
DefectsAny system will undergo a sudden failure if its hardware fails, or if its power isturned off. When this occurs, it is a defect if the system is left in an unstable stateand hence is unable to recover fully once the power is restored or the hardware Lethbridge.book  Page 396  Tuesday, November 16, 2004  12:22 PM<page> 398Chapter 10
T esting and inspecting to ensure high quality 
10.7 Documentation defects
In the previous sections we have discussed how to detect classes of defects thatarise from errors on the part of designers. However, we pointed out at thebeginning of the chapter that a failure occurs any time a user has difficulty – andone source of difficulty is using the documentation. Y ou therefore need to ‘test’the documentation carefully.DefectThe software has a defect if the user manual, reference manual or online helpgives incorrect information or fails to give information relevant to a problem.T estingstrategyExamine all the end-user documentation (in both paper and online forms),m ak i n g  s u r e  i t  i s  c o rr ect .  I n  pa rti cul a r ,  m ak e  s u r e  i t  h a s  c o rr ect  so l u ti o n s  t oproblems that users might encounter, and correct instructions to help beginnerslearn how to use the software. Work through the use cases, making sure thateach of them is adequately explained to the user. Y ou should use the strategieswe discussed in Chapter 7 for evaluating usability: ask users to read thedocumentation and tell you what they do not understand or do not like.
10.8 Writing formal test cases and test plans
A test case is an explicit set of instructions designed to detect a particular classof defect in a software system, by bringing about a failure.A test case can give rise to many tests. Each test is a particular run of the testcase on a particular version of the system.A test plan is a document that contains a complete set of test cases for a system,along with other information about the testing process. The test plan is one ofthe standard types of documentation that should be produced in most softwareengineering projects. If a project does not have a test plan, then testing willinevitably be done in an ad-hoc manner, leading to poor quality software.The test plan should be written long before the testing starts. Y ou can start todevelop the test plan once you have developed the requirements. A set of usecases can help you design test cases, as discussed in Chapter 4.
Information to include in a formal test case
Each test case should have the following information:A.Identification and classification. Each test case should have a number, andmay also be given a descriptive title that indicates its purpose. The system,subsystem or module being tested should also be clearly indicated, with areference to the related requirements and design documents. Finally, theimportance of the test case should be indicated, as discussed in the nextsubsection.B.Instructions. These tell the tester exactly what to do. The instructions must tellthe tester how to put the system into the required initial state and what inputs Lethbridge.book  Page 398  Tuesday, November 16, 2004  12:22 PM<page> Section 10.8399Writing formal test cases and test plans
to provide. The tester should not normally have to refer to the specifications orto any other documentation in order to execute the instructions.C.Expected result. This tells the tester how the system should behave in responseto the instructions – i.e. what it should output and what state it should then bein. The tester reports a failure if he or she does not encounter the expectedresult.D.Cleanup (when needed). This tells the tester how to make the system go ‘backto normal’ or shut down after the test. For example, if a test case requires thatsome erroneous data be added to a database, then the cleanup section of thetest case would require that the data be deleted (or that the database bereloaded from a backup) so as not to disrupt future tests.Test cases can be organized into groups or tables, and some of the classificationinformation and instructions can be associated with an entire group, rather thanrepeated for each test case.It is becoming increasingly common to completely automate the testingprocess. Each test case then may become a method that throws an exception ifthe test fails. The same information described above would still be needed; forexample, the test case method would need to report an identification of whatfailed.
Levels of importance of test cases
It is a good idea to classify test cases according to their importance, or severitylevel. The most important test cases are executed first, and are designed to detectthe most severe classes of defect. A typical scheme for levels of importance is asfollows, although each organization may develop its own scheme:Level 1First pass critical test cases. These are designed to verify that the system runsand is safe. Any level 1 failure normally means that no further testing ispossible.Level 2General test cases. These verify that the system performs its day-to-dayfunctions correctly and is therefore a ‘success’ . A level 2 failure, while importantto fix, may still permit testing of other aspects of the system to continue in themeantime.Level 3Test cases of lesser importance. For example, these may test ‘cosmetic’ aspectsof the user interface such as the whether a button ormenu item is ‘grayed out’ when it cannot be used. Ifdesired, level 3 test cases can also be used to providesome redundancy – for example, extra testing ofadditional combinations of input. If there are manyfailures of level 3 test cases then the system canprobably be used, but is lacking in overall quality.
JUnit
JUnit is a Java frameworkfor automated testing. Itis becoming widely usedamong Java developers.See http://junit.org. Lethbridge.book  Page 399  Tuesday, November 16, 2004  12:22 PM<page> Section 10.9403Strategies for testing large systems
A better integration testing strategy in most cases is incremental testing. In this approach, you first test each individual subsystem in isolation, and thencontinue testing as you integrate more and more subsystems.The big advantage of incremental testing is that when you encounter a failure,you can find the defect more easily. Y ou know it is most likely to be in thesubsystem you most recently added.Incremental testing can be performed horizontally or vertically, depending on the architecture of the system. Horizontal testing can be used when the systemis divided into separate sub-applications, such as ‘adding new products’ and‘selling products’; you simply test each sub-application in isolation. However, forany sub-application that is complex, it is necessary to divide it up vertically intolayers.There are several strategies for vertical incremental testing: top-down,bottom-up and sandwich. The various strategies are illustrated in Figure 10.8.
Top-down testing
In top-down testing, you start by testing only the user interface, with theunderlying functionality simulated by stubs. Then you work downwards,integrating lower and lower layers, each time creating stubs for the layers thatremain un-integrated. As you integrate each lower layer, you test the system again.Stubs are pieces of code that have the same interface (i.e. API) as the lower-levellayers, but which do not perform any real computations or manipulate any realdata. Any call to a stub will typically immediately return with a fixed default value.If a defect is detected while performing top-down testing, the tester can bereasonably confident that the defect is in the layer that calls the stubs. It couldalso be in the stubs, but that is less likely since stubs are so simple.Figure 10.8Vertical strategies for incremental integration testingUI LayerFunctional layerFullyintegratedsystemUI LayerTop-down testingUI Layer
stub stub stub
UI Layer
Functional layer
stub stub stubUI Layer
DatabaselayerNetworklayerFunctional layer
Databaselayer Networklayerdriver driver driverDatabaselayer Networklayerdriver driver driverBottom-up testing
Functional layerUI Layer
Databaselayer NetworklayerUI Layer
stub stub stubSandwich testing
Databaselayer Networklayerdriver driver driver Lethbridge.book  Page 403  Tuesday, November 16, 2004  12:22 PM<page> 408Chapter 10
T esting and inspecting to ensure high quality 
normally involves users. We have already seen in Chapter 7 that users should beheavily involved in testing and evaluating prototypes. In this section we willdiscuss the involvement of users in testing versions of the system that are almostready to be put into production. Such testing should occur once the developersbelieve that the software has reached a sufficient level of quality (it isapproaching the quality targets specified in the non-functional requirements).Alpha testing is testing performed by users and clients, under the supervision ofthe software development team. The development team normally invites someusers to work with the software and to watch for problems that they encounter.Beta testing is testing performed by the user or client in their normal workenvironment. It can be initiated either at the request of the software developers,or at the request of users who want to try the system out. Beta testers are selectedfrom the potential user population and given a pre-release version of thesoftware. They know that the software will contain more defects than the finalversion, but they have the benefit of using the features of the software beforeothers have access to them. Beta testers are responsible for reporting problemswhen they discover them.The advantages of alpha and beta testing are the following. Y ou typically areable to have a much larger volume of testing performed, and the users use thesoftware in the same manner that they will use it when it is formally released.Very often, the users do things that the developers of the test plan neveranticipated; hence users encounter failures that no test case was written todetect. In the worst case, discovery of these defects during alpha and beta testingmay require major changes to the software – but it is better that the defects befound at this stage, rather than following the software’s general release.Some organizations rely very heavily on beta testing, and will release low-quality software to the general population in what is called an open beta release. If the software is in heavy demand, this can result in the effective discovery ofproblems. It may make economic sense to do this from the perspective of thedevelopers, but it is not good engineering practice. It results in wasted time onthe part of the users, since many people will discover the same problems. It canalso damage the reputation of the developers if many failures occur.Acceptance testing, like alpha and beta testing, is performed by users andcustomers. However, the customers do it on their own initiative – to decidewhether software is of sufficient quality to purchase. Many large organizations alsoperform acceptance testing before they will pay a developer they have contractedto develop custom software for them. Other organizations use acceptance testingin order to choose between several competing generic products.
ExerciseE206
Discuss how integration testing could be performed in the SimpleChat system.What stubs or drivers could be written to permit separate testing of individuallayers?  Lethbridge.book  Page 408  Tuesday, November 16, 2004  12:22 PM<page> 416Chapter 10
T esting and inspecting to ensure high quality 
Any practicing software engineer should have a good understanding of thesestandards and their suitability for his or her organization.
10.12 T est cases for phase 2 of the SimpleChat instant messaging system
On the book’s web site (http://www.lloseng.com) you will find a complete set oftest cases to test Phases 1 and 2 of SimpleChat. The following is a selection ofthose test cases.
General setup for test cases in the 2000 series
System: SimpleChat/ocsf Phase: 2Instructions:1.Install Java, minimum release 1.2.0, on Windows 95, 98 or ME.2.Install Java, minimum release 1.2.0, on Windows NT or 2000.3.Install Java, minimum release 1.2.0, on a Solaris system.4.Install the SimpleChat – Phase 2 on each of the above platforms.
Test Case 2001System: SimpleChat Phase: 2Server startup check with default argumentsSeverity: 1Instructions:1.At the console, enter: 
java EchoServer .Expected result:1.The server reports that it is listening for clients by displaying the followingmessage:
Server listening for clients on port 5555
2.The server console waits for user input.Cleanup:1.Hit 
ctrl+c to kill the server.
Test Case 2002System: SimpleChat Phase: 2Client startup check without a loginSeverity: 1Instructions:1.At the console, enter: 
java ClientConsole . Lethbridge.book  Page 416  Tuesday, November 16, 2004  12:22 PM<page> Section 10.12417T est cases for phase 2 of the SimpleChat instant messaging system
Expected result:1.The client reports it cannot connect without a login by displaying:
ERROR – No login ID specified. Connection aborted . 2.The client terminates.Cleanup: (if client is still active)1.Hit 
ctrl+c to kill the client.
Test Case 2003System: SimpleChat Phase: 2Client startup check with a login and without a serverSeverity: 1Instructions:1.At the console, enter: 
java ClientConsole <loginID>  where <loginID>  is the name you wish to be identified by.Expected result:1.The client reports it cannot connect to a server by displaying:
Cannot open connection. Awaiting command.
2.The client waits for user inputCleanup: (if client is still active)1.Hit 
ctrl+c to kill the client.
Test Case 2007System: SimpleChat Phase: 2Server termination command checkSeverity: 2Instructions:1.Start a server (Test Case 2001 instruction 1) using default arguments.2.Type 
#quit  into the server’s console.Expected result:1.The server quits.Cleanup: (If the server is still active):1.Hit 
ctrl+c to kill the server.
Test Case 2013System: SimpleChat Phase: 2Client host and port setup commands check Lethbridge.book  Page 417  Tuesday, November 16, 2004  12:22 PM<page> 418Chapter 10
T esting and inspecting to ensure high quality 
Severity: 2Instructions:1.Start a client without a server (Test Case 2003).2.At the client’s console, type 
#sethost <newhost>  where <newhost> is the name of a computer on the network.3.At the client’s console, type 
#setport 1234 .Expected result:1.The client displays
Host set to: <newhost>Port set to: 1234
.Cleanup:1.Type 
#quit  to kill the client.
Test C as e 2016System: SimpleChat Phase: 2Multiple remote client disconnections and re-connectionsSeverity: 2Instructions:1.Start a server (Test Case 2001, instruction 1).2.On different computers, start clients (1 or 2 per computer) and connectthem to the server.3.Exchange data among all the clients and the server.4.Close the server using the 
#close  command.5.Change the server’s listening port by using the 
#setport <newport>  command. 6.Restart the server using the 
#start  command.7.Change the ports of the clients, using 
#setport , to correspond to the new port of the server.8.Reconnect the clients to the server by using the 
#login <loginID>  command. Expected results:1.The first set of connections occur normally.2.When the server is closed, all clients are disconnected.3.The server displays the following message when the 
#setport  command is used:
port set to: <newport> . Lethbridge.book  Page 418  Tuesday, November 16, 2004  12:22 PM<page> Section 10.12419T est cases for phase 2 of the SimpleChat instant messaging system
4.The server restarts and displays:
Server listening for connections on port <newport> . 5.The clients change port as in Test Case 2013.6.The clients reconnect normally.Cleanup:1.Type 
#quit  to kill the clients.2.Type 
#quit  to kill the server.
Test Case 2017System: SimpleChat Phase: 2Client changing hostsSeverity: 2Instructions:1.On two different computers, start servers on the default port.2.On a third computer, start a client and connect it to one of the two servers.3.Logoff from that server using the 
#logoff  command.4.Change the host name by using the 
#sethost <otherhost>  where <otherhost>
is the name of the computer running the other server.5.Log the client on again using the 
#login <loginID>  command. Expected results:1.The two servers start up normally.2.The client connects to the first server normally.3.When the client disconnects it displays
Connection closed .4.When the client disconnects, the server displays:
<loginID> has disconnected .5.The client changes host as in Test Case 2013.6.The client reconnects normally as in Test Case 2016.Cleanup (Unless proceeding to Test Case 2018):1.Type
 #quit  to kill the servers.2.Type 
#quit  to kill the client. Lethbridge.book  Page 419  Tuesday, November 16, 2004  12:22 PM<page> Section 10.14421Summary
something measurable to improve. Have developers and maintainers work forseveral months on a testing team; this will heighten their awareness of qualityproblems they should avoid when they return to designing software.
10.14 Summary
In this chapter we have given you an overview of several important strategiesfor efficiently verifying that a system is of sufficient quality, as well as forsupporting quality development more generally.We discussed key terminology, in particular that human errors causedefects, and defects cause failures.We then looked at strategies for testing. Black-box testing allows you onlyto control a system’s inputs and observe its outputs, whereas glass-box (orwhite-box) testing allows you to examine the system’s internals. Big bangtesting involves testing an integrated system all at once, whereas incrementalapproaches to integration testing involve first testing individual subsystems,and then testing repeatedly as subsystems are put together to create thecomplete system.Testing a selected member of each equivalence class, as well as equivalenceclass boundaries, allows you to detect different defects without exhaustivelytrying all possible inputs. However, determining suitable equivalence classesis hard. In particular, it is necessary to apply knowledge of the most commontypes of defects and program design strategies. Typical types of defects toseek include algorithmic defects (such as incorrect logical conditions, or nothandling null conditions), defects in which the system cannot handle stress,and defects resulting from failure to adhere to standards.We discussed how to systematically write both test cases and complete testplans, and to consider test-first development where an automated test planis used to drive development. We also pointed out that it is important to planin advance when to stop testing. In addition, we looked at regression testing,which is testing with a subset of tests when the system is changed, alphatesting, which is testing by users under the supervision of developers, andbeta testing, which is testing by users in their own environment.Inspections are another way of verifying software that should be used inconjunction with, and prior to, testing. We suggested a strategy forinspection that involves a team. Team members include the author, aparaphraser and a moderator. The paraphraser proceeds through the codeor other documents, explaining the material in his or her own words. ThePersonal Software Process is a disciplined approach to individual softwaredevelopment that, among other things, emphasizes careful inspection ofyour own work.Finally, we looked at quality assurance as a whole, including the notion ofcontinuous improvement. Lethbridge.book  Page 421  Tuesday, November 16, 2004  12:22 PM<page> 424Chapter 10
T esting and inspecting to ensure high quality 
created your test plan, use it to test your work, recording any failures when theyoccur. (Suggestion: test the work of another group while they test your work.)
E210 Perform a root cause analysis of the failures you encountered in the lastexercise.
E211 S tr ess test the Sim pleCha t p r ogram b y ha ving a very large n umber o f peo pleconnect clients to the same server and issue many different commands. Try todetermine the capacity of the server (or the network) before it slows down to anunacceptable level of performance. Write a summary of your experiences.
E212 Create a complete set of test cases for the Small Hotel Reservation System. Lethbridge.book  Page 424  Tuesday, November 16, 2004  12:22 PM<page> 426Chapter 11
Managing the software process 
3.Ensuring there are suitable people to undertake the project . This includes finding people, and ensuring that people have appropriate training. It can alsoinclude firing people who are not performing adequately.4.Defining responsibilities. Determining how people will work together inteams and who will be responsible for what. Teams are the subject ofSection 11.4.5.Scheduling. Determining the sequence of tasks, plus setting deadlines forwhen tasks must be complete. Major deadlines are called milestones. Scheduling is discussed in Section 11.5.6.Making arrangements for the work. Initiating the paperwork involved inhiring or subcontracting; setting up training courses; finding office space;ensuring that hardware and software is available; ensuring that people have therequisite security clearance, etc.7.Directing. Telling subordinates and contractors what to do. Many of the otheractivities in this list involve making decisions; but acting on those decisions byordering people to do things is a distinct activity. Directing is not as simple asissuing orders – you have to get people to commit to deliver what they promise.8.Being a technical leader. Giving advice about engineering problems; helpingpeople solve problems by leading discussions; pointing people to appropriatesources of information; acting as a mentor, and making high-level decisionsabout requirements and design.9.Reviewing and approving decisions made by others . In certain types of projects, the project manager will have to take the ultimate legal responsibilityfor declaring that proper engineering practice has been followed, and that themanager believes the resulting system will be safe. However, a certain amountof reviewing and approving is a part of every project.10.Building morale and supporting staff. Helping resolve interpersonalconflicts; ensuring that people feel rewarded, respected and motivated; givingpeople feedback to help them improve their work; and ensuring that peoplealways have somebody to talk to about problems.11.Monitoring and controlling. Finding out what is going on, determining howthe plans need to change, and taking action to keep the project on track. Therisk management process, which we have talked about throughout this book, isa central aspect of this.12.Co-ordinating the work with managers of other projects . 13.Reporting. Telling customers and higher-level managers what they need andwant to know.14.Continually striving to improve the process. Lethbridge.book  Page 426  Tuesday, November 16, 2004  12:22 PM<page> 430Chapter 11
Managing the software process 
The phased-release model
The phased-release model of software development, shown in Figure 11.3,rectifies some, but not all, of the problems of the waterfall model. The mostimportant change is that it introduces the notion of incremental development. It suggests that, after requirements gathering and planning, the project should bebroken into separate subprojects, or phases. Each phase can then be released tocustomers when ready. Parts of the system will be available earlier than wouldhave been possible when using a strict waterfall approach.
The phased-release model still retains some of the important weaknesses ofthe waterfall model. It continues to suggest that all requirements be finalized atthe start of development, and it continues to downplay the possibility ofprototyping. When the time comes to develop Phase 2, and subsequent phases,the design is based on the original specifications – in other words, the modeldoes not facilitate learning lessons from Phase 1, which could result inimprovements to subsequent phases.
The spiral model
The spiral model, as shown in Figure 11.4, is another view of incrementaldevelopment that explicitly embraces prototyping and an iterative approach to software development. This model takes the position that you should start toFigure 11.3The phased-release modelV&VPlanningV&VSpecificationV&VRequirementsgathering anddefinition
V&VIntegration anddeploymentV&VImplementationV&VDesignPhase 1
V&VIntegration anddeploymentV&VImplementationV&VDesignPhase 2 Lethbridge.book  Page 430  Tuesday, November 16, 2004  12:22 PM<page> Section 11.2431Software process models
develop software by developing a small prototype (innermost loop of the spiral).This first prototype follows a mini-waterfall process, but is very quicklydeveloped and serves primarily to gather requirements. The last stage of thisinner loop is review, or evaluation, of the first prototype.Project managers embrace the spiral model because it acknowledges one ofthe most famous quotations in software engineering. It was Fred Brooks whosaid, ‘The question is not whether to build a pilot system and throw it away. Y ouwill do that. The question is whether to plan in advance to build a throwaway. ’In subsequent loops of the spiral, the project team performs furtherrequirements, design, implementation and review. There may be several cyclesof prototyping; however, subsequent cycles become official releases.Before each cycle of the spiral ends, a review is held. At this review, thestakeholders discuss their experiences with the previous release and decidewhether to proceed to another cycle.The spiral model also adds the notion of risk analysis to process modeling.The first thing to do before embarking on each new loop of the spiral is to decidewhat are the major difficulties to be handled. After determining these, you thenmake adjustments to the architecture, the requirements or the project plan asnecessary.When following the spiral model, a project undergoes a large number ofcycles. The cycling only ends when the system is finally retired. This modeltherefore incorporates the idea that maintenance is simply a type of ongoingdevelopment.
The evolutionary model
The evolutionary model (Figure 11.5) shows software development as a series ofhills, each representing a separate loop of the spiral. This is a third way ofthinking about incremental development.This model shows two things that are not always clear from the spiral model.First, it shows that loops, or releases, tend to overlap each other. As testing andFigure 11.4The spiral modelRequirementsSpecificationDesign ImplementationPrototypeRelease 1Release 2ReviewAnalysis of riskIntegration anddeployment Lethbridge.book  Page 431  Tuesday, November 16, 2004  12:22 PM<page> Section 11.3435Cost estimation
performed by the community: those interested in the project scrutinize andcriticize any suggested contributions.
Choosing a process model
When planning a particular project, the important thing to recognize is that youcan combine the features of the models that apply best to your current project.From the waterfall model, you will always incorporate the notion of stages,but you will most likely want to avoid having a single cascade ending inmaintenance.From the phased-release model, you can incorporate the notion of doingsome initial high-level analysis, and then dividing the project into releases. Y oucan also incorporate the notions of prototyping and risk analysis from the spiralmodel.Next, from the evolutionary model you can incorporate the notion of varyingamounts of time and work, with overlapping releases. And from the concurrentengineering model, you can break the system down into components anddevelop them in parallel.Finally, even if you are developing a large system, you can adopt many of thefeatures of the agile model: smaller releases, on-site users, test-first developmentand frequent refactoring can all be adopted in projects both large and small.
Re-engineering
No matter what process model you use, in any large or long-lived project, thedesign will deteriorate. Periodically, therefore, project managers should setaside some time to re-engineer part or all of the system. The extent of this workcan vary considerably: it could include cleaning up the code to make it morereadable, completely replacing a layer, or refactoring part of the design.In general, the objective of a re-engineering activity is to increasemaintainability. It should not normally involve adding any new features forusers, but should make the system more flexible so that adding such features inthe future becomes easier.Although periodic re-engineering will reduce long-term costs, it is often hardto convince managers and customers of this. Y ou need to present them with adetailed analysis of how much the re-engineering will cost, and what costsavings will result. As with many aspects of software engineering, you shouldfollow the 80–20 rule: you can get 80 per cent of the benefits of re-engineeringwith only 20 per cent of the work, therefore focus re-engineering efforts on theparts of the system most in need of it.
11.3 Cost estimation
One of the biggest challenges in software engineering is accurately forecastinghow much time and effort it will take either to develop a system, or to make aspecific set of changes. All software developers have to participate in cost Lethbridge.book  Page 435  Tuesday, November 16, 2004  12:22 PM<page> 436Chapter 11
Managing the software process 
estimation, no matter whether they are the managers orarchitects of a large system, or whether they are theengineers responsible for the design and programmingof a single component.There is an old cliché that ‘time is money’ . In softwareproject management, this is literally true. When youestimate the cost of doing some work, you focus onestimating how much software-engineering time willbe required. However, there are two distinct aspects oftime. The first is elapsed time; this is the difference intime from the start date to the end date of a task orp r o ject. Th e seco n d a s pect o f tim e i s p r o ba b l y bet t ercalled development effort (or simply effort); this measures the amount of labor used and is expressed inperson-months or person-days.When planning a project, you budget a certainamount of effort for each task, and you schedule the start and end times forthat task. If you schedule a task to take two weeks of elapsed time, but take sixperson-weeks of effort, that means that you must also ensure that an averageof three people are working on the task at any given point in time.The elapsed time of a project is important – you might have a contractualobligation to deliver software by a certain day, or you might want to ensurethat your product reaches the market before the competition. However, theactual cost of a project is primarily a function of development effort.To convert an estimate of development effort to an amount of money, youmultiply it by the weighted average cost (also called the burdened cost) of employing a software engineer for a month (or a day). The weighted averagecost not only includes the average salary of a software engineer, but also thecost of providing that person with benefits, an office, a desk, a computer aswell as technical and managerial support. The weighted average cost istherefore often two to three times average salary.
Example 11.1 In your organization, although the average salary is $4,000 /month, the weightedaverage salary for cost estimation purposes is $11,000/month. You havedetermined that a particular project will take 7 person-months to complete. Howmuch would you estimate this project will cost financially? Y ou estimate that the project will cost 7×$11,000 = $77,000.
Principles of effective cost estimation
Cost estimation is notoriously difficult, as witnessed by the large number ofprojects that are completed behind schedule and over budget, or are notcompleted at all. There are several key principles that can help you to makebetter estimates. These can be applied whether you are estimating the time foryour personal work, or for an entire project.Chaos in project management
The Standish Group’s reports onproject management chaos containsome of the most respected statisticsabout software project failures.According to the Standish Group, theaverage project exceeds its budget by90%, and its schedule by 120%.Furthermore, over 30% of projectsare canceled before completion. Inthe United States alone, thisrepresents about $100 billion inwasted money per year. See http://www.standishgroup.com. Lethbridge.book  Page 436  Tuesday, November 16, 2004  12:22 PM<page> Section 11.3437Cost estimation
Cost Estimation Principle 1: Divide and conquer
In Chapter 9, we said that divide and conquer was one of the essential principlesof design. In Chapter 10, we said it also applies to testing. It turns out to be justas important to cost estimation.If you try to estimate the entire cost of a project as a single number, you arelikely to be very inaccurate. To make a better estimate, you should divide theproject up into individual subsystems, and then divide each subsystem furtherinto the activities that will be required to develop it. Next, you make a series ofdetailed estimates for each individual activity, and sum the results to arrive at thegrand total estimate for the project.Although your detailed estimates may be inaccurate, your final estimate willbe more accurate, for two reasons. Firstly, you will be more likely to account forall the subsystems and activities. Secondly, if you underestimate the timerequired for some subsystems or activities, this should be at least partlycompensated for by overestimates in other places.Although it will help you improve estimates, the divide and conquer principleis not a panacea. Y ou might miss activities or systematically underestimate eachactivity, leading to a total estimate that is too low. The other principles listedbelow will help to combat this.
Cost Estimation Principle 2: Include all activities when making estimates
If you do not appreciate the amount of effort required for certain activities, oromit them entirely, then your estimate of total effort will be too low.For example, when asked to estimate the cost of a new feature for SimpleChat,a beginner might focus primarily in the amount of time required to write therequirements document and the code. However, the time required for all development activities must be taken into account, including prototyping,design, inspecting, testing, debugging, writing user documentation anddeployment.
Cost Estimation Principle 3: Base your estimates on past experience combined with what you can observe of the current project
The only way to predict the future is to reason by analogy with the past. If youare developing a project that has many similarities with a past project, then youcan expect it to take a similar amount of work.In practice, no two projects are the same. However, the more you followPrinciple 1 and divide the estimation task into fine-grained detailed estimates,the more likely you are to be able to find similarities with aspects of pastprojects.There are two general strategies for using past experience. The first is to baseyour estimates purely on the personal judgment of experts within your team. Suchpeople will have worked on other projects and can extrapolate their experience tothe current project. The second strategy is to use algorithmic models that havebeen developed in the software industry as a whole by analyzing a wide range of Lethbridge.book  Page 437  Tuesday, November 16, 2004  12:22 PM<page> Section 11.3439Cost estimation
A typical algorithmic model uses a formula such as the following:E = a + bN
c
In this formula, E is the effort estimate and N is the estimate or measure beingused as the basis for the effort estimate (e.g. number of use cases or lines ofcode). The values a, b and c are obtained by extensive analysis of past projects,and determinations of the differences that will effect the current project (thesewill be discussed in Cost Estimation Principle 4).The exponent c is particularly interesting. If it is not equal to one, it meansthat the effort increases non-linearly. If c < 1, there would be economies of scale as a project gets larger, which turns out not to be the case in software. In realprojects c > 1, which means that the effort grows increasingly rapidly relative toproject size; this is due to the increasingly large amount of co-ordination andcomplexity involved.Figure 11.7 shows the effect of typical values of the c parameter used by one of the best-known algorithmic cost estimation models, COCOMO II(COnstructive COst Model, version II). COCOMO II computes effort, inperson-months, from an estimate of size, measured in lines of code.
Another important algorithmic method is Function Point Analysis. In this approach, and several related approaches, you count features of therequirements and use these to compute an estimate of the system’s size. Y ou canthen apply COCOMO to the size estimates.The basic equation used by approaches like Function Point Analysis is:S = W
1F1 + W2F2+W3F3 +… The F
i represent counts of features of the requirements such as number ofinputs, number of tables in the database, number of use cases etc. These countsare multiplied by weights (the W
i values) calculated using industry-wideexperience. The results are summed to produce a system size, S. To find out more about Function Points and COCOMO, see the references inthe ‘For more information’ section at the end of the chapter.Figure 11.7Effect of non-linearity in cost estimation12345
0
50100150200250300350400
Thousands of Lines of Source Code (KLOC)Thousands of person-monthsc=1.06c=1.26c=1.16 Lethbridge.book  Page 439  Tuesday, November 16, 2004  12:22 PM<page> 442Chapter 11
Managing the software process 
(0.01), no involvement of the client in the process (0.00), little risk analysis carriedout (0.04), a relatively good team of developers (0.02) and an average processmaturity (0.03). Use this data to compute a cost estimate in person-months.The exponent value will be 1.01+0.10 = 1.11. The effort would then be2.4×4.3
1.11 = 12.1 person months.
Example 11.5 Looking up in COCOMO II tables, you find that the following multiplicativefactors need to be applied to adjust the value of the b (multiplicative) parameter: (a) Personnel factor: your team has good experience with the programminglanguage to be used: 0.95(b) Product factor: the system will be running under very tight memoryconstraints: 1.21(c) Project factor: you have to put up with a schedule that is a bit tight: 1.04(d) Platform factor: particularly high reliability is required: 1.4Revise your effort estimate from Example 11.4, given this new data, and convertthe result to dollars.The effort estimate is 0.95×1.21×1.04×1.4×12.1 = 20 person-months, for a costof 20×$11,000 = $220,000.
ExerciseE214
Using your judgment, what would be reasonable multiplicative parameters forthe following (you could do this with reference to the COCOMO IIdocuments).(a) Personnel factor: your team has in the past developed many similarapplications.(b) Product factor: the system includes a particularly large database.(c) Project factor: some of your development team will be located in the US,some in Canada, some in India and some in South Africa.(d) Platform factor: the application will run under the Linux operating system.
Cost Estimation Principle 5: Anticipate the worst case and plan for contingencies
In accordance with Murphy’s Law, if something can go wrong in a project, itprobably will. For example, you might have difficulty deciding on therequirements; there might be unexpected technical challenges in the designprocess; or somebody might quit or not perform up to expectations. One way to plan for contingencies is to prioritize all the use cases accordingto their benefit to the customer. If, as the project progresses, your revised cost Lethbridge.book  Page 442  Tuesday, November 16, 2004  12:22 PM<page> 444Chapter 11
Managing the software process 
ExerciseE215
Evaluate the cost estimates presented in Example 11.6; discuss potentialsources of error in these estimates. 
E216 Search the Internet for the source code of an open-source Java project (you canalso select a package from the Java API). Then do the following:(a) Compute some basic metrics: the average number of attributes andmethods per class; and the average number of lines per method.(b) Imagine you are planning to add a new subsystem of 40 classes very similarto the system you have studied. Use the numbers computed in part a) toderive likely, optimistic and pessimistic estimates for the number of lines ofcode you would expect to find in this system.(c) Use the COCOMO approach discussed earlier to arrive at optimistic, likelyand pessimistic estimates for the effort required to develop the subsystem. 
Cost Estimation Principle 6: Combine multiple independent estimates
No matter how good your estimation process, you are likely to have overlookedsome factors that will affect the accuracy of your estimate.Y ou should therefore use several different techniques and compare the results.If there are discrepancies, you can analyze your calculations to discover whatfactors are causing the differences. For example, you can make one estimatebased on your experience with a similar project; you can then use COCOMO orFunction Points to make a second estimate.A well-respected approach to making multiple estimates is the Delphitechnique. To use this technique, several individuals initially make costestimates in private. They then share their estimates to discover thediscrepancies. Each individual repeatedly adjusts his or her estimates until aconsensus is reached.
Example 11.7 Discuss the discrepancies between the cost estimates presented in Examples 11.2and 11.5, and suggest a course of action.The estimate of $176,000 from example 11.2 was based purely on extrapolatingfrom this organization’s typical costs per class developed. The $220,000 estimateof example 11.5 was based on a much more sophisticated sequence ofcomputations, with a lines-of-code estimate as an intermediate value. Inparticular, the specific attributes of the current project that differentiate it from previous projects were taken into account. Y ou should probably therefore putmore weight on the second estimate, although it has one weakness: some factorsused in the calculations were based on industry-wide data, not your owncompany’s data. Lethbridge.book  Page 444  Tuesday, November 16, 2004  12:22 PM<page> Section 11.5449Project scheduling and tracking
The roles listed above require specific skills and knowledge. The projectmanager can either select people with appropriate background, or ensure thatpeople obtain appropriate training. The project manager should also ensure thatall team members continue to augment their education in software engineering,as well as in general skills such as leadership, technical writing, and runningmeetings. 
ExercisesE218
Discuss what you think the best team structure would be for each of thefollowing projects:(a) The replacement of the income tax system of a country.(b) The GANA software, whose requirements we introduced in Chapter 4.(c) The control software for a new interplanetary probe.(d) Software to provide a more useful front-end to a university registrationsystem, so that students can make better choices of courses.
E219 Design a team for implementing Release 1 of the GANA software whose costyou estimated in Exercise E217. Specify an appropriate team structure, thenumber of people you believe should be on the team, how the team structurewould evolve as the project progresses, and the skills you believe teammembers should have. 
11.5 Project scheduling and tracking
Scheduling is the process of deciding in what sequence a set of activities will beperformed, as well as when they should start and be completed. Tracking is theprocess of determining how well you are sticking to the cost estimate andschedule.Two types of diagram are particularly important in scheduling: PERT charts and Gantt charts. Earned value charts are useful for tracking. In this section, wewill show you how to use all three diagram types. A variety of commercial toolsare available to help draw these diagrams.
PERT charts
A PERT chart shows the sequence in which tasks must be completed. Each taskhas zero or more predecessors on which it depends, and zero or moresuccessors, which depend on it. The whole diagram therefore forms a graph,whose nodes are tasks, and whose arcs are dependencies.In each node of a PERT chart, you typically show the elapsed time and effortestimates. Y ou can also show optimistic, likely and pessimistic estimates. Lethbridge.book  Page 449  Tuesday, November 16, 2004  12:22 PM<page> 450Chapter 11
Managing the software process 
One of the most important uses of a PERT chart is todetermine the critical path. The critical path indicatesthe minimum time in which it is possible to completethe project. It is computed by searching for the paththrough the chart that has the greatest cumulativeelapsed time and no idle time. If any task on the criticalpath is delayed, then the completion date of the projectwill be delayed.Figure 11.9 shows a PERT chart for Release 2 of the GANA system,corresponding to the cost estimates in Example 11.6. Note that some of the taskshave been broken down into subtasks. Each task box shows both the expectedelapsed time, in weeks, as well as the expected effort in person-months. Thecritical path is shown in bold. Y ou can calculate the minimum elapsed time (35weeks) by summing the elapsed times on this path.
Gantt charts
A Gantt chart is used to graphically present the start and end dates of eachsoftware engineering task. A Gantt chart is like a UML sequence chart: one axisshows time and the other axis shows the activities that will be performed.Figure 11.10 shows a Gantt chart for Release 2 of the GANA system. The blackbars are the top-level tasks; the white bars are subtasks, and the diamonds aremilestones – important deadline dates, at which specific events may occur.Note how requirements gathering and prototyping overlap each other. Alsonote that inspection can be started as soon as the first parts of theimplementation are complete, and testing can start as soon as some inspectionis complete.This chart does not yet show the allocation of people to the tasks. Nor have wechosen to show the breakdown of implementation and testing by layer; thislatter detail can be added once requirements are clearer.Figure 11.9A PERT chart for Release 2 of the GANA systemDesign8 wk/6 pmRequirementsgathering7 .5 wk/3 pm
Prototyping5 wk/3 pmSpecification2.5 wk/1.5 pmImplementationnetwork layer6 wk/3 pmImplementationUI layer3 wk/1.5 pm
InspectionUI layer0.5 wk/0.5 pmInspectionnetwork layer0.5 wk/0.75 pmInspectionfunctional layer0.5 wk/0.75 pm
Unit test and fixUI layer2 wk/1 pmUnit test and fixnetwork layer3 wk/1.5 pmUnit test and fixfunctional layer3.5 wk/2 pm
Integrationtest and fix2.5 wk/1 pmIntegration withhardware1 wk/0.5 pmTest plandevelopment5.5 wk/2 pmImplementationfunctional layer8 wk/3.5 pm
Systemtest1.5 wk/1 pmPERT
PERT stands for ‘Program EvaluationReview T echnique’ and is very similarto techniques called the ‘Critical PathMethod’ and ‘Precedence Networks’. Lethbridge.book  Page 450  Tuesday, November 16, 2004  12:22 PM<page> 452Chapter 11
Managing the software process 
ExercisesE220
Draw a PERT and a Gantt chart for the project to develop Release 1 of theGANA software, whose cost you estimated in Exercise E217. Make sure youshow the critical path on your PERT chart. 
E221 In light of the last exercise, review your proposed cost estimate and teamstructure for the GANA system. Explain any changes you would make. 
11.6 Contents of a project plan
Y ou should write a project plan document that has the following types ofinformation. This document should be regularly updated as the projectprogresses. As with other documents, when writing a project plan, be conciseand understand the audience. The audience will be all the team members, thecustomers, the project managers of related projects, anybody else who has toimplement aspects of the plan, and anybody who has to take over as projectmanager for any reason.Figure 11.11Earned value chart showing how development of Release 2 of the GANA system was 8 weeks behind schedule and cost 10 person-months more than expected04 8 1 2 1 6 2 0 2 4 2 8 3 2 3 6 4 0The project is6 weeks behindschedule atweek 23The completed workis 2 person-monthsover budget atweek 23PlannedelapsedtimeActualelapsedtimeActualeffortBudgetedeffort
Elapsed time (weeks)Effort (person-months)4035302520151050Budgeted cost of work scheduledEarned valueActual cost of work performed Lethbridge.book  Page 452  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 458  Tuesday, November 16, 2004  12:22 PM<page> 1212Review 
We have incorporated nine themes into many of the chapters in this book. Thesethemes will serve in this chapter as a way to gather together and relate many ofthe concepts we have discussed.
12.1 Theme 1: Understanding the customer and user
We have emphasized in this book that software engineers must continuallyfocus on the customers and users. Customers are those who pay, while users arethose who use. In some cases they are the same people, but often not.The definition we gave of software engineering from Chapter 1 placescustomers at the center – we must ensure that everything we do is directedtowards solving their problems.Solving customers’ problems is difficult: software engineers must spendconsiderable effort trying to understand their problems and then developrequirements that address the problems. Techniques for doing this werediscussed in detail in Chapter 4; these include domain analysis, interviewing,brainstorming, use case analysis and prototyping.In Chapter 7, we focused on the users. Unless the users can learn the softwareeffectively, and work efficiently with it, the customer’s problem will not beadequately solved. We emphasized that involving users in all activities, anddesigning the user interface effectively, will ensure that both utility and usabilityare maximized.
12.2 Theme 2: Basing development on solid principles and reusable technology
We have emphasized throughout the book that software engineering is anengineering activity. Like other engineers, a software engineer solves problemsby applying well-understood knowledge and technology in a disciplined way.However, the types of knowledge and technology required for the differentengineering disciplines differ: other engineers design artifacts made of atomsand are subject to the laws of physics, whereas software engineers design Lethbridge.book  Page 459  Tuesday, November 16, 2004  12:22 PM<page> Section 12.2461Theme 2: Basing development on solid principles and reusable technology
2. Ensure users are involved in decision-making processes3. Have users work with, and give feedback about, prototypes of the system and documentation4. Design the user interface following guidelines for good usability (such as those below)Principles that lead to good usability (Chapter 7)1. Do not rely only on usability guidelines – always test with users2. Base UI designs on users’ tasks, as expressed in use cases3. Ensure that the sequences of actions to achieve a task are as simple as possible4. Ensure that the user always knows what he or she can and should do next, and what will happen when he or she does it5. Provide good feedback including effective error messages6. Ensure that the user can always get out, go back or undo an action7. Ensure that response time is adequate8. Use understandable labels and other encoding techniques9. Ensure that the UI’s appearance is neat and uncluttered10.Consider the needs of different groups of users11.Provide all necessary help12.Be consistentPrinciples for making good design decisions (Chapter 9)1. Use priorities and objectives to decide among alternatives2. Use cost–benefit analysis to choose among alternativesPrinciples of effective design (Chapter 9)1. Divide and conquer2. Increase cohesion where possible3. Reduce coupling where possible4. Keep the level of abstraction as high as possible5. Increase reusability where possible6. Reuse existing designs and code where possible7. Design for flexibility8. Anticipate obsolescence9. Design for portability10.Design for testability11.Design defensivelyPrinciples of testing (Chapter 10)1. Treat testing like detective work: be suspicious of everything2. Be both effective and efficient while testingT able 12.1Summary of software engineering principles presented in this book (cont.) Lethbridge.book  Page 461  Tuesday, November 16, 2004  12:22 PM<page> Section 12.2463Theme 2: Basing development on solid principles and reusable technology
T able 12.2The patterns discussed in this book Type of pattern DescriptionDesign patterns (Chapter 6)Abstraction–Occurrence Represents abstract sets and their occurrences, while avoiding duplication of informationGeneral Hierarchy Represents hierarchies of objects (as opposed to hierarchies of classes)Player–Role Allows an object to change roles or play multiple roles, avoiding multiple inheritanceSingletonGuarantees that a certain class can have only one instanceObserverReduces coupling by ensuring that an object can communicate with others without knowing their classDelegationReduces coupling and increases reusability by providing methods that do nothing but call methods in neighboring classesAdapterImproves reuse and flexibility by translating the interface of a class so that its facilities can be used polymorphicallyFaçadeProvides a simplified interface for a subsystem, reducing couplingImmutableAllows you to create instances that cannot be changedRead-only Interface Allows you to select which classes can modify instances of a given classProxyProvides a lightweight stand-in for a heavyweight objectFactoryAllows a framework to create instances of an application-specific classArchitectural patterns (Chapter 9)Multi-LayerAdds flexibility by separation of concerns: in particular, ensuring that the user interface is kept separate from the functional layerClient–Server The simplest pattern for distributed computing (discussed in detail in Chapter 3)BrokerTransparently distributes aspects of a software system to different nodes Transaction Processing Provides a uniform interface for handling transactions, permitting easy addition of new types of transactionPipe-and-Filter Divides the system into units where input data is in a relatively simple form, and output data in a similar form, so that sets of the units can be chained together in different waysModel–View–Controller Builds on the multi-layer pattern, allowing for separation of concerns within the user interfaceService-Oriented Enables creation of applications that call on distributed services available on the Internet using standard protocols, and which return their results as XML documentsMessage Oriented Allows applications to be built that communicate transparently through ‘topics’ to which other applications or subsystems may subscribe Lethbridge.book  Page 463  Tuesday, November 16, 2004  12:22 PM<page> 464Chapter 12
Review 
Frameworks are skeletal applications or subsystems on which many differentapplications can be built. They contain the essential services needed by a classof systems. Software engineers adapt them to the needs of a particular system bywriting code that fills slots (required functionality missing from the framework)or hooks (places where the system explicitly anticipates you may want to addextensions). The code written to fill slots and hooks will call the services of theframework.Since the designers of frameworks have already done much of the hard work,developing applications based on them should be much easier than designingfrom scratch.
12.3 Theme 3: Object orientation
We introduced the basic principles of object orientation in Chapter 2. Wepointed out that an object-oriented system benefits from the synergy arising outof abstraction, inheritance and polymorphism. Under the object-orientedparadigm, both data and procedural abstractions are grouped together into thecohesive units, the classes.In Chapter 3, we presented the OCSF as an illustration of an object-orientedframework. In Chapters 5 and 6 we discussed class diagrams and patterns,which provide abstract views of the static relationships among classes in asystem. Chapter 8 presented several other diagrams that can be used to describethe dynamic aspects of an object-oriented system. In Chapter 9 we showed howobject-oriented principles help to achieve better design.
12.4 Theme 4: Visual modeling using UML
All engineers model their products visually. Mechanical engineers and civilengineers have an advantage: since their products are very tangible, most oftheir diagrams are direct projections of their finished products. Softwareengineers, in a similar manner, draw pictures of their user interfaces. However, like electrical engineers with their circuit diagrams, softwareengineers have to do most of their diagramming using notations that representabstractions of their product. Over the 50-year history of computing, manydifferent types of diagram have been used to represent software, but the UMLnotations are now becoming standardized for most purposes.In this book we gave you a taste of UML in Chapters 2 and 3. We then formallyintroduced use case diagrams in Chapter 4, class diagrams in Chapter 5,interaction, state and activity diagrams in Chapter 8, and the remainingdiagrams in Chapter 9. As a software engineer, you should feel fluent at usingthese diagrams to represent any design that comes to your mind.We have also pointed out that the diagrams are more than just pretty pictures:they should be used to help you create better designs and implementations. InChapters 5 and 6, for example, we showed many examples of good object- Lethbridge.book  Page 464  Tuesday, November 16, 2004  12:22 PM<page> Section 12.6465Theme 6: Incorporating quantitative and logical thinking
oriented design that would have been hard to communicate without UML classdiagrams. In Chapter 8, we showed an example piece of code that implements astate and a sequence diagram: without the diagrams, we would have been muchmore likely to make a mistake in the code. In Appendix A, we provide a summary of the parts of UML syntax we haveintroduced in this book.
12.5 Theme 5: Evaluation of alternatives in requirements and design
In Chapter 9, we pointed out that design is a systematic problem-solvingprocess. Many engineering problems involve evaluating the advantages anddisadvantages of several alternatives, and then deciding which alternative leadsto the best solution to the problem.As early as Chapter 2, we started to train you to think in this way. There wereseveral exercises where we asked you to evaluate the pros and cons of differentdesign alternatives for a Point class. In Chapter 3 we presented the client–serverarchitecture and discussed the pros and cons of thin-client versus fat-clientalternatives.In Chapter 4, we pointed out that you should evaluate competing softwarewhen doing domain analysis. We also showed you examples of carefullydocumenting the rationale for decisions you make when establishingrequirements.In Chapters 5and 6, we emphasized the process of evaluation while modeling.For example, we asked you to justify your multiplicity decisions. We alsopointed out that the process of choosing a pattern requires evaluating whetherthat pattern correctly balances the ‘forces’ .Evaluation of alternatives is central in user interface design. In Chapter 7 wesuggested that you follow a process of parallel design so as to explicitly capturedifferent alternatives. Y ou can then evaluate these alternatives by observingusers, and by determining the extent to which the designs adhere to usabilityprinciples.In Chapter 9, we presented several principles of design that can serve as aguide in making design decisions, and we discussed cost–benefit analysis as asystematic evaluation process.
12.6 Theme 6: Incorporating quantitative and logical thinking
We taught you to think in a quantitative way in several places in this book. Weintroduced metrics in Section 2.10, describing them as well-defined methods andformulae for computing values of interest to a software engineer. We pointed outthat computing metrics for its own sake is not very useful: it is important to havea goal, and compute metrics that will help you achieve that goal.In Chapter 2 we introduced a variety of metrics you can use to judge theinternal quality of your programs. Lethbridge.book  Page 465  Tuesday, November 16, 2004  12:22 PM<page> Section 12.9467Theme 9: Risk management in all software engineering activities
12.8 Theme 8: Communicating effectively using documentation
Communication is central to software engineering. Y ou must communicatewith customers and users in order to develop requirements and refine the userinterface. Y ou must communicate with managers and subordinates as part ofproject management. And you must communicate your designs to othersoftware engineers who will be implementing them, interfacing to them ormodifying them in future.All of these communication activities require writing some form ofdocumentation. Throughout the book, we suggested the kinds of informationthat should be put in each type of document. In Chapter 2 we trained you tobecome used to using documentation by looking up information about Java.Looking up specifications in reference manuals is a hallmark of engineering. InChapter 4 we described domain analysis documents and requirements documents,and gave detailed examples of the latter. In Chapter 9 we presented designdocuments, and again gave an example. In Chapter 10 we discussed how to writea test plan and test cases. Finally, in Chapter 11, we indicated the kind ofinformation that should be present in a project plan.Although we suggested what should be contained in each type of document,we pointed out that organizations tend to have their own standards. Thecontent, and the accessibility of that content to your audience, should be givenpriority over rigidly following a format.We also stressed the importance of carefully reviewing documents. InChapter 4 we gave a long list of things to look for in a requirements document.In Chapter 10 we discussed inspecting documents.
12.9 Theme 9: Risk management in all software engineering activities
We have presented a selection of software engineering risks at the end of eachchapter. According to Barry Boehm (in ‘Software risk management: principlesand practices’ , IEEE Software 8 (1), pp. 32–41, January 1991), the following arethe top ten risks that software engineers have to face. Note that this is anextension of the list of root causes of software defects, given in Section 10.11.1.Personnel shortfalls. Software developers and project managers often lacksufficient training or experience to develop a system successfully. This in turnleads to many of the risks listed below. Improving personnel training andeducation is probably, therefore, the easiest way to reduce long-term risk. Ifpeople with sufficient skill are simply not available, however, then the onlysolution is to reduce the scope of the project. Planning and development effortestimation as presented in Chapter 11 are therefore the key to reduce thisimportant risk.2.Unrealistic schedules and budgets. There is a tendency, probably intrinsic tohuman nature, to believe you can get more done than is really possible. This is Lethbridge.book  Page 467  Tuesday, November 16, 2004  12:22 PM<page> 468Chapter 12
Review 
partly due to not fully appreciating the details and complexity of the proposedsystem, and partly due to the fact that the early prototyping stages can appearto produce results extremely fast, leading to over-optimism. Sometimes, beliefin an unrealistic schedule can persist up to the planned delivery date, givingrise to a well-known ‘joke’ that would be funny if it were in fact false: manysoftware developers estimate their percent done in stages – they report thatthey are 20% done, 40% done, 80% done, 99% done, 99% done, 99% done…The solution to this problem is to better understand the requirements, asdiscussed in Chapter 4, and to better manage the project using the techniquesfrom Chapter 11.3.Developing the wrong software functions. This arises from inadequaterequirements analysis. The consequences are software that does not solve thecustomer’s problem, software that is not used, and endless requests for change,leading to deterioration of the design. The solution is better requirementsanalysis, following the principles discussed in Chapter 4, as well as developingin smaller iterations. It is particularly important to develop prototypes and tointeract closely with users, as discussed in Chapter 7.4.Developing the wrong user interface. This means developing a user interfacethat is not usable for the task at hand and for the intended users. It might be thecase, for example, that the interface is efficient for use by experts, yet mostusers are not experts and find it hard to learn. The solution to this problem is tofollow the user-centered design techniques and usability principles discussed inChapter 7.5.Gold-plating. We mentioned this in Chapter 4: gold-plating occurs when youhave requirements that are not necessary to solve the problem. The solution isto be disciplined about cutting such requirements and to focus on developingsoftware that is ‘good enough’ .6.Permitting a continuing stream of requirements changes . This was another problem we discussed in Chapter 4. It takes considerable discipline to specify agood set of requirements initially so as to minimize the need for changes. Italso takes discipline to say no to requests for non-critical changes (or to deferthem). Often the requester of the change has a good argument about why thechange would be good idea, and it is hard to comprehend the fact that, one byone, a series of changes can seriously impact your ability to deliver the systemon time. There is a well-known saying: ‘How does a project get to be one yearlate? One day at a time. ’ In Chapter 4 we emphasize the importance of clearlydefining the scope of the problem; sticking to this definition helps to keep theproject focused and to resist the temptation of adding extra features.7.Shortfalls in externally performed tasks. ‘Contracting out’ is an acceptedmanagement approach to reduce costs and take advantage of externalexpertise. However, if you contract out the development of part of your system,you must ensure that your contractor follows the software engineering Lethbridge.book  Page 468  Tuesday, November 16, 2004  12:22 PM<page> Section 12.10469Where next?
principles discussed in this book. One way to do that is to require that they becertified under ISO-9000 or the CMM, as discussed in Chapter 10. Y ou shouldalso carefully and regularly evaluate the work done by contractors, and takecorrective action if shortfalls are detected. Performing integration tests andacceptance tests, as discussed in Chapter 10, is a good way to assess the qualityof the work done.8.Shortfalls in externally furnished components . As mentioned in Chapter 3, reusing components developed by others is essential to reduce developmentcosts and simplify design. However, you need to perform acceptance testingand other quality assurance activities, as discussed in Chapter 10, to ensure thereused components do not become an Achilles’ heel for you.9.Real-time performance shortfalls. In Chapter 4, we pointed out that it isessential to define real-time performance in the requirements. Designing real-t i m e  s y s t e m s  s o  a s  t o  e n s u r e  t h a t  t h e i r  t i m i n g  c o n s t r a i n t s  a r e  a l w a y s  m e t ,however, is a very difficult technical problem. There are advanced techniquesto help prevent such failures, but when failures occur they can be catastrophic.We briefly discussed testing for such problems as deadlocks and critical racesin Chapter 10, but you should read a real-time design book if you intend todesign or test such systems.10.Straining computer science capabilities. This means trying to compute thingsthat intrinsically take an increasingly large amount of CPU time or memory, orwould naturally require a very complex design. Some kinds of problems areknown to be ‘difficult’ using today’s technology. Technology being developed atthe forefront of computer science may in the future help resolve some of theseproblems; examples of such technology include DNA computing, quantumcomputing and artificial intelligence techniques. Meanwhile, learning aboutalgorithm analysis and advanced design techniques will help you avoid thisrisk. Also, as we mentioned in Chapter 4, producing prototypes is a good wayto determine the feasibility of very challenging requirements.
12.10 Where next?
This brings us to the end of the book. However, we hope you will continue yourstudies in software engineering. As we mentioned at the beginning of the book,our intent has been to give you a broad overview of software engineering, withenough depth in areas such as UML and object orientation, so that you canimmediately apply what you have learned in the work environment.After reading this book, you should now be primed to learn about many areasof software engineering in much more depth. For example, there is much moreto be learned about software design and architecture, user interface design,quality assurance and project management. Y ou will also want to learn aboutadvanced techniques in which discrete mathematics or statistics can be appliedto software engineering, such as formal specification methods and reliability Lethbridge.book  Page 469  Tuesday, November 16, 2004  12:22 PM<page> 470Chapter 12
Review 
engineering. Many of you will want to study specialized techniques that can beapplied to develop real-time or data-processing systems. Finally, you will wantto learn more about how to conduct your work in a professional manner – withconcern for customers, users, your employer, your peers and society as a whole. We therefore hope you will continue your studies, both as your formaleducation continues, and as you embark on a lifelong professional developmentprocess. Lethbridge.book  Page 470  Tuesday, November 16, 2004  12:22 PM<page> 473 Summary of the UML notation used in this book
State diagrams (Section 8.2)
Activity diagrams (Section 8.3)
Use case diagrams (Section 4.6)
arm/turnOnSensors
disarm/  turnOffSensorspasswordErrors > 3setdisturbance[strength <= threshold]/ logDisturbancedo/ flashWarningdisturbance[strength > threshold]/soundAlarmafter(200s)Setting
DisarmedMonitoring
RingingAlarm
exit/  turnOffAlarm offArmedStartstateStateTransition Superstate Activity in stateEventConditionaltransitionEnd state Action on transitionSelftransitionGuardcondition
Action on exit from state
Elapsed timetransition
Substate
DatabaseLogfile
[not dbLocked][dbLocked]Lock database
Write databaseLock logfile
Write logfile[logLocked][not logLocked]SwimlaneForkActivityRendezvousJoin
Decision node
«extend» «include»Ordinary User
SystemAdministratorOpen file bybrowsing
Browse for fileOpen file bytyping name
Attempt to open filethat does not existOpen file Actor
S
ub-actorExtensionof use caseUse caseSpecialized use case
Includeduse case Lethbridge.book  Page 473  Tuesday, November 16, 2004  12:22 PM<page> 474 Appendix A
Package diagrams (Section 9.4)Component diagrams (Section 9.5)Deployment diagrams (Section 9.5)
simplechat1
client
commonocsf
client
server«import»PackageNestedpackageDependency
Client ServerComponentImplemented interface Used interface
TCP/IPClient1:Client2:Machine1:
Client2:Client1:Server:Machine2:NodeCommunicationassociationIncludedcomponent Lethbridge.book  Page 474  Tuesday, November 16, 2004  12:22 PM<page> BBSummary of the documentationtypes recommended in this book
Throughout this book we have suggested what various types of documentationshould contain. The following is a quick reference guide that will help softwareengineers remember the kinds of information they should include. Eachorganization should adopt more comprehensive format standards so as toensure uniformity, although overly rigid formats should be avoided.When writing documents, remember that their objective is effectivecommunication, therefore keep the intended audience in mind, be as concise aspossible, and pay attention to organization and clarity of the writing. Eachdocument should also include, at the beginning, the name of the authors, aversion number and a history of changes. This will ensure that changemanagement is done properly. 
Domain analysis document (Chapter 4)
A.Introduction. Name of the domain; reasons for the analysis.B.Glossary. Meanings of terms used in the domain.C.General knowledge about the domain. Important facts or rules: scientificprinciples; business processes; analysis techniques; how any technology works.D.Customers and users. Those who will or might buy the software, and in whatindustrial sectors they operate. Others who work in the domain.E.The environment. Equipment and systems used.F.Tasks and procedures currently performed. What people do as they go abouttheir work, including shortcuts they take. Lethbridge.book  Page 475  Tuesday, November 16, 2004  12:22 PM<page> 476 Appendix B
G.Competing software. Software already in use, and on the market.H.Similarities across domains and organizations. What is generic versus what isspecific to this organization.
Requirements document (Chapter 4)
A.Problem. A succinct description of the problem the system is solving.B.Background information. Whatever will help readers understand therequirements – references to domain analysis documents, standards andthe requirements of related subsystems; important issues you considered,and the rationale for your decisions.C.Environment and system models. Context and global overview; hardware onwhich the system will run; other subsystems or software with which it willinteract.D.Functional requirements. The services provided to the user and to othersystems – inputs, outputs, computations and timing.E.Non-functional requirements. Constraints that must be imposed on the designof the system – response time; resource usage; reliability; availability; recoveryfrom failure; allowances for maintainability; enhancement and reusability;platform; technology and development process to be used.
Use case (Chapter 4)
A.Name. Short and descriptive.B.Actors. Users or other systems that can perform this use case.C.Goals. What the actor or actors are trying to achieve.D.Preconditions. The state of the system before the use case – any conditions thatmust be true before an actor can initiate this use case.E.Summary. What occurs as the actor or actors perform the use case.F.Related use cases. Use cases that may be generalizations, specializations,extensions or inclusions.G.Steps. Use a two-column format, with the left column showing the actionstaken by the actor, and the right column showing the system’s responses.H.Postconditions. The state the system is in following completion of the use case.
Design document (Chapter 9)
A.Purpose. The system or part of the system this design document describes;references to the requirements. Lethbridge.book  Page 476  Tuesday, November 16, 2004  12:22 PM<page>  477 Summary of the documentation types recommended in this book
B.General priorities. Priorities used to guide the design process.C.Outline of the design. High-level description of the design.D.Major design issues. For each issue, the alternatives that were considered, thefinal decision and the rationale for the decision.E.Details of the design. Whatever else should be understood by implementers,maintainers and those who will interface to the system.
T est case (Chapter 10)
A.Identification and classification. Test case number; descriptive title; the system,subsystem or module being tested; reference to related requirements anddesign documents; importance of the test case.B.Instructions. Tell the tester exactly what to do – how to put the system into therequired initial state and what inputs to provide.C.Expected result. What the system should do in response to the instructions.D.Cleanup (when needed). How to make the system go ‘back to normal’ .E.Purpose. Problem to be solved; business objectives.
Project plan (Chapter 11)
A.Background information. Brief history of the project to date; stakeholders;references to related projects and any documents produced so far, such asrequirements definitions.B.Processes to be used. Overall process model; techniques for requirementsgathering, design, implementation, quality assurance, change management,risk management, and project management; documents to be produced; waysto measure and track the project. (These can all be pointers to standards.)C.Subsystems and releases. Division of the system into subsystems and releasesthat can be allocated to people or teams. (This can employ references to therequirements or architectural model.)D.Risks and challenges. Risks and difficulties that are expected to be most criticalto this project; how they are to be monitored and resolved.E.Tasks. List of tasks to be completed.F.Cost estimates. Cost estimates for the tasks and subsystems.G.Team. Team structure; skills needed; training plan; allocation ofresponsibilities.H.Schedule and milestones. Deadlines for completion of tasks; Gantt and PERTcharts allocating tasks to people, showing the times they will work on each task,and showing the critical path(s). Lethbridge.book  Page 477  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 478  Tuesday, November 16, 2004  12:22 PM<page> 480 Appendix C
technology and Internet access to a map database to provide a driver with routemaps of various levels of detail, as well as spoken directions to guide the driverto his or her destination.
Airline Reservation System
Ootumlia Airlines runs sightseeing flights from Java Valley, the capital ofOotumlia. The reservation system keeps track of passengers who will be flyingin specific seats on various flights, as well as people who will form the crew. Forthe crew, the system needs to track what everyone does, and who superviseswhom. Ootumlia Airlines runs several daily numbered flights on a regularschedule. Ootumlia Airlines expects to expand in the future, therefore thesystem needs to be flexible; in particular, it will be adding a frequent-flier plan.
Bank Accounts Management System
This system provides the basic services to manage bank accounts at a bankcalled OOBank. OOBank has many branches, each of which has an address andbranch number. A client opens accounts at a branch. Each account is uniquelyidentified by an account number; it has a balance and a credit or overdraft limit.There are many types of accounts, including: a mortgage account (which has aproperty as collateral), a checking account, and a credit card account (which hasan expiry date and can have secondary cards attached to it). It is possible to havea joint account (e.g. for a husband and wife). Each type of account has aparticular interest rate, a monthly fee and a specific set of privileges (e.g. abilityto write checks, insurance for purchases etc.). OOBank is divided into divisionsand subdivisions (such as Planning, Investments and Consumer); the branchesare considered subdivisions of the Consumer Division. Each division has amanager and a set of other employees. Each customer is assigned a particularemployee as his or her ‘personal banker’ .
Elections Management System
The Ootumlia Elections Commission is designing a system to manage elections.The system will manage elections for a variety of different elected bodies (e.g.school boards, city councils, etc.). Each elected body can have various positions(also called seats, e.g. mayor, councilor, etc.). Elections are scheduled for aspecific date, and usually several (or all) positions are voted on together;however, sometimes there may be the need for a by-election (e.g. to elect aparticular councilor because the incumbent – the previous person who held theposition – has resigned).The system will keep track of candidates for each seat. The system will alsorecord who is the incumbent for a seat, since newspaper reporters are interestedin reporting whether incumbents have won again or lost. The system records thename and address of each candidate and incumbent.The system will also keep track of the list of eligible voters. Each voter can onlyvote for certain positions (e.g. a particular council seat that represents their Lethbridge.book  Page 480  Tuesday, November 16, 2004  12:22 PM<page> 481 System descriptions
area). Each voter is also assigned to vote at a specific poll – each poll has anumber and is located in a polling station. The system records the name andaddress of each voter.Finally, the system will keep track of the number of votes for each candidateat each poll. However, under no circumstance will it record which voter votedfor which candidate, nor whether a voter voted at all.
Geographical Information System
A  s y s t e m  u s e d  b y  m a p  m a k e r s  a t  t h e  G o v e r n m e n t  o f  O o t u m l i a  c o n t a i n sinformation about various maps. Each map has a scale, a name and a set offeatures. Each map also has information that defines the latitude and longitudeof the top left corner of the map, and the height and width of the map in meters.Features can be of three types: point features, curve features and regionfeatures. In general, all features have a name that is displayed on the map next tothe feature.A point feature has a single coordinate, the location at which it is to appear onthe map. Examples of point features include transmission towers, mountainpeaks, etc. Each type of point feature has a special symbol associated with it; thissymbol is a simple bitmap.A curve feature contains a list of points that define its path. Examples of curvefeatures are roads, railways and rivers. Each type of curve feature has a linepattern associated with it. The line pattern specifies the color, the line thickness,the length of dashes in the line, and the length of gaps in the line.A region feature is very similar to a curve feature, except that when drawn onthe map, it encloses a complete region (the last point connects to the first point).Additionally, it has an optional fill pattern which is a simple bitmap or a color.
Investments System for OOBank
OOBank has a separate investment division. This division manages variousmutual funds in which investors may invest and also looks after the investmentportfolios of investors.An investor may at any point in time have several investment advisors. Thesehelp the investor decide in what to invest. Different investment advisorsspecialize in different types of investments.Investors make a series of transactions and may have to pay a commission oneach transaction. The commission is paid to the investment advisor thatarranged the transaction.For each investment the system must keep track of the number of shares (alsocalled units) in addition to the amount the investment is worth today and theamount originally invested.Each mutual fund invests its money in various securities. The securities canbe stocks, bonds or other mutual funds. We must be able to calculate the originalamount invested in each security as well as how much that investment is wortht oda y .  Ea c h  m u t ual  fu n d  m a y  h a v e  sev e r al  i n v e s tm e n t  a d vi so r s  th a t  h e l p  th efund decide what securities in which to invest. Lethbridge.book  Page 481  Tuesday, November 16, 2004  12:22 PM<page> 482 Appendix C
The mutual funds in which investors invest may be managed by OOBank orb y  s o m e  o t h e r  c o m p a n y .  E a c h  m u t u a l  f u n d  c o m p a n y  m a y  m a n a g e  s e v e r a lmutual funds.
Manufacturing Plant Controller
This system will be used to manage and control the production processes at UseCase Industries’ manufacturing plant. The plant makes several types ofmechanical devices. It has 10 assembly lines, each of which can be used in themanufacturing of any of its products. An assembly line is allocated to a productfor a fixed period of time (anywhere from a few hours to a few days) – this iscalled a product run. During a product run, the assembly line makes a specifiednumber of units of the product.Each product is assembled in several steps. As the product-under-construction moves down the assembly line, it will be worked on in turn by aseries of robots. Each robot completes one step before the product moves on tothe next step (and a different robot). Each robot is dedicated to just onemanufacturing step.Each product is composed of parts. Parts may be bought from suppliers, orthey may in fact be smaller products that are built by this company (in earlierproduct runs). In each manufacturing step, a given subset of these parts is puttogether. Parts waiting for assembly are kept in numbered bins; the robots knowwhich bins to go to in order to get the required parts.Each completed assembly is given a serial number. When orders for productsare filled, the serial numbers of the products sold are recorded with the order.
Corporate Event Information System
This program will allow the employees of Ootumlia airlines to keep themselvesinformed of the various events that are organized by and for companymanagement and employees. Events can be meetings as well as social events.
Woodworking design system
This program is designed to let carpenters, cabinet makers and other woodcraftspeople perform computer aided design. The system allows you to makeand store any number of designs. Designs can also have design variants (most ofthe design is the same) but some parts have substitutions.A design comprises a series of atomic components (pieces of wood, metalhardware attached to the wood, and a few other types of things). Designs arealso broken down into a hierarchy of assemblies. Assemblies and componentscan also be reused in different assemblies.Each piece of wood is described in terms of its 3-D geometry, therecommended type of wood, and the sequence of cuts and other operationsrequired in order to make it. The 3-D geometry is described in terms of arcs andline-segments that connect to each other at vertices. A group of arcs or line- Lethbridge.book  Page 482  Tuesday, November 16, 2004  12:22 PM<page> 483 System descriptions
segments outline a face. Junctions between pieces of wood are described interms of the faces that touch each together.The system allows its users to do a wide variety of operations to create and editdesigns. Also, the system can visually display a design (or assembly, orcomponent) in three dimensions (allowing the user to rotate it in space), and asvarious two-dimensional projections. Lethbridge.book  Page 483  Tuesday, November 16, 2004  12:22 PM<page>  Lethbridge.book  Page 484  Tuesday, November 16, 2004  12:22 PM<page> DGlossary
The numbers in square brackets are the sections where eachitem is discussed. Words in italics are cross-references to otherglossary items. Y ou will find an extended cross-linked‘knowledge base’ containing this information and much moreon the book’s web site (www.lloseng.com). 80–20 rule[4.9] A rule that states that 80% of the benefit can often beobtained with 20% of the work; the remaining 20% of thebenefit then takes 80% of the work. Also called the Pareto principle, it is used to justify cutting less important requirements to significantly reduce costs. It also applies in many other situations; for example 80% of the CPU time is spent executing20% of the statements.Abstract class[2.6] A class that cannot have any instances, and defines a set ofmethods that must be implemented. Contrast with concrete class, and interface.Abstract operation[2.6] An operation in a class that makes logical sense for allsubclasses, but that is not implemented (i.e. has no method) inthe class.Abstraction[2.1 and 9.2] A representation that captures only essentialaspects of something, reducing the complexity apparent to theabstraction’s user.Abstraction–Occurrence[6.2] A pattern in which two classes are related by a 1–manyassociation, and the first class represents an abstraction of thesecond.Acceptability[7.3] The extent to which customers and users like a system. Acceptance testing[10.9] Testing performed by customers, on their own initiative,to decide whether software is sufficiently acceptable to pay for. Lethbridge.book  Page 485  Tuesday, November 16, 2004  12:22 PM<page> 486 Glossary
Action[8.2] In a state diagram, something that takes place effectivelyinstantaneously when a transition occurs, or upon entry or exitfrom a state.Activation box[8.1] A box on a lifeline in a sequence diagram indicating the period of time during which an object is performing work. Seelive activation.Activity[8.2] Something that occurs over a period of time and takesplace while the system is in a state.Activity diagram[8.3] A UML diagram showing sequences of activities; it typically shows multiple threads.Actor[4.6] A role that a user or some other system plays wheninteracting with your system; a class of user of a system.Adapter[6.8] A pattern found in class diagrams in which you are able toreuse an ‘adaptee’ class by providing a class (the adapter) thatdelegates to the adaptee. It is useful when the adaptee could nothave been used directly because its interface does not matchwhat users of the adapter expected.Adaptive maintenance[1.6] A type of maintenance performed to change software sotha t i t will wo rk in an al ter ed en vir o nmen t, such as when anoperating system, hardware platform, compiler, softwarelibrary or database structure changes. Maintenance that ispurely adaptive does not result in new capabilities for the user,except the ability to operate the software in the changedenvironment.Affordance[7.3] The set of operations that the user can do in a userinterface at any given point in time.Aggregate[5.6] The class on the ‘whole’ side of an aggregation. Aggregation[5.6] An association which specifies that instances of one classcontain instances of the other class as parts. In a UML class diagram, an aggregation is shown as a diamond next to the‘whole’ end of the association.Agile approach[1.8, 11.2] A development process that is disciplined butlightweight. Such approaches are characterized by many shortiterations, test-first development, and similar techniques.eXtreme Programming (XP) is the most well-known suchapproach.Algorithmic costestimation[11.3] An approach to cost estimation such as COCOMO or Function Points, which uses mathematical formulas whoseparameters are based on industrial experience. Lethbridge.book  Page 486  Tuesday, November 16, 2004  12:22 PM<page> 488 Glossary
variable). (2) [10.8] In testing, something that is testable; adetail of the requirements.Availability[4.5] A quality that measures the amount of time that a system is running and able to provide services to its users. See alsoreliability.Beta testing[10.9] Testing performed by the user or client in their normalwork environment.Big bang testing[10.9] An inappropriate approach to integration testing in which you take the entire integrated system and test it as a unit.Black-box testing[10.3] A form of testing in which you manipulate inputs andobserve outputs, but cannot observe the internals of the entitybeing tested. In contrast to glass-box testing. Bottom-up design[9.1] An approach to design in which you start by designing thelow-level details such as the utilities, and then decide how thesewill be put together to create successively higher-levelcomponents, and ultimately the entire system. In contrast totop-down design.Bottom-up testing[10.9] A incremental testing strategy in which you start bytesting the very lowest levels of the software using drivers, andthen work upwards, as you integrate successive layers. Boundary testing[10.3] A testing strategy based on testing at the boundaries ofequivalence classes, where most defects occur.Brainstorming[4.7] The process of obtaining ideas, opinions, and answers to aquestion in a group environment in which all members of thegroup are given the opportunity to contribute.Broker[9.6] An architectural pattern in which parts of the system aretransparently distributed to different nodes of a network.Budgeted cost of workperformed[11.5] See earned value.Bug[10.1] A colloquial term for defect or failure.Build[10.9] The process of compiling and integrating all thecomponents of the software, incorporating any changes sincethe last build.Burdened cost[11.3] See weighted average cost.Business process[4.10] A process performed by people in an organization.Software systems often automate business processes. Lethbridge.book  Page 488  Tuesday, November 16, 2004  12:22 PM<page> 490 Glossary
Cohesion[9.2] A measure of the extent to which related aspects of asystem are kept together in the same module, and unrelatedaspects are kept out. An important design principle is toincrease cohesion. See also coupling and modularity, as well as the various types of cohesion: functional, layer, communicational, sequential, procedural, temporal and utility. Communication diagram[8.1] A UML interaction diagram showing a set of objectsconnected by communication links. Formerly called acollaboration diagram.Combinatorial explosion[10.3] In the context of testing, the observation that the numberof required tests for exhaustive testing will increaseexponentially as the number of inputs increases.Combined Fragment[8.1] A group of messages in a sequence diagram that are treated specially; for example they may be optional or repeated.Represented by a box with a code in the top-left cornerindicating the kind of fragment.Commercial off-the-shelfsoftware[1.1] A term for generic software, often abbreviated as COTS. Common coupling[9.2] A form of coupling in which components share data usinga global variable and thus become dependent on each other.Communication link[8.1] In a communication diagram, a line drawn between eachpair of objects involved in the sending of a message. Communicational cohesion[9.2] A form of cohesion in which procedures that access thesame data are kept together.Component[9.1] Any piece of software or hardware that has a clear role andcan be isolated, allowing you to replace it with a differentcomponent with equivalent functionality.Component diagram[9.5] A UML diagram showing components and their relationships.Composite[6.3] A specialization of the general hierarchy pattern that usesan aggregation instead of an ordinary association.Composition[5.6] A strong kind of aggregation in which if the aggregate is destroyed, then the parts are destroyed as well.Concrete class[2.6] A class that can have instances. In contrast to abstract class. Concurrent engineeringmodel[11.2] A process model in which each team works on its owncomponent, typ
ically following a spiral or evolutionary approach. Lethbridge.book  Page 490  Tuesday, November 16, 2004  12:22 PM<page> 492 Glossary
various types of coupling: content, common, control, stamp, routine call, type use, data, inclusion, import, and external. Coverage[10.3] A measure of the percentage of either paths, statementsor branches taken by a set of tests.Critical path[11.5] A path through a PERT chart indicating the minimumtime in which it is possible to complete a project, and the tasksthat, if delayed, will delay the whole project.Critical race[10.5] A defect in which one thread or process can sometimesexperience a failure because another thread or processinterferes with the ‘normal’ sequence of events.Custom software[1.1] Software that is developed to meet the specific needs of aparticular customer (in contrast to generic software). Customer[1.4] A person who makes decisions about ordering and payingfor software (in contrast to a user); the customer is the one whohas the problem that is being solved by the development ofsoftware. Also called a client.Data coupling[9.2] A form of coupling in which one component passes simple data to another as an argument.Data processing software[1.1] Software used for running businesses, managing data such as payroll, purchases, sales, product inventory etc.Decision Node[8.3] A diamond-shape node in an activity diagram that represents a decision. It has one incoming arrow, and multipleoutgoing arrows, each with a guard. Flow must follow one of theoutgoing paths. Compare to fork and merge node. Deadlock[10.5] A failure in which two or more processes or threads are stopped, waiting for each other to do something before eithercan proceed.Defect[10.1] A flaw in any aspect of the system, including therequirements, the design or the code, that contributes, or maypotentially contribute, to the occurrence of one or morefailures. A defect is also known as a fault. See also error. Defensive design[9.2] Design with awareness that other components cannot be trusted.Delegation[6.7] A pa
ttern in which one procedure does nothing more thancall another in a neighboring class.Delphi technique[11.3] An approach to cost estimation in which severalindividuals initially make cost estimates in private, and thenshare their estimates to discover the discrepancies. Lethbridge.book  Page 492  Tuesday, November 16, 2004  12:22 PM<page> 493 Glossary
Deployment[1.7] The process of distributing and installing software as wellas any other components of a system; deployment also includesmanaging the transition from any previous system.Deployment diagram[9.5] A UML diagram showing hardware nodes, how they areinterconnected, and what components will exist on them at runtime.Design[9.1] The problem-solving process whose objective is to findand describe a way to implement the system’s functional requirements, while respecting the constraints imposed by thequality requirements, platform requirements and process requirements, and while adhering to general principles ofgood quality. Often the term is used to refer to a design document.Design by contract[9.2] An approach to design in which each method has a contract with its callers regarding preconditions, postconditions and invariants.Design decision[9.1] A decision made in the process of design which involveslisting design options, evaluating them according to pre-determined criteria, and choosing the alternative that has thebest cost–benefit trade-off.Design document[9.1] Documentation produced as a result of design. Design issue[9.1] A sub-problem of the overall design problem.Design option[9.1] An alternative solution to a design issue.Design pattern[6.1] A pattern useful for the design of software.Design space[9.1] The space of possible design options.Detailed design[1.7] The design of the internals of individual subsystems.Deterioration[1.1] The tendency of software to accumulate defects as timepasses due to errors being made during maintenance. Development effort[11.3] See effort.Development process[4.5 and 11.2] The process used by a particular project,normally following some process model.Dialog[7.4] (1) A specific window with which a user can interact, butwhich is not the main UI window; also called a dialog box. (2)The back-and-forth interaction between user and computer. Distributed system[3.4] A system in which computations are performed byseparate programs that co-operate to perform the task of thesystem as a whole. Lethbridge.book  Page 493  Tuesday, November 16, 2004  12:22 PM<page> 495 Glossary
Elapsed time[11.3] The difference in time from the start date to the end dateof a task or project.Elapsed-time transition[8.2] A transition that occurs in a state diagram due to the passage of a period of time.ElicitationSee requirements elicitation.Embedded software[1.1] Software that is designed to run specific hardware devices,and thus is embedded in the devices, usually in a form of read-only memory (ROM). Much embedded software is also real- time software.Encapsulation[2.7] Creating a module to contain some algorithm or datastructure, thus hiding its details behind the module’s interface.See also information hiding.Encoding technique[7.3] In a user interface, a way of representing information so asto communicate it to the user; e.g. using text, color, icons,grouping, sound etc. Also known as ‘coding technique’ .Engineer[1.3] A person who performs engineering. The term engineer islegally reserved, in many jurisdictions, for those who haveobtained engineering education and experience, and performengineering within a company or else have been granted alicense, or some other form of certification, to offer engineeringservices to the public. See also professional engineer. Engineering[1.3] The process of solving problems by applying, in adisciplined, systematic and ethical way, scientific and economicknowledge and principles to the design and maintenance of products or processes. See also software engineering. Enhancement[1.6] A type of maintenance performed to add a new capabilityto software.Equivalence class[10.3] A set of inputs that a tester believes will be treatedsimilarly by reasonable algorithms.Equivalence class testing[10.3] A testing strategy based on determining the possibleequivalence classes and creating a test case for each.Error[10.1] (1) A slip or inappropriate decision made by a softwareengineer that leads to the introduction of a defect into the system. (2) A mistake made by a user. (3) An inaccuracy in anumerical computation. See also failure and defect. Event[8.2] In a state diagram, something that causes a system orobject to change state. May be a message, the passage of elapsedtime, a condition becoming true, or completion of an activity. Lethbridge.book  Page 495  Tuesday, November 16, 2004  12:22 PM<page> 496 Glossary
Evolution[1.6] The process by which software is modified over the courseof its lifetime to meet changing requirements and as problemsare fixed or re-engineering is performed. This term is oftenpreferred in place of maintenance when describing the entire setof changes made to a system.Evolutionary model[11.2] A process model that views development as a series ofhills, each representing a separate loop of the spiral model. Exception[2.6] A situation that arises in a program requiring specialhandling, and hence deviation from the normal path of control.Extension use case[4.6] A use case that makes optional interactions explicit orhandles exceptional cases.External coupling[9.2] A form of coupling in which a software component has adependency to software written by a third party, to theoperating system, or to a particular type of hardware.eXtreme programming[11.2] An agile process model and methodology that provides adisciplined approach to highly incremental and user-centereddevelopment of small projects.Façade[6.9] A pattern in which you create a class that provides asimplified interface to a package. Users of the Façade class willhave reduced coupling to the package.Factory[6.13] A pattern that enables a framework to create instances ofan application specific class.Failure[10.1] An unacceptable behavior exhibited by a system. See alsodefect and error.Fat-client system[3.4] A client–server system in which the client does a large amount of computation. In contrast to thin-client system. Feature(1) [1.6] An identifiable set of requirements that can be addedto (or removed from) a system as a unit; (2) [2.5] A method or a variable defined in a class. Also sometimes called a member orproperty.Feedback[7.3] Any response in the system’s user interface to a user’sactions.Filter[9.6] A component that inputs simple data, processes it andoutputs data of a similar kind. See the pipe-and-filter architectural patternFlow graph[10.3] A graph showing all possible paths through an algorithm. Lethbridge.book  Page 496  Tuesday, November 16, 2004  12:22 PM<page> 497 Glossary
Force[6.1] In a pattern, an issue or concern that you need to considerwhen solving the problem, including criteria for evaluating agood solution.Fork[8.3] A symbol in an activity diagram indicating splitting ofcontrol into multiple threads.Formal method[5.7] An approach to software engineering in which everythingis specified in logic, and mathematical techniques are used toverify the logic.Formal language[4.8 and 5.7] A language that uses mathematics for the purposeof modeling.Framework[3.3] A skeletal software component that performs functionsneeded by a class of systems, and which is intended to beincorporated into the design of such systems. See also reuse. Function Points[11.3] An algorithmic cost estimation method in which youcount features of the requirements and use these to compute anestimate of the system’s size.Functional cohesion[9.2] A form of cohesion in which modules which togetherperform a function (a computation that returns a result and hasno side effects) are kept together, and everything else is kept out.Functional requirement[4.5] A requirement that describes a service provided by asystem. See also quality requirement, platform requirement, process requirement and non-functional requirement. Gantt chart[11.5] A diagram used to graphically present the start and enddates of each software engineering task; it shows time on oneaxis, and tasks on the other.General hierarchy[6.3] A pattern in which two classes are related both by ageneralization and by a one to many association, such that thegenerated graph of instances forms a hierarchy.Generalization[2.5 and 5.4] (1) The relationship between a classifier andanother classifier that contains a subset of the features of theformer. The former is considered a kind of the latter. In a UMLclass diagram, the generalization relationship between asubclass and a superclass is indicated by a small triangle pointingtowards the superclass. Generalizations are also found in use case diagrams. (2) The process of creating the above.Generalization set[5.4] A label on a group of generalizations that describes thecriteria used to specialize a superclass into two or more subclasses. Lethbridge.book  Page 497  Tuesday, November 16, 2004  12:22 PM<page> 499 Glossary
Host[3.5] A computer on a network.Host name[3.5] An alphanumeric name given to a host, normally dividedinto several components separated by dots. The components ofthe name following the first dot are called the domain. The host name can often be used interchangeably with the computer’s IPaddress.Hung system[10.5] A system that appears to the user to not be doinganything, caused by such things as a crash, a deadlock, a livelock or an infinite loop.Identity[2.7] The characteristic of having a distinct existence, such thateach entity can be uniquely referred to.Immutable[6.10] A pattern in which the instances of a class cannot changestate after creation.Impact analysis[10.9] The process of exploring and documenting all possibleeffects of a change.Implementation[1.7] The process of converting a design into an executablesoftware system by programming and related activities.Implicit requirement[10.1] A requirement not stated explicitly in the requirementsdocument.Import coupling[9.2] A form of coupling in which one component declares thatit imports (makes use of the definitions in) another. Importcoupling, as found in Java, is similar to inclusion coupling, as found in C++.Inclusion[4.6] A use case that captures commonality among a set of otheruse cases.Inclusion coupling[9.2] A form of coupling in which one component includes thesource code of another component. All the includers of acomponent are coupled to each other and to the included file.See also import coupling.Incremental development[11.2] A process model in which the software is developed in aseries of releases.Incremental testing[10.9] A integration testing strategy in which you testsubsystems in isolation, and then continue testing as youintegrate more and more subsystems (see also top-down testing, bottom-up testing, and sandwich testing). In contrast to big bang testing. Lethbridge.book  Page 499  Tuesday, November 16, 2004  12:22 PM<page> 500 Glossary
Information hiding[2.7 and 9.2] Hiding details so as to reduce complexity.Achieved by abstraction, modularity and encapsulation. Inheritance[2.5] The possession by one class of features defined in anotherclass, by virtue of the fact that the former class is defined to bea subclass of (to extend) the latter.Inheritance hierarchy[2.5] The hierarchy formed by the generalization relationships among a set of classes.Inspecting[10.10] A verification process that involves several peoplesystematically proceeding through a document searching fordefects. See also reviewing.Instance[2.2] A role term referring to object that is a member of a class;can also be applied to other classifiers, i.e. a scenario is an instance of a use case. This term is used when talking about anobject in the context of its class, as in, ‘Object X is an instanceof class Y’ .Instance diagram[5.5] See object diagram. Instance method[2.4] A method that executes in the context of a particularobject; it has access to the instance variables of the given object,and can refer to the object itself using the ‘this’ keyword (in Javaand C++).Instance variable[2.3] A data item present in each instance of a class, normallyused to implement associations and attributes. In contrast withclass variable.Integration testing[10.9] Testing during or following the process of integrating asystem. See also incremental testing. Interaction diagram[8.1] A sequence diagram or communication diagram used to model the dynamic aspects of a software system.Interface[2.6] (1) The public operations provided by a module for othermodules to use (see also Application Program Interface). (2) A software module in which these are listed. A class canimplement many interfaces.Internationalization[7.4] The process of ensuring that a system can be easilyadapted to different locales.IP[3.5] Abbreviation for ‘Internet Protocol’ , the low-levelprotocol used by all computers on the Internet, in whichmessages are divided into packets for delivery to a remotehost. See also TCP/IP. Lethbridge.book  Page 500  Tuesday, November 16, 2004  12:22 PM<page> 501 Glossary
IP address[3.5] The address of a computer (i.e. a host) connected to an IP network. It is composed of a series of numbers. Instead of the IPaddress, a more human-readable host name is often used. Isa hierarchy[2.5] Another term for inheritance hierarchy. ISO 9000-3[10.11] An international standard describing activities anorganization should perform in order to have an effectivesoftware development process.Iterative development[1.8 and 11.2] An approach to development by which softwareis developed in stages, with the first stage being very simple, andsubsequent stages adding more features. See also incremental development.JAD[4.7] Abbreviation for ‘Joint Applications Development’ . Anapproach to defining requirements, in which all the stakeholders meet intensively for several days in a secluded location.Join[8.3] A symbol in an activity diagram indicating a point whereseveral threads wait for each other. When all threads reach thejoin, control continues in a single thread.Layer[9.2] A subsystem that provides a set of services and has layer cohesion.Layer cohesion[9.2] A form of cohesion in which the facilities for providing oraccessing a set of services through an API or hardware interfaceare kept together. There must also be a strict hierarchy in whichhigher-level layers can access only lower-level layers.Leaf class[2.6] A class at the very bottom of an inheritance hierarchy. Learnability[7.3] The speed with which a new user can become proficientwith the system. An aspect of usability.Learning curve[7.3] A curve on a diagram that plots the time spent learning onone axis, and the amount of functionality learned on the otheraxis.Legacy system[1.6] A software system which is still undergoing evolution, but on which some or all of the original developers are no longerworking.License[1.3] A legal document authorizing the holder to perform someactivity. In many jurisdictions an engineer must hold a licenseto offer engineering services to the public. See also professional engineer.Lifeline[8.1] A dashed line in a sequence diagram indicating the periodof time during which an object exists. Lethbridge.book  Page 501  Tuesday, November 16, 2004  12:22 PM<page> 502 Glossary
Link[5.3] A reference from one object to another. An instance of anassociation. In a UML object diagram, a link is drawn as a lineconnecting two objects. In a communication diagram there arealso communication links.Listening[3.4] A state in which a server is waiting for clients to connect.Live activation[8.1] The period of time when an object is performing work.See activation box.Livelock[10.5] A failure in which a system can never get out of a limitedset of states, although it is not in deadlock.Locale[7.4] An environment where the language, culture, laws,currency and many other factors may be different.Localhost[3.5] A special host name that always refers to the currentcomputer.Localization[7.4] The process of adapting a system to a specific locale. Locking[10.5] A mechanism for reserving a resource s o  a s  t o  a v o i dinappropriate concurrent access.Maintainability[1.5] An important internal quality of software that measuresthe extent to which the software can be modified at the lowestpossible cost, that is, maintenance can be made easier.Maintenance[1.6] In the context of software, any process involvingmodifying software following its general release to users. Seealso evolution. Important types of maintenance includeadaptive maintenance, corrective maintenance, enhancement and re-engineering.Memory leak[10.6] A situation in which a program requests memory butdoes not release it when it is no longer needed.Merge Node[8.3] A diamond-shape node in an activity diagram that represents the coming together of two non-concurrent paths.Contrast with join and decision node. Message[8.1] Any information sent as a component interacts withanother, including using procedure calls, or networkcommunication. Explicitly shown in interaction diagrams. Message-OrientedArchitecture[9.6] An architectural pattern in which subsystemscommunicate by sending messages to virtual topics; othersubsystems subscribe to these topics.Method[2.4] A concrete implementation of an operation; a procedure in a class. Lethbridge.book  Page 502  Tuesday, November 16, 2004  12:22 PM<page> 503 Glossary
Methodology[5.1] A description of a process; it usually prescribes how to dothings in a step-by-step manner.Metric[2.10, 10.11] A well-defined method and formula forcomputing some value that helps a software engineer answer aquestion about a software product or process.Milestone[11.5] An important deadline date, at which a specific eventmay occur, and when a specific deliverable may be required.Mixed testing[10.9] See sandwich testing.Modal dialog[7.4] A dialog (1) that the user must dismiss before interactingwith any other window. While in the modal dialog, the systemis in a very restrictive mode.Mode[7.3] In the context of user interfaces, a state in which the UI restricts the affordance.Model(1) [5.1] A representation of a system that conveys one or moreaspects of it in an analyzable way. (2) [9.6] The functional layerin the MVC architectural pattern – the underlying classeswhose instances are to be viewed and manipulated. See alsoview and controller.Model Driven Development[9.4]. An approach to software development in which thearchitecture and design are specified by developing models. The implementation of the software is then generated automaticallyfrom the models. A special case of this is called Model DrivenArchitecture.Model–View–Controller[9.6] A architectural pattern used to separate the functionallayer of the system (the model) from two aspects of the userinterface, the view and the controller. Normally abbreviated asMVC.Modeling[5.1] The process of creating a model. Modeling is performedboth in design and requirements analysis. Modeling may useformal languages or diagrams.Modularity[2.7] The extent to which software is divided into components, called modules, which have high internal cohesion, low coupling between each other, and simple interfaces. A factor contributingto maintainability.Module[9.1] A component that is defined at the programming languagelevel, such as file, method or package.Multi-Layer[9.6] An architectural pattern in which a system is divided intolayers. Lethbridge.book  Page 503  Tuesday, November 16, 2004  12:22 PM<page> 505 Glossary
Off-by-one error[10.4] A defect in which a program inappropriately adds orsubtracts one, or inappropriately loops one too many times orone too few times.Open beta release[10.9] A version of a system released for beta testing by any member of the general public who wishes to participate.Open source[11.2] A process model in which software is developed by acommunity, and source code is distributed with the software, sothat community members can change it.Operation[2.4] The abstract notion of something that can be done byone or more classes. An operation is implemented as a set ofmethods. The word is also used in the context of what theuser can do in the user interface, i.e. part of the affordance. Operator precedence error[10.4] A defect in which an expression in a program lacksneeded parentheses, or has parentheses in the wrong place.Opportunistic approach[11.2] An unsatisfactory process model in which developers keepon modifying the software until they or their users are satisfied.Optimistic–likely–pessimistic estimation[11.3] An approach to cost estimation in which you make threeestimates for each task and for the project as a whole: anoptimistic estimate (in which everything goes well), the likelyestimate and a pessimistic estimate (where you account foreverything that could go wrong).Over-constrain[4.8] To make a decision that constrains future choices, withinsufficient justification. A typical mistake made duringrequirements analysis.Overriding[2.6] The situation where a method local to a class is used in place of a method that otherwise would have been inherited. Package(1) [9.5] A collection of modeling elements that are groupedtogether because they are logically related. (2) [2.8] A Javafacility for grouping a set of classes.Package diagram[9.5] A type of UML class diagram showing packages and their relationships.Paper prototype[4.6] A set of pictures of the user interface of a system used todemonstrate how the system would work if implemented.Parallel design[9.1] See parallel development.Parallel development[9.1] Independent development of a system or subsystem byseveral developers, with the objective of exploring design space and generating a variety of different design ideas; the best ideasare generally chosen for further development. Lethbridge.book  Page 505  Tuesday, November 16, 2004  12:22 PM<page> 506 Glossary
Paraphraser[10.10] A person in an inspection who steps through thedocument explaining it in their own words.Pareto principle[4.9] See 80–20 rule.Pattern[6.1] A widely understood and well-defined solution to aparticular type of problem. See also design pattern and architectural pattern.Pattern language[6.1] A group of interrelated patterns. Peer-to-peer[9.6] A variant of the client–server architectural pattern inwhich components can serve as both servers and clients to eachother.Perfective maintenance[1.6] A type of maintenance that includes re-engineering, and is sometimes applied more broadly to include enhancement. Person-month[11.3] A measure of effort. One person-month is the amount ofwork done by one person in one month if they are working fulltime.Personal Software Process[10.11] A disciplined approach that an individual softwaredeveloper can use to improve the quality and efficiency of his orher personal work.PERT chart[11.5] A diagram showing the sequence in which tasks must becompleted.Phased-release model[11.2] An approach to incremental development in which, after requirements gathering and planning, the project is broken intoseparate subprojects, or phases.Pilot system[11.2] A synonym for prototype.Pipe[9.6] A connection between two filters in a pipe-and-filter architecture. It joins the output of one filter to the input toanother.Pipe-and-Filter[9.6] An architectural pattern in which data in a standardformat is passed through a series of processes ( filters) that transform it in some way. Also called a transformationalarchitectural pattern.Pipeline[9.6] A series of processes that transform data in the pipe-and- filter architectural pattern.Platform requirement[4.5] A type of requirement that specifies an aspect of thetechnology that must be used or the deployment platform forthe software. See also quality requirement. Lethbridge.book  Page 506  Tuesday, November 16, 2004  12:22 PM<page> 507 Glossary
Player–role[6.4] A pattern found in class diagrams in which one class (theplayer) has several associated role classes. Instances of the roleclasses can change over the lifetime of a player. The patternreduces the need for multiple inheritance. Polymorphism[2.4] A property of object-oriented software by which anabstract operation may be performed by different methods in different classes. Polymorphism exists when several classeswhich each implement the operation either have a commonsuperclass in which the operation exists, or else implement aninterface that contains the operation.Port[3.5] A number associated with a server on a host, used by a client that wishes to connect to that server. Each server on ahost must have a different port number.Portability[9.2] The ability for software to be run in a variety of differenthardware or software environments with no or minimal changes.Postcondition[4.6] A statement that is guaranteed to be true following thesuccessful completion of some algorithm, method or use case. In contrast to precondition.Post-mortem analysis[10.11] The process of looking back at a completed project’sdesign and its development process, in order to identify thoseaspects where improvements can be made in future projects.Precondition[4.6 and 10.4] A statement that must be true before somealgorithm, method or use case is executed. In contrast topostcondition.Problem[1.2] In the broad context of software engineering, a difficulty, challenge, need or desire faced by a customer that is to be solvedby developing software.Procedural cohesion[9.2] A form of cohesion in which procedures that are called oneafter another are kept together.Procedural paradigm[2.1] An approach to software design and programming inwhich software is primarily thought of as a hierarchy ofprocedures – the root of the hierarchy is typically a mainprocedure, which calls other procedures, etc. (in contrast to theobject-oriented paradigm).ProcessAnything that operates for a period of time, normallyconsuming resources during that time and using them to createa useful result. In software engineering, the word is also appliedto mean the development process of a software project. Lethbridge.book  Page 507  Tuesday, November 16, 2004  12:22 PM<page> 508 Glossary
Process model[11.2] A general approach for organizing a project intoactivities; an aid to thinking, not a rigid prescription of the wayto do things.Process requirement[4.5] A type of requirement that specifies an aspect of the process model t h a t  m u s t  b e  f o l l o w e d .  M u s t  b e  m e a s u r a b l e .  S e e  a l s oquality requirement.Process standard[10.11] A document describing a well-respected way ofdeveloping software.Product line[3.3]. A set of products based on a common framework,designed with different sets of features so as to satisfy differentmarket needs. Professional engineer[1.3] A person who has been issued a license, by somejurisdiction, to perform engineering. See also chartered engineer. Project management[11.1] All the activities needed to plan and execute a project.Project manager[11.4] The person responsible for performing project management tasks.Project plan[11.6] A document used in project management describing all aspects of the project’s process, including the process model,tasks, risks, cost estimates, team structure and schedule.Propagation[5.6] A mechanism whereby an operation in an aggregate is implemented by having the aggregate perform that operationon its parts – in other words, the operation is propagated to theparts.PropertySee feature (2).Protocol[3.4] The languages and rules by which two programs orprocesses communicate, as in a client–server system.Prototype[1.8 and 4.7] A version of a system created primarily to learnmore about the requirements, and not intended to be the finalproduct. It normally contains only certain aspects of thesystem’s eventual functionality.Prototyping[4.7] The process of developing prototypes.Proxy[6.12] A pattern found in which a lightweight object stands inplace of a heavyweight object that has the same interface. Ittransparently loads the heavyweight object when needed.Quality[1.5] An attribute of a product or process that, if improved, wouldbetter satisfy one or more of the stakeholders of that product orservice. Examples of qualities relevant to software engineeringinclude: usability, efficiency, reliability and maintainability. When Lethbridge.book  Page 508  Tuesday, November 16, 2004  12:22 PM<page> 511 Glossary
Reusability[3.2 and 9.2] A quality that measures of the extent to which aproduct or process can be used in different contexts from whichit was originally designed.Reuse[3.2 and 9.2] The practice of using the same code or design inmore than one place. In contrast to cloning. See also reusability. Reviewing[4.9] The process of systematically proceeding through asoftware document to perform a function such as validation, or verification.Ripple effect[10.9] The situation in which removing defects causes new onesto be added.Risk management[1.8] The process of evaluating risks and taking correctiveaction, including revising plans, on a regular basis.Role(1) [5.3] A name given to one end of an association that acts as a synonym for the class at that end. (2) [6.4] A class in theplayer–role pattern whose instances can be attached to playerobjects.Root cause analysis[10.11] The process of determining the ultimate reason why asoftware engineer made the error that introduced a defect.Routine call coupling[9.2] A form of coupling in which one routine calls another.Sandwich testing[10.9] An incremental testing strategy in which you test the toplayers and bottom layers, and finally test the integrated system.It is partially bottom-up and partially top-down, hence is also called mixed testing.Scenario[4.6] An instance of a use case, involving a specific actorinstance, at a specific time and using specific data.Schedule[11.3] (1) The allocation of tasks to time periods. (2) The totalelapsed time of a project.Scheduling[11.1, 11.5] Determining the sequence of tasks, plus decidingwhen the tasks should start, and setting deadlines for when theymust be complete.Scope[4.3] The extent of a software project.Sequence diagram[8.1] A UML interaction diagram showing the sequence ofmessages exchanged by the set of objects and optionally an actor. Actors and objects are on one axis, and time is on the other.Sequential cohesion[9.2] A form of cohesion in which a series of procedures, whereone provides input to the next, are kept together. Lethbridge.book  Page 511  Tuesday, November 16, 2004  12:22 PM<page> 512 Glossary
Server[3.4] A program or process that, in response to requests fromclients, provides some kind of service.Server socket[3.5] Data in a server used to generate connections on a port. Service-OrientedArchitecture[9.6] An architectural pattern in which subsystems obtaininformation by calling on standard services available on theInternet, called Web Services. The information is typicallydelivered in XML format.Severity level[10.8] A number given to a failure, defect or test case, indicating the amount of impact it has on the user or customer.Shelfware[4.7] Software that is not used.Shrink-wrapped software[1.1] A term for generic software, so-called because it is oftensold in boxes tightly wrapped in plastic.Side effect[9.2] A change to the state of the system made by a procedure,other than merely returning a result. See also functional cohesion.Signature[5.2] The format of an operation or message, includingarguments and return value.Singleton[6.5] (1) A pattern that ensures that a certain class can have onlyone instance. (2) A class for which only one instance shouldexist.Slot[3.3] A missing part in a framework that is filled in by theapplication developer who is adapting the framework to suit hisor her needs. See also hook.Socket[3.5] Data in a client or server that represents an end of a TCP/ IP connection. A complete connection has two sockets, one inthe client and one in the server.Software[1.1] Programs and related data that run on a computer. Seealso custom, data processing, embedded, generic and real-time software.Software architecture[9.5] (1) The process of designing the global organization of asoftware system, including dividing software into subsystems, deciding how these will interact, and determining theirinterfaces. (2) Documentation produced as a result of thisprocess (the architectural model). (3) The field of study of howto effectively do the above.Software construction[11.3] See construction. Lethbridge.book  Page 512  Tuesday, November 16, 2004  12:22 PM<page> 518 Glossary
View[9.6] In the MVC architectural pattern, the class or classes usedto render the appearance of the data from the model in the userinterface.Waterfall model[11.2] A process model in which the software engineer works ina series of stages. The basis for many process models, but notthe recommended model to use in modern softwareengineering. In contrast to incremental development and iterative development.Weighted average cost[11.3] The cost of employing a person, including the cost ofbenefits, office and management support. Also called burdened cost.Web service[9.6] A service available on the Internet, delivered using thehttp protocol, and designed to be used by applications, asopposed to end users. Data is normally delivered in XMLformat. See service-oriented architecture. White-box testing[10.3] A synonym for glass-box testing or structural testing. Widget[7.4] A synonym for user interface component and control. XML[9.6] A textual markup language in which tags are used toprovide meanings to various types of information. Lethbridge.book  Page 518  Tuesday, November 16, 2004  12:22 PM<page> EIndex
80–20 rule 149, 435, 466abstract classes 47–8abstract methods 47–8AbstractClientcallback methods 93–4private internals 94–5public interface 92–3using 94abstraction 29–31, 52–3data abstraction 30–1design 329increasing 341levels, patterns 348procedural abstraction 30–1Abstraction–Occurrence pattern 223–6exercises 225–6AbstractServercallback methods 96–7private internals 98–9public interface 95–6testing 374–6using 98acceptability 259–61acceptance testing 407–8ACM see Association for Computing Machineryaction semantics 297activity diagrams 301–2, 303adaptability see flexibilityAdapter pattern 236–8, 247adaptive projects 15affordance, UI 261aggregation 188–92agile approaches, models/modeling 433–4agile development 22–3, 466vs. conventional development 18agile documentation 23, 145aircraft disasterBritish Midland Flight 92; 258USS Vincennes 281aircraft landing-gear, algorithms defects 380–3airline systemclass diagrams 207, 215–17classes 204Delegation pattern 234–6flight booking associations 177–8generalization 209responsibilities 211–12Transaction-Processing pattern 352–3algorithmscontrol constructs 384decimal defects 389–91defects 380–91error build up 389–91evaluation 337–9floating-point errors 389–91inappropriate 387–8logical conditions 380–4loops 384–5maximum values storage 389–91non-singleton conditions 386null conditions 385numerical 388–91off-by-one errors 386–7preconditions 385recursions 384–5reuse 68singleton conditions 386testing 380–91alpha testing 407–8alternatives 465client–server architecture 78–80design 336–40evaluating 21–2Application Program Interface (API) 72architecting software 309–69architectural patterns 347–62Broker 351–2Client–Server 349–51Message-Oriented 360–2Model-View-Controller 355–7Multi-Layer 347–9 Lethbridge.book  Page 519  Tuesday, November 16, 2004  12:22 PM<page> 520 Index
Pipe-and-Filter 353–5Service-Oriented 358–60summary 463Transaction-Processing 352–3transformational 353–5architectureclient–server 77–87quality 338–9software see software architectureAriane-5, disaster 414Association for Computing Machinery (ACM), ethics 9associations 36–7, 53, 173–81analysing 176–80association classes 179–80directionality 181exercises 178–9, 191flight booking 177–8identifying 205–8labeling 175–6links 181N-ary 196reflexive associations 180–1ternary 196valid 176–80, 205attributes 36–7, 53enumerating 400–1identifying 205–8quality 11–14responsibilities 202test cases 400–1valid 205–8availability 124banking application, objects 32basing development, principles 21behaviorbooks 307difficulties 306Internet sites 307–8modeling 285–308project exercises 308risks 306beta testing 407–8big bang testing 402–3black-box testing 373–6booksdesign 368engineering profession 28failure 422frameworks 103inspection 423Java principles 63–4metrics 64networking 104object-oriented development processes 219–20OO principles 63–4patterns 251–2process standards 423programming 64project management 456requirements 166reuse 103software engineering 27–8standards 423, 457testing 422UI 282UML 219usability 282bottom-up design 313bottom-up testing 404–5brainstorming, gathering requirements technique 142–4Broker architectural pattern 351–2bugslaw of conservation of bugs 407modification side effect 3see also defects; error; testingC++, terminology 38, 49Canadian Standards Association, software engineering definition 8changeclass 184–5constant 25requirements 155–6class diagramsairline system 207, 215–17CRC cards 212–13developing 212–13difficulties 218vs. entity–relationship diagrams 199 Lethbridge.book  Page 520  Tuesday, November 16, 2004  12:22 PM<page> 521 Index
essentials 172–3exercises 185, 187–8, 215features 188–93genealogy 196–8generalization 185Java 216–17object diagrams 186–8risks 218sequence of activities 201–2summary of notation 471–2symbols 172–3Class–Responsibility–Collaboration (CRC) cards 212–13class variablesvs. instance variables 37–8terminology 37–8classes 52, 53, 173airline system 204changing 184–5geometric points 57–60identifying 202–5inheritance hierarchies 39–45instances 33–5modeling with 169–220and objects 31–6organizing 39–45responsibilities, allocating 210–12terminology 35–6client capabilities, client–server systems 82–3client–server architecture 77–87alternatives 78–80architectural pattern 349–51client capabilities 82–3concurrency 83–4examples 79exercises 80–7fat-client systems 84–5Internet sites 104messages 86–7network concepts 87–9project exercises 104–7protocols 86–7risks 102server capabilities 81–2systems 77tasks 87technology 87–90thin-client systems 84–5client side, OCSF 92–5clients see customerscloningdesign 331, 332objects vs. code 332clutter, usability 266CMM™ see Software Capability Maturity Modelco-ordination defects 391–4cohesion principle, design 315–21collaborations, communication diagrams 292common coupling 323, 324communication diagrams 290–2choosing 291–2collaborations 292patterns 292communication, documentation 467communication systems, client–server systems 79communicational cohesion 316, 318–19complexity 24measuring 60–2component diagrams 346componentsdefining 311–12projects 15–16Composite pattern 228composition 188–92concurrent engineering model 432configuration management 20configurations defects 395ConnectionToClientprivate internals 98–9public interface 97using 98constraints 192–3content coupling 322–4contingencies, cost estimation 442–4control constructs, algorithm defects 384control coupling 323, 325controls, UI 261conventional development, vs. agile development 18corrective projects 15cost–benefit analysis, design 339–40cost estimation 435–45conflict resolution 446 Lethbridge.book  Page 521  Tuesday, November 16, 2004  12:22 PM<page> 522 Index
contingencies 442–4divide and conquer principle 437experience principle 437–40extrapolation pitfalls 440–2false analogies 440inclusion principle 437independent estimates 444–5Murphy’s Law 442non-linearity 439principles 436–45project management 435–45revising/refining principle 445software process 435–45uncertainty 446worst case anticipation 442–4couplingdesign 321–9exercises 328–9course registration, frameworks 73crash recovery defects 396–7CRC cards see Class-Responsibility-Collaboration cardscreep, requirements 156critical races 393–4custom software 3–6customerssoftware engineering stakeholders 10–11testing 407–8understanding 20, 256–8data abstraction 30–1data coupling 323, 326–7data processing software 5–6database systems, client–server systems 79deadlock 391–3decimal defects, algorithms 389–91decisions, design 310–11, 336–40defectsalgorithms 380–91co-ordination 391–4defining 372documentation 398numerical algorithms 388–91stress 394–7timing 391–4unusual situations 394–7defensive design 334–6defining the problem 16Delegation pattern 234–6Law of Demeter 236Demeter, Law of 236demographics, users 257dependencies, UML 196deployment 19–20deployment diagrams 347descriptive text 192–3design 17–18, 309–69abstraction 329alternatives 336–40books 368bottom-up 313cloning 331, 332cohesion principle 315–21cost–benefit analysis 339–40coupling 321–9decisions 310–11, 336–40defensive 334–6defining 310design space 310–11deterioration 25difficulties 366–7divide and conquer principle 314–15documentation 362–5evaluation 336–40exercises 320–1flexibility 331–2instant messaging 365–6Internet sites 368objectives 336–9obsolescence 332–3portability 333–4principles 314–36prioritizing 336–9process 310–13project exercises 368–9reusability 330reuse 331risks 366–7SimpleChat 365–6special types 313subsystems 312testability 334top-down 313design patterns 221–52Abstraction–Occurrence 223–6Adapter 236–8 Lethbridge.book  Page 522  Tuesday, November 16, 2004  12:22 PM<page> 523 Index
Composite 228Delegation 234–6Façade 238–9Factory 243–6General Hierarchy 226–8Immutable 239–40Observer 232–4Player–Role 228–31Proxy 241–3Read-Only Interface 240–1Singleton 231–2summary 463detailed design 17deterioration, design 25developing requirements 109–68development managers, software engineering stakeholders 10–11diagrams, frames/labels 178dialog, UI 261difficultiesbehavior 306class diagrams 218design 366–7domain analysis 164–5interactions 306patterns 250–1project management 453–5QA 420–1requirements 164–5reusable technology 101–2software engineering 24–6UCD 280directionality, associations 181disabilities, usability 267disastersAriane-5; 414British Midland Flight 92; 258project management 427radiation therapy 414spaceflight 414Therac-25; 414USS Vincennes 281see also failurediscriminators, terminology 182distributed systems 77divide and conquer principlecost estimation 437design 314–15documentationagile 23, 145communication 467defects 398design 362–5project management 452–3project plan 452–3requirements 145–8summary 475–7domain analysis 16, 109–14benefits 110difficulties 164–5document 112–13exercises 113–14risks 164–5sections 110–13domain models 199–201dynamic and behavioral modeling 18dynamic binding, variables 50–1e-commerce, frameworks 73earned value charts, project scheduling/tracking 451–2efficiency 11–14, 62–3, 259–61elapsed-time transitions, state diagrams 294–5email, client–server systems 79embedded software 3–6encapsulation 53encoding techniques, UI 261–2engineering profession, Internet sites 28enhancement 124enhancement projects 15entity–relationship diagrams, vs. class diagrams 199equivalence classesboundaries 380combinations 378–80strategy 376–8testing 376–80error build up, algorithms 389–91error, defining 372error handling 259–61see also bugs; testingerror messages, usability 264ethics 9networks 103usability testing 276evaluationalgorithms 337–9 Lethbridge.book  Page 523  Tuesday, November 16, 2004  12:22 PM<page> 524 Index
alternatives 21–2design 336–40heuristic 273–4vs. quality assurance 273UI 273–6usability testing 274–6evolution, languages 62–3evolutionary model 431–2evolutionary projects 14–15exceptions, testing 373experience principle, cost estimation 437–40expertise, reuse 68exploratory domain models 199–201external attributes, quality 11–14external coupling 323extrapolation pitfalls, cost estimation 440–2eXtreme Programming (XP) 18tenets 433–4users 254Façade pattern 238–9Factory pattern 243–6failuredefining 372Internet sites 422recovery from 124see also disastersfat-client systems 84–5feedbackUI 261usability 264first order logic 194flexibilitydesign 331–2teams 446–7flight booking associations 177–8floating-point errors, algorithms 389–91formal methods 194frames/labels, diagrams 178frameworksbooks 103course registration 73defining 72e-commerce 73examples 75–6exercises 76–7frequent buyer clubs 73horizontal 74–5object-oriented 75payroll management 72product lines 73projects 15–16reuse 68, 71–7vertical frameworks 74–5frequent buyer clubs, frameworks 73functional cohesion 315–17functional requirements 119–23, 154–5GANA see GPS-based Automobile Navigation AssistantGantt charts, project scheduling/tracking 450–1gathering requirements 17, 138–45genealogyclass diagram 196–8exercises 198General Hierarchy pattern 226–8generalization 39, 182–5airline system 209class diagrams 185generalization sets 182–4identifying 208–9unnecessary 182generic software 3–6geometric points, classes 57–60glass-box testing 373–6glossary 485–518glue code 16, 68–9Goals, Questions, Metrics (GQM) 61goals, users 256GPS-based Automobile Navigation Assistant (GANA) 156–60, 340, 443, 450–2, 480GQM see Goals, Questions, Metricsgraphical user interface (GUI)implementing 276–80Java 276–80green field projects 15guard conditions, state diagrams 299GUI see graphical user interfaceheuristic evaluation 273–4hierarchies, teams 446–7history, object-orientationmethods and notations 172programming languages 54horizontal frameworks 74–5 Lethbridge.book  Page 524  Tuesday, November 16, 2004  12:22 PM<page> 525 Index
hotel reservation system, project exercises 167–8, 220, 252, 283, 308, 424identity 52IEEE Computer Societyethics 9software engineering definition 8Immutable pattern 239–40implementing classes 51–2import coupling 323, 328inclusion coupling 323, 328inclusion principle, cost estimation 437incremental testing 402–3independent estimates, cost estimation 444–5information hiding 53inheritance 52defining 40multiple 184inheritance hierarchiesclasses 39–45effects 45–52exercises 43–5mathematical objects 42polymorphism 45–52variable declarations 45–52inspection 409–13meetings 411–12peer-review process 411principles 409–11roles 409cf. testing 412see also reviews; testinginstance variables 36–8vs. class variables 37–8terminology 37–8instancesassociations see linksclasses 33–5terminology 35instant messagingdesign 365–6GUI 276–80OCSF 99–100requirements 160–4test cases 416–20integration testing 402–3interaction diagrams 285–92implementing classes 302–6messages 286interactionsdifficulties 306Internet sites 307–8modeling 285–308project exercises 308risks 306interface, user see user interfaceinternal criteria, quality 13–14internationalization, usability 267Internet, Internet site 104Internet sitesbehavior 307–8client–server architecture 104design 368engineering profession 27failure 422interactions 307–8Internet 104Java 64patterns 251product lines 104project management 456QA 422, 423requirements 166reuse 103software engineering 27standards 457testing 422UML 219–20interviewing, gathering requirements technique 139–41IP (Internet Protocol) addresses, finding 87–9isa hierarchies 39ISO 9000-3, QA 415iterative development 22–3, 466JAD see Joint Application DevelopmentJavaclass diagrams 216–17connections 89–90GUI 276–80Internet sites 64JUnit 399MVC 357principles, books 63–4project exercises 64–5tools 64 Lethbridge.book  Page 525  Tuesday, November 16, 2004  12:22 PM<page> 526 Index
Joint Application Development (JAD), gathering requirements technique 144JUnit, Java 399knowledge, prior, users 257landing-gear, aircraft, algorithms defects 380–3language evolution 62–3large systems, testing 402–9law of conservation of bugs 407Law of Demeter, Delegation pattern 236layer cohesion 316, 317–18learnability 259–61libraries, reuse 68library system 127–8links, associations 181Liskov Substitution Principle 41livelock 391–3localization, usability 267, 268logical conditions, algorithm defects 380–4logical thinking 22, 465–6long-term quality 14loops, algorithm defects 384–5magazines, software engineering 26–7maintainability 11–14, 124managing projects 20many-to-many associations 176–7mathematical objects, inheritance hierarchy 42–3maximum values storage, algorithms 389–91MDA see Model Driven Architecturemeasuring 22, 436, 439complexity 60–2GQM 61quality 60–2, 123–4, 372, 414usability 259–60memory leaks 397Message-Oriented architectural pattern 360–2Message-Oriented Middleware (MOM) 360–2messagesclient–server systems 86–7interaction diagrams 286see also instant messagingmethodologies, terminology 171methods 38–9, 53terminology 171metrics see measuringminimal configurations, defects 395modal dialog, UI 261mode, UI 261Model Driven Architecture (MDA) 341model driven development 340–2Model-View-Controller (MVC) architectural pattern 355–7models/modelingagile approaches 433–4approaches 18choosing 435with classes 169–220concurrent engineering model 432contents 343–4developing 344–5domain models 199–201evolutionary model 431–2importance 342–3open source model 434–5phased-release model 430project management 428–35RUP 432–3skills 218software process 428–35software process models 428–35spiral model 430–1waterfall model 22–3, 428–9see also Unified Modeling Languagemodularity 53modules, defining 312MOM see Message-Oriented MiddlewareMulti-Layer architectural pattern 347–9multiple inheritance 184multiplicity 173–81exercises 178–9Murphy’s Law, cost estimation 442MVC see Model-View-Controller architectural patternN-ary associations 196nested substates, state diagrams 299network concepts, client–server systems 87–9network file systems, client–server systems 79networks, ethics 103Newton, Isaac 69non-functional requirements 123non-linearity, cost estimation 439 Lethbridge.book  Page 526  Tuesday, November 16, 2004  12:22 PM<page> 527 Index
non-singleton conditions, algorithm defects 386notes 192–3null conditions, algorithm defects 385numerical algorithms, defects 388–91Object Client–Server Framework (OCSF) 91–100client side 92–5instant messaging 99–100Observable layer 247–50patterns 246–50server side 95–9testing 404–5Object Constraint Language (OCL)basics 193–6exercises 195object diagramsclass diagrams 186–8exercises 187–8Object Management Group (OMG) 172object-orientation (OO)history 172review 29–65object-oriented analysis (OOA) 32object-oriented development processes, books 219–20object-oriented frameworks 75object-oriented paradigm, defining 31object-oriented testing 409objectives, design 336–9objects 53and classes 31–6examples 32terminology 35vs. variables 37Observable layer, OCSF 247–50Observer pattern 232–4observing, gathering requirements technique 139obsolescence, design 332–3OCL see Object Constraint LanguageOCSF see Object Client–Server Frameworkoff-by-one errors, algorithm defects 386–7offshoring 2OMG see Object Management Groupone-to-many associations 176one-to-one associations 177–8operations 38–9, 53identifying 213–15operator precedence errors, algorithm defects 387opportunistic approach, software development 428overriding 48–9extension 49optimization 49restriction 48–9packages 345–6pair programming 19, 434patents, software 455patternsabstraction levels 348books 251–2communication diagrams 292defining 222, 223difficulties 250–1exercises 228Internet sites 251OCSF 246–50patterns community 223project exercises 252resources 251–2risks 250–1summary 463see also architectural patterns; design patternspatterns of use, users 256–7payroll management, frameworks 72peak loads defects 395–6peer-to-peer systems 77perfection 150perfective projects 15Personal Software Process (PSP™), QA 415PERT charts, project scheduling/tracking 449–50phased-release model 430physical ability, users 257PIM see Platform Independent Model (PIM)Pipe-and-Filter architectural pattern 353–5Platform Independent Model (PIM) 341–2platform requirements 124–7Platform Specific Model (PSM) 341–2Player–Role pattern 228–31exercises 231political risks 25–6polymorphism 38–9, 52defining 38inheritance hierarchies 45–52portability, design 333–4 Lethbridge.book  Page 527  Tuesday, November 16, 2004  12:22 PM<page> 528 Index
post-mortem analysis, QA 415postal codes 55–7preconditions, algorithm defects 385principlesbasing development 21cost estimation 436–45design 314–36inspection 409–11Java 63–4summary 460–2usability 262–72prioritizing, design 336–9problem, defining 115–19procedural abstraction 30–1procedural cohesion 316, 320procedural paradigm 30–1process requirements 124–7process standardsbooks 423QA 415–16processes, terminology 171product linesframeworks 73Internet sites 104programming 18–19pair 19project exercises 64–5project exercisesbehavior 308client–server systems 104–7design 368–9hotel reservation system 220interactions 308Java 64–5patterns 252programming 64–5project management 457requirements 167–8UI 282–3see also exercisesproject management 425–57activities 425–7books 456chaos 436cost estimation 435–45difficulties 453–5disasters 427documentation 452–3Internet sites 456models/modeling 428–35project exercises 457project scheduling/tracking 449–52risks 453–5teams 445–9project plan, documentation 452–3project scheduling/trackingearned value charts 451–2Gantt charts 450–1PERT charts 449–50projectsactivities 16–20components 15–16evolutionary 14–15frameworks 15–16green field 15managing 20problem, defining 115–19scope 115–19software engineering 14–16starting points 114–15protocols, client–server systems 86–7prototyping, gathering requirements technique 144–5proving correct, vs. testing 402Proxy pattern 241–3PSM see Platform Specific ModelPSP™ see Personal Software Processpsychological traits, users 257publications, software engineering 26–8QA see quality assurancequalifiers, UML 196qualityattributes 11–14external attributes 11–14internal criteria 13–14long-term 14measuring 60–2short-term 14software 3, 7, 11–14quality assurance (QA) 19, 413–16continuous improvement 414–15difficulties 420–1vs. evaluation 273Internet sites 422, 423post-mortem analysis 415 Lethbridge.book  Page 528  Tuesday, November 16, 2004  12:22 PM<page> 529 Index
process standards 415–16risks 420–1root cause analysis 413–14quality requirements 123–4quantitative thinking 22, 465–6radiation therapy, disasters 414Rational Unified Process (RUP), models/modeling 432–3re-engineering projects 15re-engineering, software process 435Read-Only Interface pattern 240–1real-time software 5–6recovery from failure 124recursions, algorithm defects 384–5refactoring 18, 434reflexive associations 180–1regression testing 406reliability 11–14, 124remote display systems, client–server systems 79requirements 16–17acceptable 149–51agile approaches 145analysis 17, 164–5books 166changing 155–6creep 156defining 119developing 109–68difficulties 164–5documentation 145–8example 153–4, 156–164exercises 154–5functional 119–23, 154–5gathering 17, 138–45instant messaging 160–4Internet sites 166measuring 156non-functional 123platform 124–7process 124–7project exercises 167–8quality 123–4restaurant advisor system 153–4reviewing 148–55risks 164–5SimpleChat 160–4standards 167subsystems 148types 119–27uncertainty 25unnecessary 150resource management defects 396resource usage 123response time 123usability 265–6responsibilitiesairline system 211–12allocating to classes 210–12attributes 202restaurant advisor system, requirements 153–4reusability 11–14, 21allowances 124design 330incorporating 69–71reusable technology 67–107difficulties 101–2risks 101–2reuse 68–9algorithms 68books 103complete applications 68–9design 331expertise 68finding components 71frameworks 68, 71–7incorporating 69–71Internet sites 103libraries 68standard designs 68vicious cycle 70–1review, themes 459–70reviwingrequirements 148–53see also inspectionsrevising/refining principle, cost estimation 445ripple effect, testing 406–7risk management 24, 467–9risksbehavior 306choice, programming languages 62–3class diagrams 218client–server systems 102design 366–7domain analysis 164–5interactions 306 Lethbridge.book  Page 529  Tuesday, November 16, 2004  12:22 PM<page> 530 Index
patterns 250–1political 25–6project management 453–5QA 420–1requirements 164–5reusable technology 101–2software engineering 24–6UCD 280root cause analysis, QA 413–14routine call coupling 323, 327RUP see Rational Unified Processsandwich testing 405–6satellite navigation 156–60scenarios, use cases 138scope, defining 115–19sequence diagrams 286–90choosing 291–2sequence of activities, class diagrams 201–2sequential cohesion 316, 319server capabilities, client–server systems 81–2server side, OCSF 95–9Service-Oriented architectural pattern 358–60short-term quality 14SimpleChatdesign 365–6GUI 276–80OCSF 99–100requirements 160–4test cases 416–20singleton conditions, algorithm defects 386Singleton pattern 231–2exercises 232skillsteams 448–9uncertainty 25softwarecrisis 3custom 3–6data processing 5–6embedded 3–6generic 3–6nature of 1–6quality 3, 7, 11–14real-time 5–6terminology 5types 3–6software architecture 17, 338–9, 342–7defining 342Software Capability Maturity Model (CMM™), QA 415software developers, software engineering stakeholders 10–11software engineeringdefining 6–8difficulties 24–6as engineering profession branch 8–10ethics 9Internet sites 27projects 14–16risks 24–6stakeholders 10–11software patents 455software processcost estimation 435–45managing 425–57models/modeling 428–35re-engineering 435software projects, starting points 114–15spaceflightdisaster 414successes 415specialization 39specification 16–17spiral model 430–1stakeholderssoftware engineering 10–11software quality 12stamp coupling 323, 325–6standard designs, reuse 68standardsbooks 423, 457Internet sites 457requirements 167starting points, software projects 114–15state diagrams 292–300actions 297–8activities 297–8elapsed-time transitions 294–5exercises 296–7, 299–302guard conditions 299implementing classes 302–6nested substates 299state, UI 261 Lethbridge.book  Page 530  Tuesday, November 16, 2004  12:22 PM<page> 531 Index
stress defects 394–7structural modeling 18subclasses 39subsystemsdefining 312–13requirements 148successes, software 415summaryarchitectural patterns 463design patterns 463documentation 475–7patterns 463principles 460–2UML notation 471–4superclass 39, 53synergy 45–52system descriptions 479–83system domain models 199–201system models 199–201systems, defining 312systems engineering 17tagged values 213task analysis, vs. use case 129TCP/IP (Transmission Control Protocol/Internet Protocol) 87–9Team Software Process (TSP™), QA 415teamsexercises 449flexibility 446–7hierarchies 446–7size 447–8skills 448–9team building 445–9technology uncertainty 25templates, UML 196temporal cohesion 316, 320terminologyC++ 38, 49class variables 37–8classes 35–6discriminators 182instance variables 37–8instances 35methodologies 171methods 171objects 35processes 171software 5UI 261–2ternary associations 196test cases 398–402attributes 400–1contents 398–9importance levels 399instant messaging 416–20SimpleChat 416–20test-first development 401–2test-fix-test cycle 406test plans 398–402testability, design 334testing 371–424AbstractServer 374–6acceptance 407–8algorithms 380–91alpha 407–8beta 407–8big bang approach 402–3black-box 373–6books 422bottom-up 404–5customers 407–8definitions 371–3as detective work 376–8effective 373–80efficient 373–80equivalence classes 376–80exceptions 373glass-box 373–6incremental approach 402–3cf. inspection 412integration testing 402–3Internet sites 422large systems 402–9object-oriented 409OCSF 404–5project exercises 423–4vs. proving correct 402regression 406ripple effect 406–7roles 407sandwich 405–6stopping 406–7strategies 402–9 Lethbridge.book  Page 531  Tuesday, November 16, 2004  12:22 PM<page> 532 Index
test-fix-test cycle 406top-down 403–4users 407–8see also inspectionthemes 20–4review 459–70Therac-25, disasters 414thin-client systems 84–5throughput 123timing defects 391–4tools, Java code 64top-down design 313top-down testing 403–4trade-offs 13traffic lights, elapsed-time transitions 294–5Transaction-Processing architectural pattern 352–3transaction processing systems, client–server systems 79transformational architectural pattern 353–5TSP™ see Team Software Processtype use coupling 323, 327–8UCD see user-centred designUI see user interfaceUML see Unified Modeling Languageuncertainty, cost estimation 446understanding users 20, 256–8Unified Modeling Language (UML) 21, 169–72resources 219–20tools 220unusual situations, defects 394–7usability 11–14aspects 259–61backing out 265books 282clutter 266disabilities 267error messages 264feedback 264internationalization 267Internet sites 281–2localization 267, 268principles 262–72response time 265–6vs. utility 259usability testingethics 276evaluation 274–6use case modeling 18use cases 127–38benefits 137–8defining 127describing 129–32diagrams 132extension 132–7generalization 132–7inclusion 132–7modeling 129modeling processes 136scenarios 138vs. task analysis 129user-centred design (UCD) 254–6difficulties 280risks 280user interface (UI) 51–2, 191–2books 282design 17, 258–62evaluation 273–6example 269–73exercises 272GUI, Java 276–80identifying 208–9project exercises 282–3terminology 261–2userscharacteristics 256–8demographics 257focusing on 253–83goals 256interacting with 264knowledge, prior 257patterns of use 256–7physical ability 257psychological traits 257software engineering stakeholders 10–11testing 407–8understanding 20, 256–8XP 254utility cohesion 316, 320utility, vs. usability 259 Lethbridge.book  Page 532  Tuesday, November 16, 2004  12:22 PM<page> 533 Index
valid associations 176–80, 205valid attributes 205–8variable declarations, inheritance hierarchies 45–52variablesdynamic binding 50–1vs. objects 37vertical frameworks 74–5vicious cycle, reuse 70–1visual modeling 21, 464–5waterfall model 22–3, 428–9websites see Internet siteswidgets, UI 261World Wide Web, client–server systems 79worst case anticipation, cost estimation 442–4XP see eXtreme ProgrammingZ, logic 194 Lethbridge.book  Page 533  Tuesday, November 16, 2004  12:22 PM<page> 
Object-Oriented Software Engineering
Timothy C. LethbridgeRobert Laganière2nd edition Practical Software Developmentusing UML and Java
To access these materials, visit the Online Learning Centre at:
www.mhhe.com/lethbridge
Or visit the authors’ website dedicated to the textbook at:
www.lloseng.com• Updated to reflect the new UML 2.0 standard• Features nine contemporary themes in software engineering,such as understanding the user, iterative and agile modeling,and risk management•New section on model driven development and new coverageof web-based software architectures • A wide variety of examples and exercises throughout to providestudents with practice in tackling software engineering projectsKey features of the new edition:
• Chapter-by-chapter PowerPoint slides to supportrevision of topics •Answers to selected textbook exercises, enablingstudents to test their progress• Source code and documentation• Useful web links and further reading• A searchable glossary of key termsThe following resources are available for students:Object-Oriented Software Engineering
Practical Software Development using UML and Java, 2nd Edition 
By Timothy C. Lethbridge and Robert Laganière
This book provides the essential knowledge and skills required by students of software engineering,from the nuts and bolts of objects to software architecture, from writing code to testing, from softwaredevelopment processes to project management.Object-Oriented Software Engineering
Practical Software Development using UML and Java, 2nd EditionTimothy C. Lethbridgeand Robert LaganièreA range of Online Learning Resources accompanies Object-Oriented Software Engineering
About the authors
Timothy C. Lethbridge is Associate Professor andRobert Laganière is Assistant Professor in theSchool of Information Technology and Engineeringat the University of Ottawa, Ontario.<page>